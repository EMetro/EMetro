/*
 * Metro 4 Components Library v4.4.1  (https://metroui.org.ua)
 * Copyright 2012-2020 Sergey Pimenov
 * Built at 14/11/2020 11:04:08
 * Licensed under GPL3
 */
(function (global, undefined) {

// Source: src/mode.js

/* jshint -W097 */
'use strict';

// Source: src/func.js

/* global dataSet */
/* exported isTouch, isSimple, isHidden, isPlainObject, isEmptyObject, isArrayLike, str2arr, parseUnit, getUnit, setStyleProp, acceptData, dataAttr, normName, strip, dashedName, isLocalhost */

var numProps = ['opacity', 'zIndex'];

function isSimple(v){
    return typeof v === "string" || typeof v === "boolean" || typeof v === "number";
}

function isVisible(elem) {
    return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
}

function isHidden(elem) {
    var s = getComputedStyle(elem);
    return !isVisible(elem) || +s.opacity === 0 || elem.hidden || s.visibility === "hidden";
}

function not(value){
    return value === undefined || value === null;
}

function camelCase(string){
    return string.replace( /-([a-z])/g, function(all, letter){
        return letter.toUpperCase();
    });
}

function dashedName(str){
    return str.replace(/([A-Z])/g, function(u) { return "-" + u.toLowerCase(); });
}

function isPlainObject( obj ) {
    var proto;
    if ( !obj || Object.prototype.toString.call( obj ) !== "[object Object]" ) {
        return false;
    }
    proto = obj.prototype !== undefined;
    if ( !proto ) {
        return true;
    }
    return proto.constructor && typeof proto.constructor === "function";
}

function isEmptyObject( obj ) {
    for (var name in obj ) {
        if (hasProp(obj, name)) return false;
    }
    return true;
}

function isArrayLike (o){
    return o instanceof Object && 'length' in o;
}

function str2arr (str, sep) {
    sep = sep || " ";
    return str.split(sep).map(function(el){
        return  (""+el).trim();
    }).filter(function(el){
        return el !== "";
    });
}

function parseUnit(str, out) {
    if (!out) out = [ 0, '' ];
    str = String(str);
    out[0] = parseFloat(str);
    out[1] = str.match(/[\d.\-+]*\s*(.*)/)[1] || '';
    return out;
}

function getUnit(val, und){
    var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
    return typeof split[1] !== "undefined" ? split[1] : und;
}

function setStyleProp(el, key, val){
    key = camelCase(key);

    if (["scrollLeft", "scrollTop"].indexOf(key) > -1) {
        el[key] = (parseInt(val));
    } else {
        el.style[key] = isNaN(val) || numProps.indexOf(""+key) > -1 ? val : val + 'px';
    }
}

function acceptData(owner){
    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
}

function getData(data){
    try {
        return JSON.parse(data);
    } catch (e) {
        return data;
    }
}

function dataAttr(elem, key, data){
    var name;

    if ( not(data) && elem.nodeType === 1 ) {
        name = "data-" + key.replace( /[A-Z]/g, "-$&" ).toLowerCase();
        data = elem.getAttribute( name );

        if ( typeof data === "string" ) {
            data = getData( data );
            dataSet.set( elem, key, data );
        } else {
            data = undefined;
        }
    }
    return data;
}

function normName(name) {
    return typeof name !== "string" ? undefined : name.replace(/-/g, "").toLowerCase();
}

function strip(name, what) {
    return typeof name !== "string" ? undefined : name.replace(what, "");
}

function hasProp(obj, prop){
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

function isLocalhost(host){
    var hostname = host || window.location.hostname;
    return (
        hostname === "localhost" ||
        hostname === "127.0.0.1" ||
        hostname === "[::1]" ||
        hostname === "" ||
        hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) !== null
    );
}

function isTouch() {
    return (('ontouchstart' in window)
        || (navigator.maxTouchPoints > 0)
        || (navigator.msMaxTouchPoints > 0));
}

// Source: src/setimmediate.js

/* global global */
/*
 * setImmediate polyfill
 * Version 1.0.5
 * Url: https://github.com/YuzuJS/setImmediate
 * Copyright (c) 2016 Yuzu (https://github.com/YuzuJS)
 * Licensed under MIT
 */
(function (global) {

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var registerImmediate;

    function setImmediate(callback) {
        if (typeof callback !== "function") {
            /* jshint -W054 */
            callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        tasksByHandle[nextHandle] = { callback: callback, args: args };
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        if (currentlyRunningATask) {
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    // global.process
    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            global.process.nextTick(function () { runIfPresent(handle); });
        };
    }

    // web workers
    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    // Browsers
    function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        global.addEventListener("message", onGlobalMessage, false);

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    if ({}.toString.call(global.process) === "[object process]") {

        installNextTickImplementation();

    } else if (global.MessageChannel) {

        installMessageChannelImplementation();

    } else {

        installPostMessageImplementation();

    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;

}(typeof self === "undefined" ? typeof global === "undefined" ? window : global : self));

// Source: src/promise.js

/* global setImmediate */

/*
 * Promise polyfill
 * Version 1.2.0
 * Url: https://github.com/lahmatiy/es6-promise-polyfill
 * Copyright (c) 2014 Roman Dvornov
 * Licensed under MIT
 */
(function (global) {

    if (global.Promise) {
        return;
    }

    // 

    var PENDING = 'pending';
    var SEALED = 'sealed';
    var FULFILLED = 'fulfilled';
    var REJECTED = 'rejected';
    var NOOP = function(){};

    function isArray(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    }

    // async calls
    var asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;
    var asyncQueue = [];
    var asyncTimer;

    function asyncFlush(){
        // run promise callbacks
        for (var i = 0; i < asyncQueue.length; i++)
            asyncQueue[i][0](asyncQueue[i][1]);

        // reset async asyncQueue
        asyncQueue = [];
        asyncTimer = false;
    }

    function asyncCall(callback, arg){
        asyncQueue.push([callback, arg]);

        if (!asyncTimer)
        {
            asyncTimer = true;
            asyncSetTimer(asyncFlush, 0);
        }
    }

    function invokeResolver(resolver, promise) {
        function resolvePromise(value) {
            resolve(promise, value);
        }

        function rejectPromise(reason) {
            reject(promise, reason);
        }

        try {
            resolver(resolvePromise, rejectPromise);
        } catch(e) {
            rejectPromise(e);
        }
    }

    function invokeCallback(subscriber){
        var owner = subscriber.owner;
        var settled = owner.state_;
        var value = owner.data_;
        var callback = subscriber[settled];
        var promise = subscriber.then;

        if (typeof callback === 'function')
        {
            settled = FULFILLED;
            try {
                value = callback(value);
            } catch(e) {
                reject(promise, e);
            }
        }

        if (!handleThenable(promise, value))
        {
            if (settled === FULFILLED)
                resolve(promise, value);

            if (settled === REJECTED)
                reject(promise, value);
        }
    }

    function handleThenable(promise, value) {
        var resolved;

        try {
            if (promise === value)
                throw new TypeError('A promises callback cannot return that same promise.');

            if (value && (typeof value === 'function' || typeof value === 'object'))
            {
                var then = value.then;  // then should be retrived only once

                if (typeof then === 'function')
                {
                    then.call(value, function(val){
                        if (!resolved)
                        {
                            resolved = true;

                            if (value !== val)
                                resolve(promise, val);
                            else
                                fulfill(promise, val);
                        }
                    }, function(reason){
                        if (!resolved)
                        {
                            resolved = true;

                            reject(promise, reason);
                        }
                    });

                    return true;
                }
            }
        } catch (e) {
            if (!resolved)
                reject(promise, e);

            return true;
        }

        return false;
    }

    function resolve(promise, value){
        if (promise === value || !handleThenable(promise, value))
            fulfill(promise, value);
    }

    function fulfill(promise, value){
        if (promise.state_ === PENDING)
        {
            promise.state_ = SEALED;
            promise.data_ = value;

            asyncCall(publishFulfillment, promise);
        }
    }

    function reject(promise, reason){
        if (promise.state_ === PENDING)
        {
            promise.state_ = SEALED;
            promise.data_ = reason;

            asyncCall(publishRejection, promise);
        }
    }

    function publish(promise) {
        var callbacks = promise.then_;
        promise.then_ = undefined;

        for (var i = 0; i < callbacks.length; i++) {
            invokeCallback(callbacks[i]);
        }
    }

    function publishFulfillment(promise){
        promise.state_ = FULFILLED;
        publish(promise);
    }

    function publishRejection(promise){
        promise.state_ = REJECTED;
        publish(promise);
    }

    /**
     * @class
     */
    function Promise(resolver){
        if (typeof resolver !== 'function')
            throw new TypeError('Promise constructor takes a function argument');

        if (!(this instanceof Promise))
            throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');

        this.then_ = [];

        invokeResolver(resolver, this);
    }

    Promise.prototype = {
        constructor: Promise,

        state_: PENDING,
        then_: null,
        data_: undefined,

        then: function(onFulfillment, onRejection){
            var subscriber = {
                owner: this,
                then: new this.constructor(NOOP),
                fulfilled: onFulfillment,
                rejected: onRejection
            };

            if (this.state_ === FULFILLED || this.state_ === REJECTED)
            {
                // already resolved, call callback async
                asyncCall(invokeCallback, subscriber);
            }
            else
            {
                // subscribe
                this.then_.push(subscriber);
            }

            return subscriber.then;
        },

        done: function(onFulfillment){
            return this.then(onFulfillment, null);
        },

        always: function(onAlways){
            return this.then(onAlways, onAlways);
        },

        'catch': function(onRejection) {
            return this.then(null, onRejection);
        }
    };

    Promise.all = function(promises){
        var Class = this;

        if (!isArray(promises))
            throw new TypeError('You must pass an array to Promise.all().');

        return new Class(function(resolve, reject){
            var results = [];
            var remaining = 0;

            function resolver(index){
                remaining++;
                return function(value){
                    results[index] = value;
                    if (!--remaining)
                        resolve(results);
                };
            }

            for (var i = 0, promise; i < promises.length; i++)
            {
                promise = promises[i];

                if (promise && typeof promise.then === 'function')
                    promise.then(resolver(i), reject);
                else
                    results[i] = promise;
            }

            if (!remaining)
                resolve(results);
        });
    };

    Promise.race = function(promises){
        var Class = this;

        if (!isArray(promises))
            throw new TypeError('You must pass an array to Promise.race().');

        return new Class(function(resolve, reject) {
            for (var i = 0, promise; i < promises.length; i++)
            {
                promise = promises[i];

                if (promise && typeof promise.then === 'function')
                    promise.then(resolve, reject);
                else
                    resolve(promise);
            }
        });
    };

    Promise.resolve = function(value){
        var Class = this;

        if (value && typeof value === 'object' && value.constructor === Class)
            return value;

        return new Class(function(resolve){
            resolve(value);
        });
    };

    Promise.reject = function(reason){
        var Class = this;

        return new Class(function(resolve, reject){
            reject(reason);
        });
    };

    if (typeof  global.Promise === "undefined") {
        global.Promise = Promise;
    }
}(window));

// Source: src/core.js

/* global hasProp */

var m4qVersion = "v1.0.9. Built at 19/10/2020 18:36:03";

/* eslint-disable-next-line */
var matches = Element.prototype.matches
    || Element.prototype.matchesSelector
    || Element.prototype.webkitMatchesSelector
    || Element.prototype.mozMatchesSelector
    || Element.prototype.msMatchesSelector
    || Element.prototype.oMatchesSelector;

var $ = function(selector, context){
    return new $.init(selector, context);
};

$.version = m4qVersion;

$.fn = $.prototype = {
    version: m4qVersion,
    constructor: $,
    length: 0,
    uid: "",

    push: [].push,
    sort: [].sort,
    splice: [].splice,
    indexOf: [].indexOf,
    reverse: [].reverse
};

$.extend = $.fn.extend = function(){
    var options, name,
        target = arguments[ 0 ] || {},
        i = 1,
        length = arguments.length;

    if ( typeof target !== "object" && typeof target !== "function" ) {
        target = {};
    }

    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        if ( ( options = arguments[ i ] ) != null ) {
            for ( name in options ) {
                if (hasProp(options, name))
                    target[ name ] = options[ name ];
            }
        }
    }

    return target;
};

$.assign = function(){
    var options, name,
        target = arguments[ 0 ] || {},
        i = 1,
        length = arguments.length;

    if ( typeof target !== "object" && typeof target !== "function" ) {
        target = {};
    }

    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        if ( ( options = arguments[ i ] ) != null ) {
            for ( name in options ) {
                if (hasProp(options, name) && options[name] !== undefined)
                    target[ name ] = options[ name ];
            }
        }
    }

    return target;
};

// if (typeof window["hideM4QVersion"] === "undefined") console.info("m4q " + $.version);

// Source: src/interval.js

/* global $ */

var now = function(){
    return Date.now();
};

$.extend({

    intervalId: -1,
    intervalQueue: [],
    intervalTicking: false,
    intervalTickId: null,

    setInterval: function(fn, int){
        var that = this;

        this.intervalId++;

        this.intervalQueue.push({
            id: this.intervalId,
            fn: fn,
            interval: int,
            lastTime: now()
        });

        if (!this.intervalTicking) {
            var tick = function(){
                that.intervalTickId = requestAnimationFrame(tick);
                $.each(that.intervalQueue, function(){
                    var item = this;
                    if (item.interval < 17 || now() - item.lastTime >= item.interval) {
                        item.fn();
                        item.lastTime = now();
                    }
                });
            };
            this.intervalTicking = true;
            tick();
        }

        return this.intervalId;
    },

    clearInterval: function(id){
        for(var i = 0; i < this.intervalQueue.length; i++){
            if (id === this.intervalQueue[i].id) {
                this.intervalQueue.splice(i, 1);
                break;
            }
        }
        if (this.intervalQueue.length === 0) {
            cancelAnimationFrame(this.intervalTickId);
            this.intervalTicking = false;
        }
    },

    setTimeout: function(fn, interval){
        var that = this, id = this.setInterval(function(){
            that.clearInterval(id);
            fn();
        }, interval);

        return id;
    },

    clearTimeout: function(id){
        return this.clearInterval(id);
    }
});

// Source: src/contains.js

/* global $, not, matches, isArrayLike, isVisible */

$.fn.extend({
    index: function(sel){
        var el, _index = -1;

        if (this.length === 0) {
            return _index;
        }

        if (not(sel)) {
            el = this[0];
        } else if (sel instanceof $ && sel.length > 0) {
            el = sel[0];
        } else if (typeof sel === "string") {
            el = $(sel)[0];
        } else {
            el = undefined;
        }

        if (not(el)) {
            return _index;
        }

        if (el && el.parentNode) $.each(el.parentNode.children, function(i){
            if (this === el) {
                _index = i;
            }
        });
        return _index;
    },

    get: function(i){
        if (i === undefined) {
            return this.items();
        }
        return i < 0 ? this[ i + this.length ] : this[ i ];
    },

    eq: function(i){
        return !not(i) && this.length > 0 ? $.extend($(this.get(i)), {_prevObj: this}) : this;
    },

    is: function(s){
        var result = false;

        if (this.length === 0) {
            return false;
        }

        if (s instanceof $) {
            return this.same(s);
        }

        if (s === ":selected") {
            this.each(function(){
                if (this.selected) result = true;
            });
        } else

        if (s === ":checked") {
            this.each(function(){
                if (this.checked) result = true;
            });
        } else

        if (s === ":visible") {
            this.each(function(){
                if (isVisible(this)) result = true;
            });
        } else

        if (s === ":hidden") {
            this.each(function(){
                var styles = getComputedStyle(this);
                if (
                    this.getAttribute('type') === 'hidden'
                        || this.hidden
                        || styles.display === 'none'
                        || styles.visibility === 'hidden'
                        || parseInt(styles.opacity) === 0
                ) result = true;
            });
        } else

        if (typeof  s === "string" && [':selected'].indexOf(s) === -1) {
            this.each(function(){
                if (matches.call(this, s)) {
                    result = true;
                }
            });
        } else

        if (isArrayLike(s)) {
            this.each(function(){
                var el = this;
                $.each(s, function(){
                    var sel = this;
                    if (el === sel) {
                        result = true;
                    }
                });
            });
        } else

        if (typeof s === "object" && s.nodeType === 1) {
            this.each(function(){
                if  (this === s) {
                    result = true;
                }
            });
        }

        return result;
    },

    same: function(o){
        var result = true;

        if (!(o instanceof $)) {
            o = $(o);
        }

        if (this.length !== o.length) return false;

        this.each(function(){
            if (o.items().indexOf(this) === -1) {
                result = false;
            }
        });

        return result;
    },

    last: function(){
        return this.eq(this.length - 1);
    },

    first: function(){
        return this.eq(0);
    },

    odd: function(){
        var result = this.filter(function(el, i){
            return i % 2 === 0;
        });
        return $.extend(result, {_prevObj: this});
    },

    even: function(){
        var result = this.filter(function(el, i){
            return i % 2 !== 0;
        });
        return $.extend(result, {_prevObj: this});
    },

    filter: function(fn){
        if (typeof fn === "string") {
            var sel = fn;
            fn = function(el){
                return matches.call(el, sel);
            };
        }

        return $.extend($.merge($(), [].filter.call(this, fn)), {_prevObj: this});
    },

    find: function(s){
        var res = [], result;

        if (s instanceof $) return s;

        if (this.length === 0) {
            result = this;
        } else {
            this.each(function () {
                var el = this;
                if (typeof el.querySelectorAll !== "undefined") res = res.concat([].slice.call(el.querySelectorAll(s)));
            });
            result = $.merge($(), res);
        }

        return $.extend(result, {_prevObj: this});
    },

    contains: function(s){
        return this.find(s).length > 0;
    },

    children: function(s){
        var i, res = [];

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            for(i = 0; i < el.children.length; i++) {
                if (el.children[i].nodeType === 1)
                    res.push(el.children[i]);
            }
        });
        res = s ? res.filter(function(el){
            return matches.call(el, s);
        }) : res;

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    parent: function(s){
        var res = [];
        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            if (this.parentNode) {
                if (res.indexOf(this.parentNode) === -1) res.push(this.parentNode);
            }
        });
        res = s ? res.filter(function(el){
            return matches.call(el, s);
        }) : res;

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    parents: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var par = this.parentNode;
            while (par) {
                if (par.nodeType === 1 && res.indexOf(par) === -1) {
                    if (!not(s)) {
                        if (matches.call(par, s)) {
                            res.push(par);
                        }
                    } else {
                        res.push(par);
                    }
                }
                par = par.parentNode;
            }
        });

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    siblings: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            if (el.parentNode) {
                $.each(el.parentNode.children, function(){
                    if (el !== this) res.push(this);
                });
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    _siblingAll: function(dir, s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            while (el) {
                el = el[dir];
                if (!el) break;
                res.push(el);
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    _sibling: function(dir, s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this[dir];
            if (el && el.nodeType === 1) {
                res.push(el);
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    prev: function(s){
        return this._sibling('previousElementSibling', s);
    },

    next: function(s){
        return this._sibling('nextElementSibling', s);
    },

    prevAll: function(s){
        return this._siblingAll('previousElementSibling', s);
    },

    nextAll: function(s){
        return this._siblingAll('nextElementSibling', s);
    },

    closest: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        if (!s) {
            return this.parent(s);
        }

        this.each(function(){
            var el = this;
            while (el) {
                if (!el) break;
                if (matches.call(el, s)) {
                    res.push(el);
                    return ;
                }
                el = el.parentElement;
            }
        });

        return $.extend($.merge($(), res.reverse()), {_prevObj: this});
    },

    has: function(selector){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        this.each(function(){
            var el = $(this);
            var child = el.children(selector);
            if (child.length > 0) {
                res.push(this);
            }
        });

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    back: function(to_start){
        var ret;
        if (to_start === true) {
            ret = this._prevObj;
            while (ret) {
                if (!ret._prevObj) break;
                ret = ret._prevObj;
            }
        } else {
            ret = this._prevObj ? this._prevObj : this;
        }
        return ret;
    }
});

// Source: src/script.js

/* global $, not */

function createScript(script){
    var s = document.createElement('script');
    s.type = 'text/javascript';

    if (not(script)) return $(s);

    var _script = $(script)[0];

    if (_script.src) {
        s.src = _script.src;
    } else {
        s.textContent = _script.innerText;
    }

    document.body.appendChild(s);

    if (_script.parentNode) _script.parentNode.removeChild(_script);

    return s;
}

$.extend({
    script: function(el){

        if (not(el)) {
            return createScript();
        }

        var _el = $(el)[0];

        if (_el.tagName && _el.tagName === "SCRIPT") {
            createScript(_el);
        } else $.each($(_el).find("script"), function(){
            createScript(this);
        });
    }
});

$.fn.extend({
    script: function(){
        return this.each(function(){
            $.script(this);
        });
    }
});

// Source: src/prop.js

/* global $, not */

$.fn.extend({
    _prop: function(prop, value){
        if (arguments.length === 1) {
            return this.length === 0 ? undefined : this[0][prop];
        }

        if (not(value)) {
            value = '';
        }

        return this.each(function(){
            var el = this;

            el[prop] = value;

            if (prop === "innerHTML") {
                $.script(el);
            }
        });
    },

    prop: function(prop, value){
        return arguments.length === 1 ? this._prop(prop) : this._prop(prop, typeof value === "undefined" ? "" : value);
    },

    val: function(value){
        if (not(value)) {
            return this.length === 0 ? undefined : this[0].value;
        }

        return this.each(function(){
            var el = $(this);
            if (typeof this.value !== "undefined") {
                this.value = value;
            } else {
                el.html(value);
            }
        });
    },

    html: function(value){
        var that = this, v = [];

        if (arguments.length === 0) {
            return this._prop('innerHTML');
        }

        if (value instanceof $) {
            value.each(function(){
                v.push($(this).outerHTML());
            });
        } else {
            v.push(value);
        }

        that._prop('innerHTML', v.length === 1 && not(v[0]) ? "" : v.join("\n"));

        return this;
    },

    outerHTML: function(){
        return this._prop('outerHTML');
    },

    text: function(value){
        return arguments.length === 0 ? this._prop('textContent') : this._prop('textContent', typeof value === "undefined" ? "" : value);
    },

    innerText: function(value){
        return arguments.length === 0 ? this._prop('innerText') : this._prop('innerText', typeof value === "undefined" ? "" : value);
    },

    empty: function(){
        return this.each(function(){
            if (typeof this.innerHTML !== "undefined") this.innerHTML = "";
        });
    },

    clear: function(){
        return this.empty();
    }
});

// Source: src/each.js

/* global $, isArrayLike, hasProp */

$.each = function(ctx, cb){
    var index = 0;
    if (isArrayLike(ctx)) {
        [].forEach.call(ctx, function(val, key) {
            cb.apply(val, [key, val]);
        });
    } else {
        for(var key in ctx) {
            if (hasProp(ctx, key))
                cb.apply(ctx[key], [key, ctx[key],  index++]);
        }
    }

    return ctx;
};

$.fn.extend({
    each: function(cb){
        return $.each(this, cb);
    }
});


// Source: src/data.js

/* global acceptData, camelCase, $, not, dataAttr, isEmptyObject, hasProp */

/*
 * Data routines
 * Url: https://jquery.com
 * Copyright (c) Copyright JS Foundation and other contributors, https://js.foundation/
 * Licensed under MIT
 */
var Data = function(ns){
    this.expando = "DATASET:UID:" + ns.toUpperCase();
    Data.uid++;
};

Data.uid = -1;

Data.prototype = {
    cache: function(owner){
        var value = owner[this.expando];
        if (!value) {
            value = {};
            if (acceptData(owner)) {
                if (owner.nodeType) {
                    owner[this.expando] = value;
                } else {
                    Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true
                    });
                }
            }
        }
        return value;
    },

    set: function(owner, data, value){
        var prop, cache = this.cache(owner);

        if (typeof data === "string") {
            cache[camelCase(data)] = value;
        } else {
            for (prop in data) {
                if (hasProp(data, prop))
                    cache[camelCase(prop)] = data[prop];
            }
        }
        return cache;
    },

    get: function(owner, key){
        return key === undefined ? this.cache(owner) : owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
    },

    access: function(owner, key, value){
        if (key === undefined || ((key && typeof key === "string") && value === undefined) ) {
            return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== undefined ? value : key;
    },

    remove: function(owner, key){
        var i, cache = owner[this.expando];
        if (cache === undefined) {
            return ;
        }
        if (key !== undefined) {
            if ( Array.isArray( key ) ) {
                key = key.map( camelCase );
            } else {
                key = camelCase( key );

                key = key in cache ? [ key ] : ( key.match( /[^\x20\t\r\n\f]+/g ) || [] ); // ???
            }

            i = key.length;

            while ( i-- ) {
                delete cache[ key[ i ] ];
            }
        }
        if ( key === undefined || isEmptyObject( cache ) ) {
            if ( owner.nodeType ) {
                owner[ this.expando ] = undefined;
            } else {
                delete owner[ this.expando ];
            }
        }
        return true;
    },

    hasData: function(owner){
        var cache = owner[ this.expando ];
        return cache !== undefined && !isEmptyObject( cache );
    }
};

var dataSet = new Data('m4q');

$.extend({
    hasData: function(elem){
        return dataSet.hasData(elem);
    },

    data: function(elem, key, val){
        return dataSet.access(elem, key, val);
    },

    removeData: function(elem, key){
        return dataSet.remove(elem, key);
    },

    dataSet: function(ns){
        if (not(ns)) return dataSet;
        if (['INTERNAL', 'M4Q'].indexOf(ns.toUpperCase()) > -1) {
            throw Error("You can not use reserved name for your dataset");
        }
        return new Data(ns);
    }
});

$.fn.extend({
    data: function(key, val){
        var res, elem, data, attrs, name, i;

        if (this.length === 0) {
            return ;
        }

        elem = this[0];

        if ( arguments.length === 0 ) {
            if ( this.length ) {
                data = dataSet.get( elem );

                if ( elem.nodeType === 1) {
                    attrs = elem.attributes;
                    i = attrs.length;
                    while ( i-- ) {
                        if ( attrs[ i ] ) {
                            name = attrs[ i ].name;
                            if ( name.indexOf( "data-" ) === 0 ) {
                                name = camelCase( name.slice( 5 ) );
                                dataAttr( elem, name, data[ name ] );
                            }
                        }
                    }
                }
            }

            return data;
        }

        if ( arguments.length === 1 ) {
            res = dataSet.get(elem, key);
            if (res === undefined) {
                if ( elem.nodeType === 1) {
                    if (elem.hasAttribute("data-"+key)) {
                        res = elem.getAttribute("data-"+key);
                    }
                }
            }
            return res;
        }

        return this.each( function() {
            dataSet.set( this, key, val );
        } );
    },

    removeData: function( key ) {
        return this.each( function() {
            dataSet.remove( this, key );
        } );
    },

    origin: function(name, value, def){

        if (this.length === 0) {
            return this;
        }

        if (not(name) && not(value)) {
            return $.data(this[0]);
        }

        if (not(value)) {
            var res = $.data(this[0], "origin-"+name);
            return !not(res) ? res : def;
        }

        this.data("origin-"+name, value);

        return this;
    }
});

// Source: src/utils.js

/* global $, not, camelCase, dashedName, isPlainObject, isEmptyObject, isArrayLike, acceptData, parseUnit, getUnit, isVisible, isHidden, matches, strip, normName, hasProp, isLocalhost, isTouch */

$.extend({

    device: (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase())),
    localhost: isLocalhost(),
    isLocalhost: isLocalhost,
    touchable: isTouch(),

    uniqueId: function (prefix) {
        var d = new Date().getTime();
        if (not(prefix)) {
            prefix = 'm4q';
        }
        return (prefix !== '' ? prefix + '-' : '') + 'xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    },

    toArray: function(n){
        var i, out = [];

        for (i = 0 ; i < n.length; i++ ) {
            out.push(n[i]);
        }

        return out;
    },

    import: function(ctx){
        var res = [];
        this.each(ctx, function(){
            res.push(this);
        });
        return this.merge($(), res);
    },

    merge: function( first, second ) {
        var len = +second.length,
            j = 0,
            i = first.length;

        for ( ; j < len; j++ ) {
            first[ i++ ] = second[ j ];
        }

        first.length = i;

        return first;
    },

    type: function(obj){
        return Object.prototype.toString.call(obj).replace(/^\[object (.+)]$/, '$1').toLowerCase();
    },

    sleep: function(ms) {
        ms += new Date().getTime();
        /* eslint-disable-next-line */
        while (new Date() < ms){}
    },

    isSelector: function(selector){
        if (typeof selector !== 'string') {
            return false;
        }
        try {
            document.querySelector(selector);
        } catch(error) {
            return false;
        }
        return true;
    },

    remove: function(s){
        return $(s).remove();
    },

    camelCase: camelCase,
    dashedName: dashedName,
    isPlainObject: isPlainObject,
    isEmptyObject: isEmptyObject,
    isArrayLike: isArrayLike,
    acceptData: acceptData,
    not: not,
    parseUnit: parseUnit,
    getUnit: getUnit,
    unit: parseUnit,
    isVisible: isVisible,
    isHidden: isHidden,
    matches: function(el, s) {return matches.call(el, s);},
    random: function(from, to) {
        if (arguments.length === 1 && isArrayLike(from)) {
            return from[Math.floor(Math.random()*(from.length))];
        }
        return Math.floor(Math.random()*(to-from+1)+from);
    },
    strip: strip,
    normName: normName,
    hasProp: hasProp,

    serializeToArray: function(form){
        var _form = $(form)[0];
        if (!_form || _form.nodeName !== "FORM") {
            console.warn("Element is not a HTMLFromElement");
            return;
        }
        var i, j, q = [];
        for (i = _form.elements.length - 1; i >= 0; i = i - 1) {
            if (_form.elements[i].name === "") {
                continue;
            }
            switch (_form.elements[i].nodeName) {
                case 'INPUT':
                    switch (_form.elements[i].type) {
                        case 'checkbox':
                        case 'radio':
                            if (_form.elements[i].checked) {
                                q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            }
                            break;
                        case 'file':
                            break;
                        default: q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                    }
                    break;
                case 'TEXTAREA':
                    q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                    break;
                case 'SELECT':
                    switch (_form.elements[i].type) {
                        case 'select-one':
                            q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            break;
                        case 'select-multiple':
                            for (j = _form.elements[i].options.length - 1; j >= 0; j = j - 1) {
                                if (_form.elements[i].options[j].selected) {
                                    q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].options[j].value));
                                }
                            }
                            break;
                    }
                    break;
                case 'BUTTON':
                    switch (_form.elements[i].type) {
                        case 'reset':
                        case 'submit':
                        case 'button':
                            q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            break;
                    }
                    break;
            }
        }
        return q;
    },
    serialize: function(form){
        return $.serializeToArray(form).join("&");
    }
});

$.fn.extend({
    items: function(){
        return $.toArray(this);
    }
});

// Source: src/events.js

/* global $, not, camelCase, str2arr, normName, matches, isEmptyObject, isPlainObject */

(function () {
    if ( typeof window.CustomEvent === "function" ) return false;

    function CustomEvent ( event, params ) {
        params = params || { bubbles: false, cancelable: false, detail: null };
        var evt = document.createEvent( 'CustomEvent' );
        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
        return evt;
    }

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
})();

var overriddenStop =  Event.prototype.stopPropagation;
var overriddenPrevent =  Event.prototype.preventDefault;

Event.prototype.stopPropagation = function(){
    this.isPropagationStopped = true;
    overriddenStop.apply(this, arguments);
};
Event.prototype.preventDefault = function(){
    this.isPreventedDefault = true;
    overriddenPrevent.apply(this, arguments);
};

Event.prototype.stop = function(immediate){
    return immediate ? this.stopImmediatePropagation() : this.stopPropagation();
};

$.extend({
    events: [],
    eventHooks: {},

    eventUID: -1,

    /*
    * el, eventName, handler, selector, ns, id, options
    * */
    setEventHandler: function(obj){
        var i, freeIndex = -1, eventObj, resultIndex;
        if (this.events.length > 0) {
            for(i = 0; i < this.events.length; i++) {
                if (this.events[i].handler === null) {
                    freeIndex = i;
                    break;
                }
            }
        }

        eventObj = {
            element: obj.el,
            event: obj.event,
            handler: obj.handler,
            selector: obj.selector,
            ns: obj.ns,
            id: obj.id,
            options: obj.options
        };

        if (freeIndex === -1) {
            this.events.push(eventObj);
            resultIndex = this.events.length - 1;
        } else {
            this.events[freeIndex] = eventObj;
            resultIndex = freeIndex;
        }

        return resultIndex;
    },

    getEventHandler: function(index){
        if (this.events[index] !== undefined && this.events[index] !== null) {
            this.events[index] = null;
            return this.events[index].handler;
        }
        return undefined;
    },

    off: function(){
        $.each(this.events, function(){
            this.element.removeEventListener(this.event, this.handler, true);
        });
        this.events = [];
        return this;
    },

    getEvents: function(){
        return this.events;
    },

    getEventHooks: function(){
        return this.eventHooks;
    },

    addEventHook: function(event, handler, type){
        if (not(type)) {
            type = "before";
        }
        $.each(str2arr(event), function(){
            this.eventHooks[camelCase(type+"-"+this)] = handler;
        });
        return this;
    },

    removeEventHook: function(event, type){
        if (not(type)) {
            type = "before";
        }
        $.each(str2arr(event), function(){
            delete this.eventHooks[camelCase(type+"-"+this)];
        });
        return this;
    },

    removeEventHooks: function(event){
        var that = this;
        if (not(event)) {
            this.eventHooks = {};
        } else {
            $.each(str2arr(event), function(){
                delete that.eventHooks[camelCase("before-"+this)];
                delete that.eventHooks[camelCase("after-"+this)];
            });
        }
        return this;
    }
});

$.fn.extend({
    on: function(eventsList, sel, handler, options){
        if (this.length === 0) {
            return ;
        }

        if (typeof sel === 'function') {
            options = handler;
            handler = sel;
            sel = undefined;
        }

        if (!isPlainObject(options)) {
            options = {};
        }

        return this.each(function(){
            var el = this;
            $.each(str2arr(eventsList), function(){
                var h, ev = this,
                    event = ev.split("."),
                    name = normName(event[0]),
                    ns = options.ns ? options.ns : event[1],
                    index, originEvent;

                $.eventUID++;

                h = function(e){
                    var target = e.target;
                    var beforeHook = $.eventHooks[camelCase("before-"+name)];
                    var afterHook = $.eventHooks[camelCase("after-"+name)];

                    if (typeof beforeHook === "function") {
                        beforeHook.call(target, e);
                    }

                    if (!sel) {
                        handler.call(el, e);
                    } else {
                        while (target && target !== el) {
                            if (matches.call(target, sel)) {
                                handler.call(target, e);
                                if (e.isPropagationStopped) {
                                    e.stopImmediatePropagation();
                                    break;
                                }
                            }
                            target = target.parentNode;
                        }
                    }

                    if (typeof afterHook === "function") {
                        afterHook.call(target, e);
                    }

                    if (options.once) {
                        index = +$(el).origin( "event-"+e.type+(sel ? ":"+sel:"")+(ns ? ":"+ns:"") );
                        if (!isNaN(index)) $.events.splice(index, 1);
                    }
                };

                Object.defineProperty(h, "name", {
                    value: handler.name && handler.name !== "" ? handler.name : "func_event_"+name+"_"+$.eventUID
                });

                originEvent = name+(sel ? ":"+sel:"")+(ns ? ":"+ns:"");

                el.addEventListener(name, h, !isEmptyObject(options) ? options : false);

                index = $.setEventHandler({
                    el: el,
                    event: name,
                    handler: h,
                    selector: sel,
                    ns: ns,
                    id: $.eventUID,
                    options: !isEmptyObject(options) ? options : false
                });
                $(el).origin('event-'+originEvent, index);
            });
        });
    },

    one: function(events, sel, handler, options){
        if (!isPlainObject(options)) {
            options = {};
        }

        options.once = true;

        return this.on.apply(this, [events, sel, handler, options]);
    },

    off: function(eventsList, sel, options){

        if (isPlainObject(sel)) {
            options = sel;
            sel = null;
        }

        if (!isPlainObject(options)) {
            options = {};
        }

        if (not(eventsList) || eventsList.toLowerCase() === 'all') {
            return this.each(function(){
                var el = this;
                $.each($.events, function(){
                    var e = this;
                    if (e.element === el) {
                        el.removeEventListener(e.event, e.handler, e.options);
                        e.handler = null;
                        $(el).origin("event-"+name+(e.selector ? ":"+e.selector:"")+(e.ns ? ":"+e.ns:""), null);
                    }
                });
            });
        }

        return this.each(function(){
            var el = this;
            $.each(str2arr(eventsList), function(){
                var evMap = this.split("."),
                    name = normName(evMap[0]),
                    ns = options.ns ? options.ns : evMap[1],
                    originEvent, index;

                originEvent = "event-"+name+(sel ? ":"+sel:"")+(ns ? ":"+ns:"");
                index = $(el).origin(originEvent);

                if (index !== undefined && $.events[index].handler) {
                    el.removeEventListener(name, $.events[index].handler, $.events[index].options);
                    $.events[index].handler = null;
                }

                $(el).origin(originEvent, null);
            });
        });
    },

    trigger: function(name, data){
        return this.fire(name, data);
    },

    fire: function(name, data){
        var _name, e;

        if (this.length === 0) {
            return ;
        }

        _name = normName(name);

        if (['focus', 'blur'].indexOf(_name) > -1) {
            this[0][_name]();
            return this;
        }

        if (typeof CustomEvent !== "undefined") {
            e = new CustomEvent(_name, {
                bubbles: true,
                cancelable: true,
                detail: data
            });
        } else {
            e = document.createEvent('Events');
            e.detail = data;
            e.initEvent(_name, true, true);
        }

        return this.each(function(){
            this.dispatchEvent(e);
        });
    }
});

( "blur focus resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu touchstart touchend touchmove touchcancel" )
    .split( " " )
    .forEach(
    function( name ) {
        $.fn[ name ] = function( sel, fn, opt ) {
            return arguments.length > 0 ?
                this.on( name, sel, fn, opt ) :
                this.fire( name );
        };
});

$.fn.extend( {
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    }
});

$.ready = function(fn, options){
    document.addEventListener('DOMContentLoaded', fn, (options || false));
};

$.load = function(fn){
    return $(window).on("load", fn);
};

$.unload = function(fn){
    return $(window).on("unload", fn);
};

$.fn.extend({
    unload: function(fn){
        return (this.length === 0 || this[0].self !== window) ? undefined : $.unload(fn);
    }
});

$.beforeunload = function(fn){
    if (typeof fn === "string") {
        return $(window).on("beforeunload", function(e){
            e.returnValue = fn;
            return fn;
        });
    } else {
        return $(window).on("beforeunload", fn);
    }
};

$.fn.extend({
    beforeunload: function(fn){
        return (this.length === 0 || this[0].self !== window) ? undefined : $.beforeunload(fn);
    }
});

$.fn.extend({
    ready: function(fn){
        if (this.length && this[0] === document && typeof fn === 'function') {
            return $.ready(fn);
        }
    }
});

// Source: src/ajax.js

/* global $, Promise, not, isSimple, isPlainObject, isEmptyObject, camelCase */

$.ajax = function(p){
    return new Promise(function(resolve, reject){
        var xhr = new XMLHttpRequest(), data;
        var method = (p.method || "GET").toUpperCase();
        var headers = [];
        var async = not(p.async) ? true : p.async;
        var url = p.url;

        var exec = function(fn, params){
            if (typeof fn === "function") {
                fn.apply(null, params);
            }
        };

        var isGet = function(method){
            return ["GET", "JSON"].indexOf(method) !== -1;
        };

        var plainObjectToData = function(obj){
            var _data = [];
            $.each(obj, function(k, v){
                var _v = isSimple(v) ? v : JSON.stringify(v);
                _data.push(k+"=" + _v);
            });
            return _data.join("&");
        };

        if (p.data instanceof HTMLFormElement) {
            var _action = p.data.getAttribute("action");
            var _method = p.data.getAttribute("method");

            if (not(url) && _action && _action.trim() !== "") {url = _action;}
            if (_method && _method.trim() !== "") {method = _method.toUpperCase();}
        }


        if (p.timeout) {
            xhr.timeout = p.timeout;
        }

        if (p.withCredentials) {
            xhr.withCredentials = p.withCredentials;
        }

        if (p.data instanceof HTMLFormElement) {
            data = $.serialize(p.data);
        } else if (p.data instanceof HTMLElement && p.data.getAttribute("type") && p.data.getAttribute("type").toLowerCase() === "file") {
            var _name = p.data.getAttribute("name");
            data = new FormData();
            for (var i = 0; i < p.data.files.length; i++) {
                data.append(_name, p.data.files[i]);
            }
        } else if (isPlainObject(p.data)) {
            data = plainObjectToData(p.data);
        } else if (p.data instanceof FormData) {
            data = p.data;
        } else if (typeof p.data === "string") {
            data = p.data;
        } else {
            data = new FormData();
            data.append("_data", JSON.stringify(p.data));
        }

        if (isGet(method)) {
            url += (typeof data === "string" ? "?"+data : isEmptyObject(data) ? "" : "?"+JSON.stringify(data));
        }

        xhr.open(method, url, async, p.user, p.password);
        if (p.headers) {
            $.each(p.headers, function(k, v){
                xhr.setRequestHeader(k, v);
                headers.push(k);
            });
        }
        if (!isGet(method)) {
            if (headers.indexOf("Content-type") === -1 && p.contentType !== false) {
                xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            }
        }
        xhr.send(data);

        xhr.addEventListener("load", function(e){
            if (xhr.readyState === 4 && xhr.status < 300) {
                var _return = p.returnValue && p.returnValue === 'xhr' ? xhr : xhr.response;
                if (p.parseJson) {
                    try {
                        _return = JSON.parse(_return);
                    } catch (ex) {
                        _return = {};
                    }
                }
                exec(resolve, [_return]);
                exec(p.onSuccess, [e, xhr]);
            } else {
                exec(reject, [xhr]);
                exec(p.onFail, [e, xhr]);
            }
            exec(p.onLoad, [e, xhr]);
        });

        $.each(["readystatechange", "error", "timeout", "progress", "loadstart", "loadend", "abort"], function(){
            var ev = camelCase("on-"+(this === 'readystatechange' ? 'state' : this));
            xhr.addEventListener(ev, function(e){
                exec(p[ev], [e, xhr]);
            });
        });
    });
};

['get', 'post', 'put', 'patch', 'delete', 'json'].forEach(function(method){
    $[method] = function(url, data, options){
        var _method = method.toUpperCase();
        var _options = {
            method: _method === 'JSON' ? 'GET' : _method,
            url: url,
            data: data,
            parseJson: _method === 'JSON'
        };
        return $.ajax($.extend({}, _options, options));
    };
});

$.fn.extend({
    load: function(url, data, options){
        var that = this;

        if (this.length && this[0].self === window ) {
            return $.load(url);
        }

        return $.get(url, data, options).then(function(data){
            that.each(function(){
                this.innerHTML = data;
            });
        });
    }
});

// Source: src/css.js

/* global $, not, setStyleProp */

$.fn.extend({

    style: function(name, pseudo){
        var el;

        function _getStyle(el, prop, pseudo){
            return ["scrollLeft", "scrollTop"].indexOf(prop) > -1 ? $(el)[prop]() : getComputedStyle(el, pseudo)[prop];
        }

        if (typeof name === 'string' && this.length === 0) {
            return undefined;
        }

        if (this.length === 0) {
            return this;
        }

        el = this[0];

        if (not(name) || name === "all") {
            return getComputedStyle(el, pseudo);
        } else {
            var result = {}, names = name.split(", ").map(function(el){
                return (""+el).trim();
            });
            if (names.length === 1)  {
                return _getStyle(el, names[0], pseudo);
            } else {
                $.each(names, function () {
                    var prop = this;
                    result[this] = _getStyle(el, prop, pseudo);
                });
                return result;
            }
        }
    },

    removeStyleProperty: function(name){
        if (not(name) || this.length === 0) return this;
        var names = name.split(", ").map(function(el){
            return (""+el).trim();
        });

        return this.each(function(){
            var el = this;
            $.each(names, function(){
                el.style.removeProperty(this);
            });
        });
    },

    css: function(key, val){
        key = key || 'all';

        if (typeof key === "string" && not(val)) {
            return  this.style(key);
        }

        return this.each(function(){
            var el = this;
            if (typeof key === "object") {
                $.each(key, function(key, val){
                    setStyleProp(el, key, val);
                });
            } else if (typeof key === "string") {
                setStyleProp(el, key, val);
            }
        });
    },

    scrollTop: function(val){
        if (not(val)) {
            
            return this.length === 0 ? undefined : this[0] === window ? pageYOffset : this[0].scrollTop;
        }
        return this.each(function(){
            this.scrollTop = val;
        });
    },

    scrollLeft: function(val){
        if (not(val)) {
            return this.length === 0 ? undefined : this[0] === window ? pageXOffset : this[0].scrollLeft;
        }
        return this.each(function(){
            this.scrollLeft = val;
        });
    }
});



// Source: src/classes.js

/* global $, not */

$.fn.extend({
    addClass: function(){},
    removeClass: function(){},
    toggleClass: function(){},

    containsClass: function(cls){
        return this.hasClass(cls);
    },

    hasClass: function(cls){
        var result = false;
        var classes = cls.split(" ").filter(function(v){
            return (""+v).trim() !== "";
        });

        if (not(cls)) {
            return false;
        }

        this.each(function(){
            var el = this;

            $.each(classes, function(){
                if (!result && el.classList && el.classList.contains(this)) {
                    result = true;
                }
            });
        });

        return result;
    },

    clearClasses: function(){
        return this.each(function(){
            this.className = "";
        });
    },

    cls: function(array){
        return this.length === 0 ? undefined : array ? this[0].className.split(" ") : this[0].className;
    },

    removeClassBy: function(mask){
        return this.each(function(){
            var el = $(this);
            var classes = el.cls(true);
            $.each(classes, function(){
                var elClass = this;
                if (elClass.indexOf(mask) > -1) {
                    el.removeClass(elClass);
                }
            });
        });
    }
});

['add', 'remove', 'toggle'].forEach(function (method) {
    $.fn[method + "Class"] = function(cls){
        if (not(cls) || (""+cls).trim() === "") return this;
        return this.each(function(){
            var el = this;
            var hasClassList = typeof el.classList !== "undefined";
            $.each(cls.split(" ").filter(function(v){
                return (""+v).trim() !== "";
            }), function(){
                if (hasClassList) el.classList[method](this);
            });
        });
    };
});


// Source: src/parser.js

/* global $ */

$.parseHTML = function(data){
    var base, singleTag, result = [], ctx, _context;
    var regexpSingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // eslint-disable-line

    if (typeof data !== "string") {
        return [];
    }

    data = data.trim();

    ctx = document.implementation.createHTMLDocument("");
    base = ctx.createElement( "base" );
    base.href = document.location.href;
    ctx.head.appendChild( base );
    _context = ctx.body;

    singleTag = regexpSingleTag.exec(data);

    if (singleTag) {
        result.push(document.createElement(singleTag[1]));
    } else {
        _context.innerHTML = data;
        for(var i = 0; i < _context.childNodes.length; i++) {
            result.push(_context.childNodes[i]);
        }
    }

    return result;
};


// Source: src/size.js

/* global $, not */

$.fn.extend({
    _size: function(prop, val){
        if (this.length === 0) return ;

        if (not(val)) {

            var el = this[0];

            if (prop === 'height') {
                return el === window ? window.innerHeight : el === document ? el.body.clientHeight : parseInt(getComputedStyle(el).height);
            }
            if (prop === 'width') {
                return el === window ? window.innerWidth : el === document ? el.body.clientWidth : parseInt(getComputedStyle(el).width);
            }
        }

        return this.each(function(){
            var el = this;
            if (el === window || el === document) {return ;}
            el.style[prop] = isNaN(val) ? val : val + 'px';
        });
    },

    height: function(val){
        return this._size('height', val);
    },

    width: function(val){
        return this._size('width', val);
    },

    _sizeOut: function(prop, val){
        var el, size, style, result;

        if (this.length === 0) {
            return ;
        }

        if (!not(val) && typeof val !== "boolean") {
            return this.each(function(){
                var el = this;
                if (el === window || el === document) {return ;}
                var h, style = getComputedStyle(el),
                    bs = prop === 'width' ? parseInt(style['border-left-width']) + parseInt(style['border-right-width']) : parseInt(style['border-top-width']) + parseInt(style['border-bottom-width']),
                    pa = prop === 'width' ? parseInt(style['padding-left']) + parseInt(style['padding-right']) : parseInt(style['padding-top']) + parseInt(style['padding-bottom']);

                h = $(this)[prop](val)[prop]() - bs - pa;
                el.style[prop] = h + 'px';
            });
        }

        el = this[0];
        size = el[prop === 'width' ? 'offsetWidth' : 'offsetHeight'];
        style = getComputedStyle(el);
        result = size + parseInt(style[prop === 'width' ? 'margin-left' : 'margin-top']) + parseInt(style[prop === 'width' ? 'margin-right' : 'margin-bottom']);
        return val === true ? result : size;
    },

    outerWidth: function(val){
        return this._sizeOut('width', val);
    },

    outerHeight: function(val){
        return this._sizeOut('height', val);
    },

    padding: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["padding-top"]),
            right: parseInt(s["padding-right"]),
            bottom: parseInt(s["padding-bottom"]),
            left: parseInt(s["padding-left"])
        };
    },

    margin: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["margin-top"]),
            right: parseInt(s["margin-right"]),
            bottom: parseInt(s["margin-bottom"]),
            left: parseInt(s["margin-left"])
        };
    },

    border: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["border-top-width"]),
            right: parseInt(s["border-right-width"]),
            bottom: parseInt(s["border-bottom-width"]),
            left: parseInt(s["border-left-width"])
        };
    }
});

// Source: src/position.js

/* global $, not */

$.fn.extend({
    offset: function(val){
        var rect;

        if (not(val)) {
            if (this.length === 0) return undefined;
            rect = this[0].getBoundingClientRect();
            return {
                top: rect.top + pageYOffset,
                left: rect.left + pageXOffset
            };
        }

        return this.each(function(){ //?
            var el = $(this),
                top = val.top,
                left = val.left,
                position = getComputedStyle(this).position,
                offset = el.offset();

            if (position === "static") {
                el.css("position", "relative");
            }

            if (["absolute", "fixed"].indexOf(position) === -1) {
                top = top - offset.top;
                left = left - offset.left;
            }

            el.css({
                top: top,
                left: left
            });
        });
    },

    position: function(margin){
        var ml = 0, mt = 0, el, style;

        if (not(margin) || typeof margin !== "boolean") {
            margin = false;
        }

        if (this.length === 0) {
            return undefined;
        }

        el = this[0];
        style = getComputedStyle(el);

        if (margin) {
            ml = parseInt(style['margin-left']);
            mt = parseInt(style['margin-top']);
        }

        return {
            left: el.offsetLeft - ml,
            top: el.offsetTop - mt
        };
    },

    left: function(val, margin){
        if (this.length === 0) return ;
        if (not(val)) {
            return this.position(margin).left;
        }
        if (typeof val === "boolean") {
            margin = val;
            return this.position(margin).left;
        }
        return this.each(function(){
            $(this).css({
                left: val
            });
        });
    },

    top: function(val, margin){
        if (this.length === 0) return ;
        if (not(val)) {
            return this.position(margin).top;
        }
        if (typeof val === "boolean") {
            margin = val;
            return this.position(margin).top;
        }
        return this.each(function(){
            $(this).css({
                top: val
            });
        });
    },

    coord: function(){
        return this.length === 0 ? undefined : this[0].getBoundingClientRect();
    },

    pos: function(){
        if (this.length === 0) return ;
        return {
            top: parseInt($(this[0]).style("top")),
            left: parseInt($(this[0]).style("left"))
        };
    }
});

// Source: src/attr.js

/* global $, not, isPlainObject */

$.fn.extend({
    attr: function(name, val){
        var attributes = {};

        if (this.length === 0 && arguments.length === 0) {
            return undefined;
        }

        if (this.length && arguments.length === 0) {
            $.each(this[0].attributes, function(){
                attributes[this.nodeName] = this.nodeValue;
            });
            return attributes;
        }

        if (typeof name === 'string' && val === undefined) {
            return this.length && this[0].nodeType === 1 && this[0].hasAttribute(name) ? this[0].getAttribute(name) : undefined;
        }

        return this.each(function(){
            var el = this;
            if (isPlainObject(name)) {
                $.each(name, function(k, v){
                    el.setAttribute(k, v);
                });
            } else {
                el.setAttribute(name, val);
                // 
            }
        });
    },

    removeAttr: function(name){
        var attributes;

        if (not(name)) {
            return this.each(function(){
                var el = this;
                $.each(this.attributes, function(){
                    el.removeAttribute(this);
                });
            });
        }

        attributes = typeof name === "string" ? name.split(",").map(function(el){
            return el.trim();
        }) : name;

        return this.each(function(){
            var el = this;
            $.each(attributes, function(){
                if (el.hasAttribute(this)) el.removeAttribute(this);
            });
        });
    },

    toggleAttr: function(name, val){
        return this.each(function(){
            var el = this;

            if (not(val)) {
                el.removeAttribute(name);
            } else {
                el.setAttribute(name, val);
            }

        });
    },

    id: function(val){
        return this.length ? $(this[0]).attr("id", val) : undefined;
    }
});

$.extend({
    meta: function(name){
        return not(name) ? $("meta") : $("meta[name='$name']".replace("$name", name));
    },

    metaBy: function(name){
        return not(name) ? $("meta") : $("meta[$name]".replace("$name", name));
    },

    doctype: function(){
        return $("doctype");
    },

    html: function(){
        return $("html");
    },

    head: function(){
        return $("html").find("head");
    },

    body: function(){
        return $("body");
    },

    document: function(){
        return $(document);
    },

    window: function(){
        return $(window);
    },

    charset: function(val){
        var meta = $("meta[charset]");
        if (val) {
            meta.attr("charset", val);
        }
        return meta.attr("charset");
    }
});

// Source: src/proxy.js

/* global $ */

$.extend({
    proxy: function(fn, ctx){
        return typeof fn !== "function" ? undefined : fn.bind(ctx);
    },

    bind: function(fn, ctx){
        return this.proxy(fn, ctx);
    }
});


// Source: src/manipulation.js

/* global $, isArrayLike, not, matches, hasProp */

(function (arr) {
    arr.forEach(function (item) {
        ['append', 'prepend'].forEach(function(where){
            if (hasProp(item, where)) {
                return;
            }
            Object.defineProperty(item, where, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: function prepend() {
                    var argArr = Array.prototype.slice.call(arguments),
                        docFrag = document.createDocumentFragment();

                    argArr.forEach(function (argItem) {
                        var isNode = argItem instanceof Node;
                        docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
                    });

                    if (where === 'prepend')
                        this.insertBefore(docFrag, this.firstChild);
                    else
                        this.appendChild(docFrag);
                }
            });
        });
    });
})([Element.prototype, Document.prototype, DocumentFragment.prototype]);

var normalizeElements = function(s){
    var result;
    if (typeof s === "string") result = $.isSelector(s) ? $(s) : $.parseHTML(s);
    else if (s instanceof HTMLElement) result = [s];
    else if (isArrayLike(s)) result = s;
    return result;
};

$.fn.extend({

    appendText: function(text){
        return this.each(function(elIndex, el){
            el.innerHTML += text;
        });
    },

    prependText: function(text){
        return this.each(function(elIndex, el){
            el.innerHTML = text + el.innerHTML;
        });
    },

    append: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(elIndex, el){
            $.each(_elements, function(){
                if (el === this) return ;
                var child = elIndex === 0 ? this : this.cloneNode(true);
                $.script(child);
                if (child.tagName && child.tagName !== "SCRIPT") el.append(child);
            });
        });
    },

    appendTo: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(parIndex, parent){
                if (el === this) return ;
                parent.append(parIndex === 0 ? el : el.cloneNode(true));
            });
        });
    },

    prepend: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function (elIndex, el) {
            $.each(_elements, function(){
                if (el === this) return ;
                var child = elIndex === 0 ? this : this.cloneNode(true);
                $.script(child);
                if (child.tagName && child.tagName !== "SCRIPT") el.prepend(child);
            });
        });
    },

    prependTo: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(parIndex, parent){
                if (el === this) return ;
                $(parent).prepend(parIndex === 0 ? el : el.cloneNode(true));
            });
        });
    },

    insertBefore: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(elIndex){
                if (el === this) return ;
                var parent = this.parentNode;
                if (parent) {
                    parent.insertBefore(elIndex === 0 ? el : el.cloneNode(true), this);
                }
            });
        });
    },

    insertAfter: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(elIndex, element){
                if (el === this) return ;
                var parent = this.parentNode;
                if (parent) {
                    parent.insertBefore(elIndex === 0 ? el : el.cloneNode(true), element.nextSibling);
                }
            });
        });
    },

    after: function(html){
        return this.each(function(){
            var el = this;
            if (typeof html === "string") {
                el.insertAdjacentHTML('afterend', html);
            } else {
                $(html).insertAfter(el);
            }
        });
    },

    before: function(html){
        return this.each(function(){
            var el = this;
            if (typeof html === "string") {
                el.insertAdjacentHTML('beforebegin', html);
            } else {
                $(html).insertBefore(el);
            }
        });
    },

    clone: function(deep, withData){
        var res = [];
        if (not(deep)) {
            deep = false;
        }
        if (not(withData)) {
            withData = false;
        }
        this.each(function(){
            var el = this.cloneNode(deep);
            var $el = $(el);
            var data;
            if (withData && $.hasData(this)) {
                data = $(this).data();
                $.each(data, function(k, v){
                    $el.data(k, v);
                });
            }
            res.push(el);
        });
        return $.merge($(), res);
    },

    import: function(deep){
        var res = [];
        if (not(deep)) {
            deep = false;
        }
        this.each(function(){
            res.push(document.importNode(this, deep));
        });
        return $.merge($(), res);
    },

    adopt: function(){
        var res = [];
        this.each(function(){
            res.push(document.adoptNode(this));
        });
        return $.merge($(), res);
    },

    remove: function(selector){
        var i = 0, node, out, res = [];

        if (this.length === 0) {
            return ;
        }

        out = selector ? this.filter(function(el){
            return matches.call(el, selector);
        }) : this.items();

        for ( ; ( node = out[ i ] ) != null; i++ ) {
            if (node.parentNode) {
                res.push(node.parentNode.removeChild(node));
                $.removeData(node);
            }
        }

        return $.merge($(), res);
    },

    wrap: function( el ){
        if (this.length === 0) {
            return ;
        }

        var wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        var res = [];

        this.each(function(){
            var _target, _wrapper;

            _wrapper = wrapper.clone(true, true);
            _wrapper.insertBefore(this);

            _target = _wrapper;
            while (_target.children().length) {
                _target = _target.children().eq(0);
            }
            _target.append(this);

            res.push(_wrapper);
        });

        return $(res);
    },

    wrapAll: function( el ){
        var wrapper, _wrapper, _target;

        if (this.length === 0) {
            return ;
        }

        wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        _wrapper = wrapper.clone(true, true);
        _wrapper.insertBefore(this[0]);

        _target = _wrapper;
        while (_target.children().length) {
            _target = _target.children().eq(0);
        }

        this.each(function(){
            _target.append(this);
        })

        return _wrapper;
    },

    wrapInner: function( el ){
        if (this.length === 0) {
            return ;
        }

        var wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        var res = [];

        this.each(function(){
            var elem = $(this);
            var html = elem.html();
            var wrp = wrapper.clone(true, true);
            elem.html(wrp.html(html));
            res.push(wrp);
        });

        return $(res);
    }
});

// Source: src/animation.js

/* global $, not, camelCase, parseUnit, Promise, getUnit */

$.extend({
    animation: {
        duration: 1000,
        ease: "linear",
        elements: {}
    }
});

if (typeof window["setupAnimation"] === 'object') {
    $.each(window["setupAnimation"], function(key, val){
        if (typeof $.animation[key] !== "undefined" && !not(val))
            $.animation[key] = val;
    });
}

var transformProps = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY'];
var numberProps = ['opacity', 'zIndex'];
var floatProps = ['opacity', 'volume'];
var scrollProps = ["scrollLeft", "scrollTop"];
var reverseProps = ["opacity", "volume"];

function _validElement(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
}

/**
 *
 * @param to
 * @param from
 * @returns {*}
 * @private
 */
function _getRelativeValue (to, from) {
    var operator = /^(\*=|\+=|-=)/.exec(to);
    if (!operator) return to;
    var u = getUnit(to) || 0;
    var x = parseFloat(from);
    var y = parseFloat(to.replace(operator[0], ''));
    switch (operator[0][0]) {
        case '+':
            return x + y + u;
        case '-':
            return x - y + u;
        case '*':
            return x * y + u;
        case '/':
            return x / y + u;
    }
}

/**
 *
 * @param el
 * @param prop
 * @param pseudo
 * @returns {*|number|string}
 * @private
 */
function _getStyle (el, prop, pseudo){
    if (typeof el[prop] !== "undefined") {
        if (scrollProps.indexOf(prop) > -1) {
            return prop === "scrollLeft" ? el === window ? pageXOffset : el.scrollLeft : el === window ? pageYOffset : el.scrollTop;
        } else {
            return el[prop] || 0;
        }
    }

    return el.style[prop] || getComputedStyle(el, pseudo)[prop];
}

/**
 *
 * @param el
 * @param key
 * @param val
 * @param unit
 * @param toInt
 * @private
 */
function _setStyle (el, key, val, unit, toInt) {

    if (not(toInt)) {
        toInt = false;
    }

    key = camelCase(key);

    if (toInt) {
        val  = parseInt(val);
    }

    if (_validElement(el)) {
        if (typeof el[key] !== "undefined") {
            el[key] = val;
        } else {
            el.style[key] = key === "transform" || key.toLowerCase().indexOf('color') > -1 ? val : val + unit;
        }
    } else {
        el[key] = val;
    }
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyStyles (el, mapProps, p) {
    $.each(mapProps, function (key, val) {
        _setStyle(el, key, val[0] + (val[2] * p), val[3], val[4]);
    });
}

/**
 *
 * @param el
 * @returns {{}}
 * @private
 */
function _getElementTransforms (el) {
    if (!_validElement(el)) return {};
    var str = el.style.transform || '';
    var reg = /(\w+)\(([^)]*)\)/g;
    var transforms = {};
    var m;

    /* jshint ignore:start */
    // eslint-disable-next-line
    while (m = reg.exec(str))
        transforms[m[1]] = m[2];
    /* jshint ignore:end */

    return transforms;
}

/**
 *
 * @param val
 * @returns {number[]}
 * @private
 */
function _getColorArrayFromHex (val){
    var a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(val ? val : "#000000");
    return a.slice(1).map(function(v) {
            return parseInt(v, 16);
    });
}

/**
 *
 * @param el
 * @param key
 * @returns {number[]}
 * @private
 */
function _getColorArrayFromElement (el, key) {
    return getComputedStyle(el)[key].replace(/[^\d.,]/g, '').split(',').map(function(v) {
        return parseInt(v);
    });
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyTransform (el, mapProps, p) {
    var t = [];
    var elTransforms = _getElementTransforms(el);

    $.each(mapProps, function(key, val) {
        var from = val[0], to = val[1], delta = val[2], unit = val[3];
        key = "" + key;

        if ( key.indexOf("rotate") > -1 || key.indexOf("skew") > -1) {
            if (unit === "") unit = "deg";
        }

        if (key.indexOf('scale') > -1) {
            unit = '';
        }

        if (key.indexOf('translate') > -1 && unit === '') {
            unit = 'px';
        }

        if (unit === "turn") {
            t.push(key+"(" + (to * p) + unit + ")");
        } else {
            t.push(key +"(" + (from + (delta * p)) + unit+")");
        }
    });

    $.each(elTransforms, function(key, val) {
        if (mapProps[key] === undefined) {
            t.push(key+"("+val+")");
        }
    });

    el.style.transform = t.join(" ");
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyColors (el, mapProps, p) {
    $.each(mapProps, function (key, val) {
        var i, result = [0, 0, 0], v;
        for (i = 0; i < 3; i++) {
            result[i] = Math.floor(val[0][i] + (val[2][i] * p));
        }
        v = "rgb("+(result.join(","))+")";
        el.style[key] = v;
    });
}

/**
 *
 * @param val
 * @returns {string|*}
 * @private
 */
function _expandColorValue (val) {
    var regExp = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (val[0] === "#" && val.length === 4) {
        return "#" + val.replace(regExp, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
    }
    return val[0] === "#" ? val : "#"+val;
}

/**
 *
 * @param el
 * @param map
 * @param p
 */
function applyProps (el, map, p) {
    _applyStyles(el, map.props, p);
    _applyTransform(el, map.transform, p);
    _applyColors(el, map.color, p);
}

/**
 *
 * @param el
 * @param draw
 * @param dir
 * @returns {{transform: {}, color: {}, props: {}}}
 */
function createAnimationMap (el, draw, dir) {
    var map = {
        props: {},
        transform: {},
        color: {}
    };
    var i, from, to, delta, unit, temp;
    var elTransforms = _getElementTransforms(el);

    if (not(dir)) {
        dir = "normal";
    }

    $.each(draw, function(key, val) {

        var isTransformProp = transformProps.indexOf(""+key) > -1;
        var isNumProp = numberProps.indexOf(""+key) > -1;
        var isColorProp = (""+key).toLowerCase().indexOf("color") > -1;

        if (Array.isArray(val) && val.length === 1) {
            val = val[0];
        }

        if (!Array.isArray(val)) {
            if (isTransformProp) {
                from = elTransforms[key] || 0;
            } else if (isColorProp) {
                from = _getColorArrayFromElement(el, key);
            } else {
                from = _getStyle(el, key);
            }
            from = !isColorProp ? parseUnit(from) : from;
            to = !isColorProp ? parseUnit(_getRelativeValue(val, Array.isArray(from) ? from[0] : from)) : _getColorArrayFromHex(val);
        } else {
            from = !isColorProp ? parseUnit(val[0]) : _getColorArrayFromHex(_expandColorValue(val[0]));
            to = !isColorProp ? parseUnit(val[1]) : _getColorArrayFromHex(_expandColorValue(val[1]));
        }

        if (reverseProps.indexOf(""+key) > -1 && from[0] === to[0]) {
            from[0] = to[0] > 0 ? 0 : 1;
        }

        if (dir === "reverse") {
            temp = from;
            from = to;
            to = temp;
        }

        unit = el instanceof HTMLElement && to[1] === '' && !isNumProp && !isTransformProp ? 'px' : to[1];

        if (isColorProp) {
            delta = [0, 0, 0];
            for (i = 0; i < 3; i++) {
                delta[i] = to[i] - from[i];
            }
        } else {
            delta = to[0] - from[0];
        }

        if (isTransformProp) {
            map.transform[key] = [from[0], to[0], delta, unit];
        } else if (isColorProp) {
            map.color[key] = [from, to, delta, unit];
        } else {
            map.props[key] = [from[0], to[0], delta, unit, floatProps.indexOf(""+key) === -1];
        }
    });

    return map;
}

function minMax(val, min, max) {
    return Math.min(Math.max(val, min), max);
}

var Easing = {
    linear: function(){return function(t) {return t;};}
};

Easing.default = Easing.linear;

var eases = {
    Sine: function(){
        return function(t){
            return 1 - Math.cos(t * Math.PI / 2);
        };
    },
    Circ: function(){
        return function(t){
            return 1 - Math.sqrt(1 - t * t);
        };
    },
    Back: function(){
        return function(t){
            return t * t * (3 * t - 2);
        };
    },
    Bounce: function(){
        return function(t){
            var pow2, b = 4;
            // eslint-disable-next-line
            while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
            return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2);
        };
    },
    Elastic: function(amplitude, period){
        if (not(amplitude)) {
            amplitude = 1;
        }

        if (not(period)) {
            period = 0.5;
        }
        var a = minMax(amplitude, 1, 10);
        var p = minMax(period, 0.1, 2);
        return function(t){
            return (t === 0 || t === 1) ? t :
                -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
        };
    }
};

['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'].forEach(function(name, i) {
    eases[name] = function(){
        return function(t){
            return Math.pow(t, i + 2);
        };
    };
});

Object.keys(eases).forEach(function(name) {
    var easeIn = eases[name];
    Easing['easeIn' + name] = easeIn;
    Easing['easeOut' + name] = function(a, b){
        return function(t){
            return 1 - easeIn(a, b)(1 - t);
        };
    };
    Easing['easeInOut' + name] = function(a, b){
        return function(t){
            return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
        };
    };
});

var defaultAnimationProps = {
    id: null,
    el: null,
    draw: {},
    dur: $.animation.duration,
    ease: $.animation.ease,
    loop: 0,
    pause: 0,
    dir: "normal",
    defer: 0,
    onFrame: function(){},
    onDone: function(){}
};

function animate(args){
    return new Promise(function(resolve){
        var that = this, start;
        var props = $.assign({}, defaultAnimationProps, {dur: $.animation.duration, ease: $.animation.ease}, args);
        var id = props.id, el = props.el, draw = props.draw, dur = props.dur, ease = props.ease, loop = props.loop, onFrame = props.onFrame, onDone = props.onDone, pause = props.pause, dir = props.dir, defer = props.defer;
        var map = {};
        var easeName = "linear", easeArgs = [], easeFn = Easing.linear, matchArgs;
        var direction = dir === "alternate" ? "normal" : dir;
        var replay = false;
        var animationID = id ? id : +(performance.now() * Math.pow(10, 14));

        if (not(el)) {
            throw new Error("Unknown element!");
        }

        if (typeof el === "string") {
            el = document.querySelector(el);
        }

        if (typeof draw !== "function" && typeof draw !== "object") {
            throw new Error("Unknown draw object. Must be a function or object!");
        }

        if (dur === 0) {
            dur = 1;
        }

        if (dir === "alternate" && typeof loop === "number") {
            loop *= 2;
        }

        if (typeof ease === "string") {
            matchArgs = /\(([^)]+)\)/.exec(ease);
            easeName = ease.split("(")[0];
            easeArgs = matchArgs ? matchArgs[1].split(',').map(function(p){return parseFloat(p);}) : [];
            easeFn = Easing[easeName] || Easing.linear;
        } else if (typeof ease === "function") {
            easeFn = ease;
        } else {
            easeFn = Easing.linear;
        }

        $.animation.elements[animationID] = {
            element: el,
            id: null,
            stop: 0,
            pause: 0,
            loop: 0
        };

        var play = function() {
            if (typeof draw === "object") {
                map = createAnimationMap(el, draw, direction);
            }
            start = performance.now();
            $.animation.elements[animationID].loop += 1;
            $.animation.elements[animationID].id = requestAnimationFrame(animate);
        };

        var done = function() {
            cancelAnimationFrame($.animation.elements[animationID].id);
            delete $.animation.elements[id];

            if (typeof onDone === "function") {
                onDone.apply(el);
            }

            resolve(that);
        };

        var animate = function(time) {
            var p, t;
            var stop = $.animation.elements[animationID].stop;

            if ( stop > 0) {
                if (stop === 2) {
                    if (typeof draw === "function") {

                        draw.bind(el)(1, 1);

                    } else {

                        applyProps(el, map, 1);

                    }
                }
                done();
                return;
            }

            t = (time - start) / dur;

            if (t > 1) t = 1;
            if (t < 0) t = 0;

            p = easeFn.apply(null, easeArgs)(t);

            if (typeof draw === "function") {

                draw.bind(el)(t, p);

            } else {

                applyProps(el, map, p);

            }

            if (typeof onFrame === 'function') {
                onFrame.apply(el, [t, p]);
            }

            if (t < 1) {
                $.animation.elements[animationID].id = requestAnimationFrame(animate);
            }

            if (parseInt(t) === 1) {
                if (loop) {
                    if (dir === "alternate") {
                        direction = direction === "normal" ? "reverse" : "normal";
                    }

                    if (typeof loop === "boolean") {
                        setTimeout(function () {
                            play();
                        }, pause);
                    } else {
                        if (loop > $.animation.elements[animationID].loop) {
                            setTimeout(function () {
                                play();
                            }, pause);
                        } else {
                            done();
                        }
                    }
                } else {
                    if (dir === "alternate" && !replay) {
                        direction = direction === "normal" ? "reverse" : "normal";
                        replay = true;
                        play();
                    } else {
                        done();
                    }
                }
            }
        };
        if (defer > 0) {
            setTimeout(function() {
                play();
            }, defer);
        } else {
            play();
        }
    });
}

/* eslint-disable */
function stop(id, done){
    if (not(done)) {
        done = true;
    }
    $.animation.elements[id].stop = done === true ? 2 : 1;
}
/* eslint-enable */

function chain(arr, loop){
    if (not(loop)) loop = false;
    if (!Array.isArray(arr)) {
        console.warn("Chain array is not defined!");
        return false;
    }

    var reducer = function(acc, item){
        return acc.then(function(){
            return animate(item);
        });
    };

    arr.reduce(reducer, Promise.resolve()).then(function(){
        if (loop) {
            if (typeof loop === "boolean") {
                chain(arr, loop);
            } else {
                loop--;
                chain(arr, loop);
            }
        }
    });
}

$.easing = {};

$.extend($.easing, Easing);

$.extend({
    animate: function(args){
        var el, draw, dur, ease, cb;

        if (arguments.length > 1) {
            el = $(arguments[0])[0];
            draw = arguments[1];
            dur = arguments[2] || $.animation.duration;
            ease = arguments[3] || $.animation.ease;
            cb = arguments[4];

            if (typeof dur === 'function') {
                cb = dur;
                ease = $.animation.ease;
                dur = $.animation.duration;
            }

            if (typeof ease === 'function') {
                cb = ease;
                ease = $.animation.ease;
            }

            return animate({
                el: el,
                draw: draw,
                dur: dur,
                ease: ease,
                onDone: cb
            });
        }

        return animate(args);
    },
    stop: stop,
    chain: chain
});

$.fn.extend({
    /**
     *

     args = {
         draw: {} | function,
         dur: 1000,
         ease: "linear",
         loop: 0,
         pause: 0,
         dir: "normal",
         defer: 0,
         onFrame: function,
         onDone: function
     }

     * @returns {this}
     */
    animate: function(args){
        var that = this;
        var draw, dur, easing, cb;
        var a = args;
        var compatibilityMode;

        compatibilityMode = !Array.isArray(args) && (arguments.length > 1 || (arguments.length === 1 && typeof arguments[0].draw === 'undefined'));

        if ( compatibilityMode ) {
            draw = arguments[0];
            dur = arguments[1] || $.animation.duration;
            easing = arguments[2] || $.animation.ease;
            cb = arguments[3];

            if (typeof dur === 'function') {
                cb = dur;
                dur = $.animation.duration;
                easing = $.animation.ease;
            }

            if (typeof easing === 'function') {
                cb = easing;
                easing = $.animation.ease;
            }

            return this.each(function(){
                return $.animate({
                    el: this,
                    draw: draw,
                    dur: dur,
                    ease: easing,
                    onDone: cb
                });
            });
        }

        if (Array.isArray(args)) {
            $.each(args, function(){
                var a = this;
                that.each(function(){
                    a.el = this;
                    $.animate(a);
                });
            });
            return this;
        }

        return this.each(function(){
            a.el = this;
            $.animate(a);
        });
    },

    chain: function(arr, loop){
        return this.each(function(){
            var el = this;
            $.each(arr, function(){
                this.el = el;
            });
            $.chain(arr, loop);
        });
    },

    /**
     *
     * @param done
     * @returns {this}
     */
    stop: function(done){
        var elements = $.animation.elements;
        return this.each(function(){
            var el = this;
            $.each(elements, function(k, o){
                if (o.element === el) {
                    stop(k, done);
                }
            });
        });
    }
});


// Source: src/visibility.js

/* global $ */

$.extend({
    hidden: function(el, val, cb){
        el = $(el)[0];

        if (typeof val === "string") {
            val = val.toLowerCase() === "true";
        }

        if (typeof val === "function") {
            cb = val;
            val = !el.hidden;
        }

        el.hidden = val;

        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }

        return this;
    },

    hide: function(el, cb){
        var $el = $(el);

        $el.origin('display', (el.style.display ? el.style.display : getComputedStyle(el, null).display));
        el.style.display = 'none';

        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }

        return this;
    },

    show: function(el, cb){
        var display = $(el).origin('display', undefined, "block");
        el.style.display = display ? display === 'none' ? 'block' : display : '';
        if (parseInt(el.style.opacity) === 0) {
            el.style.opacity = "1";
        }
        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }
        return this;
    },

    visible: function(el, mode, cb){
        if (mode === undefined) {
            mode = true;
        }
        el.style.visibility = mode ? 'visible' : 'hidden';
        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }
        return this;
    },

    toggle: function(el, cb){
        var func = getComputedStyle(el, null).display !== 'none' ? 'hide' : 'show';
        return $[func](el, cb);
    }
});

$.fn.extend({
    hide: function(){
        var callback;

        $.each(arguments, function(){
            if (typeof this === 'function') {
                callback = this;
            }
        });

        return this.each(function(){
            $.hide(this, callback);
        });
    },

    show: function(){
        var callback;

        $.each(arguments, function(){
            if (typeof this === 'function') {
                callback = this;
            }
        });

        return this.each(function(){
            $.show(this, callback);
        });
    },

    visible: function(mode, cb){
        return this.each(function(){
            $.visible(this, mode, cb);
        });
    },

    toggle: function(cb){
        return this.each(function(){
            $.toggle(this, cb);
        });
    },

    hidden: function(val, cb){
        return this.each(function(){
            $.hidden(this, val, cb);
        });
    }
});



// Source: src/effects.js

/* global $, not, isVisible */

$.extend({
    fx: {
        off: false
    }
});

$.fn.extend({
    fadeIn: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var visible = !(!isVisible(el) || (isVisible(el) && +($el.style('opacity')) === 0));

            if (visible) {
                return this;
            }

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }

            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            if ($.fx.off) {
                dur = 0;
            }

            var originDisplay = $el.origin("display", undefined, 'block');

            el.style.opacity = "0";
            el.style.display = originDisplay;

            return $.animate({
                el: el,
                draw: {
                    opacity: 1
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    fadeOut: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);

            if ( !isVisible(el) ) return ;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            $el.origin("display", $el.style('display'));

            return $.animate({
                el: el,
                draw: {
                    opacity: 0
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    this.style.display = 'none';

                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    slideUp: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var currHeight;

            if ($el.height() === 0) return ;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            currHeight = $el.height();
            $el.origin("height", currHeight);
            $el.origin("display", $(el).style('display'));

            $el.css({
                overflow: "hidden"
            });

            return $.animate({
                el: el,
                draw: {
                    height: 0
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    $el.hide().removeStyleProperty("overflow, height");
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    slideDown: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var targetHeight, originDisplay;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            $el.show().visible(false);
            targetHeight = +$el.origin("height", undefined, $el.height());
            if (parseInt(targetHeight) === 0) {
                targetHeight = el.scrollHeight;
            }
            originDisplay = $el.origin("display", $el.style('display'), "block");
            $el.height(0).visible(true);

            $el.css({
                overflow: "hidden",
                display: originDisplay === "none" ? "block" : originDisplay
            });

            return $.animate({
                el: el,
                draw: {
                    height: targetHeight
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    $(el).removeStyleProperty("overflow, height, visibility");
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    moveTo: function(x, y, dur, easing, cb){
        var draw = {
            top: y,
            left: x
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    centerTo: function(x, y, dur, easing, cb){
        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            var draw = {
                left: x - this.clientWidth / 2,
                top: y - this.clientHeight / 2
            };
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    colorTo: function(color, dur, easing, cb){
        var draw = {
            color: color
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    backgroundTo: function(color, dur, easing, cb){
        var draw = {
            backgroundColor: color
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    }
});

// Source: src/init.js

/* global $, isArrayLike, isPlainObject, hasProp, str2arr */

$.init = function(sel, ctx){
    var parsed;
    var that = this;

    if (typeof sel === "string") {
        sel = sel.trim();
    }

    this.uid = $.uniqueId();

    if (!sel) {
        return this;
    }

    if (typeof sel === "function") {
        return $.ready(sel);
    }

    if (sel instanceof Element) {
        this.push(sel);
        return this;
    }

    if (sel instanceof $) {
        $.each(sel, function(){
            that.push(this);
        });
        return this;
    }

    if (sel === "window") sel = window;
    if (sel === "document") sel = document;
    if (sel === "body") sel = document.body;
    if (sel === "html") sel = document.documentElement;
    if (sel === "doctype") sel = document.doctype;
    if (sel && (sel.nodeType || sel.self === window)) {
        this.push(sel);
        return this;
    }

    if (isArrayLike(sel)) {
        $.each(sel, function(){
            $(this).each(function(){
                that.push(this);
            });
        });
        return this;
    }

    if (typeof sel !== "string" && (sel.self && sel.self !== window)) {
        return this;
    }

    if (sel === "#" || sel === ".") {
        console.error("Selector can't be # or .") ;
        return this;
    }

    if (sel[0] === "@") {

        $("[data-role]").each(function(){
            var roles = str2arr($(this).attr("data-role"), ",");
            if (roles.indexOf(sel.slice(1)) > -1) {
                that.push(this);
            }
        });

    } else {

        parsed = $.parseHTML(sel);

        if (parsed.length === 1 && parsed[0].nodeType === 3) { // Must be a text node -> css sel
            try {
                [].push.apply(this, document.querySelectorAll(sel));
            } catch (e) {
                console.error(sel + " is not a valid selector");
            }
        } else {
            $.merge(this, parsed);
        }
    }

    if (ctx !== undefined) {
        if (ctx instanceof $) {
            this.each(function () {
                $(ctx).append(that);
            });
        } else if (ctx instanceof HTMLElement) {
            $(ctx).append(that);
        } else {
            if (isPlainObject(ctx)) {
                $.each(this,function(){
                    for(var name in ctx) {
                        if (hasProp(ctx, name))
                            this.setAttribute(name, ctx[name]);
                    }
                });
            }
        }
    }

    return this;
};

$.init.prototype = $.fn;


// Source: src/populate.js

/* global Promise, $ */

var _$ = window.$;

$.Promise = Promise;

window.m4q = $;

if (typeof window.$ === "undefined") {
    window.$ = $;
}

$.global = function(){
    _$ = window.$;
    window.$ = $;
};

$.noConflict = function() {
    if ( window.$ === $ ) {
        window.$ = _$;
    }

    return $;
};

}(window));


(function($) {
    'use strict';

    var meta_init = $.meta('metro4:init').attr("content");
    var meta_locale = $.meta('metro4:locale').attr("content");
    var meta_week_start = $.meta('metro4:week_start').attr("content");
    var meta_date_format = $.meta('metro4:date_format').attr("content");
    var meta_date_format_input = $.meta('metro4:date_format_input').attr("content");
    var meta_animation_duration = $.meta('metro4:animation_duration').attr("content");
    var meta_callback_timeout = $.meta('metro4:callback_timeout').attr("content");
    var meta_timeout = $.meta('metro4:timeout').attr("content");
    var meta_scroll_multiple = $.meta('metro4:scroll_multiple').attr("content");
    var meta_cloak = $.meta('metro4:cloak').attr("content");
    var meta_cloak_duration = $.meta('metro4:cloak_duration').attr("content");
    var meta_global_common = $.meta('metro4:global_common').attr("content");
    var meta_blur_image = $.meta('metro4:blur_image').attr("content");

    if (window.METRO_BLUR_IMAGE === undefined) {
        window.METRO_BLUR_IMAGE = meta_blur_image !== undefined ? JSON.parse(meta_global_common) : false;
    }

    if (window.METRO_GLOBAL_COMMON === undefined) {
        window.METRO_GLOBAL_COMMON = meta_global_common !== undefined ? JSON.parse(meta_global_common) : false;
    }

    var meta_jquery = $.meta('metro4:jquery').attr("content"); //undefined
    window.jquery_present = typeof jQuery !== "undefined";
    if (window.METRO_JQUERY === undefined) {
        window.METRO_JQUERY = meta_jquery !== undefined ? JSON.parse(meta_jquery) : true;
    }
    window.useJQuery = window.jquery_present && window.METRO_JQUERY;


    /* Added by Ken Kitay https://github.com/kens-code*/
    var meta_about = $.meta('metro4:about').attr("content");
    if (window.METRO_SHOW_ABOUT === undefined) {
        window.METRO_SHOW_ABOUT = meta_about !== undefined ? JSON.parse(meta_about) : true;
    }
    /* --- end ---*/

    var meta_compile = $.meta('metro4:compile').attr("content");
    if (window.METRO_SHOW_COMPILE_TIME === undefined) {
        window.METRO_SHOW_COMPILE_TIME = meta_compile !== undefined ? JSON.parse(meta_compile) : true;
    }

    if (window.METRO_INIT === undefined) {
        window.METRO_INIT = meta_init !== undefined ? JSON.parse(meta_init) : true;
    }

    if (window.METRO_DEBUG === undefined) {window.METRO_DEBUG = true;}

    if (window.METRO_WEEK_START === undefined) {
        window.METRO_WEEK_START = meta_week_start !== undefined ? parseInt(meta_week_start) : 0;
    }
    if (window.METRO_DATE_FORMAT === undefined) {
        window.METRO_DATE_FORMAT = meta_date_format !== undefined ? meta_date_format : "%Y-%m-%d";
    }
    if (window.METRO_DATE_FORMAT_INPUT === undefined) {
        window.METRO_DATE_FORMAT_INPUT = meta_date_format_input !== undefined ? meta_date_format_input : "%Y-%m-%d";
    }
    if (window.METRO_LOCALE === undefined) {
        window.METRO_LOCALE = meta_locale !== undefined ? meta_locale : 'en-US';
    }
    if (window.METRO_ANIMATION_DURATION === undefined) {
        window.METRO_ANIMATION_DURATION = meta_animation_duration !== undefined ? parseInt(meta_animation_duration) : 100;
    }
    if (window.METRO_CALLBACK_TIMEOUT === undefined) {
        window.METRO_CALLBACK_TIMEOUT = meta_callback_timeout !== undefined ? parseInt(meta_callback_timeout) : 500;
    }
    if (window.METRO_TIMEOUT === undefined) {
        window.METRO_TIMEOUT = meta_timeout !== undefined ? parseInt(meta_timeout) : 2000;
    }
    if (window.METRO_SCROLL_MULTIPLE === undefined) {
        window.METRO_SCROLL_MULTIPLE = meta_scroll_multiple !== undefined ? parseInt(meta_scroll_multiple) : 20;
    }
    if (window.METRO_CLOAK_REMOVE === undefined) {
        window.METRO_CLOAK_REMOVE = meta_cloak !== undefined ? (""+meta_cloak).toLowerCase() : "fade";
    }
    if (window.METRO_CLOAK_DURATION === undefined) {
        window.METRO_CLOAK_DURATION = meta_cloak_duration !== undefined ? parseInt(meta_cloak_duration) : 300;
    }

    if (window.METRO_HOTKEYS_FILTER_CONTENT_EDITABLE === undefined) {window.METRO_HOTKEYS_FILTER_CONTENT_EDITABLE = true;}
    if (window.METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS === undefined) {window.METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS = true;}
    if (window.METRO_HOTKEYS_FILTER_TEXT_INPUTS === undefined) {window.METRO_HOTKEYS_FILTER_TEXT_INPUTS = true;}
    if (window.METRO_HOTKEYS_BUBBLE_UP === undefined) {window.METRO_HOTKEYS_BUBBLE_UP = false;}
    if (window.METRO_THROWS === undefined) {window.METRO_THROWS = true;}

    window.METRO_MEDIA = [];

}(m4q));

/* Metro 4 Core */
(function( factory ) {
    if ( typeof define === 'function' && define.amd ) {
        define('metro4', factory );
    } else {
        factory( );
    }
}(function( ) {
    'use strict';

    var $ = m4q; // eslint-disable-line

    if (typeof m4q === 'undefined') {
        throw new Error('Metro 4 requires m4q helper!');
    }

    if (!('MutationObserver' in window)) {
        throw new Error('Metro 4 requires MutationObserver!');
    }

    var isTouch = (('ontouchstart' in window) || (navigator["MaxTouchPoints"] > 0) || (navigator["msMaxTouchPoints"] > 0));

    var normalizeComponentName = function(name){
        return typeof name !== "string" ? undefined : name.replace(/-/g, "").toLowerCase();
    };

    var Metro = {

        version: "4.4.1",
        compileTime: "14/11/2020 11:04:08",
        buildNumber: "@@build",
        isTouchable: isTouch,
        fullScreenEnabled: document.fullscreenEnabled,
        sheet: null,

        statuses: {
          HIDE: 'hide' ,
          SHOW: 'show' ,
          TOGGLE: 'toggle'
        } ,

        controlsPosition: {
            INSIDE: "inside",
            OUTSIDE: "outside"
        },

        groupMode: {
            ONE: "one",
            MULTI: "multi"
        },

        aspectRatio: {
            HD: "hd",
            SD: "sd",
            CINEMA: "cinema"
        },

        fullScreenMode: {
            WINDOW: "window",
            DESKTOP: "desktop"
        },

        position: {
            TOP: "top",
            BOTTOM: "bottom",
            LEFT: "left",
            RIGHT: "right",
            TOP_RIGHT: "top-right",
            TOP_LEFT: "top-left",
            BOTTOM_LEFT: "bottom-left",
            BOTTOM_RIGHT: "bottom-right",
            LEFT_BOTTOM: "left-bottom",
            LEFT_TOP: "left-top",
            RIGHT_TOP: "right-top",
            RIGHT_BOTTOM: "right-bottom"
        },

        popoverEvents: {
            CLICK: "click",
            HOVER: "hover",
            FOCUS: "focus"
        },

        stepperView: {
            SQUARE: "square",
            CYCLE: "cycle",
            DIAMOND: "diamond"
        },

        listView: {
            LIST: "list",
            CONTENT: "content",
            ICONS: "icons",
            ICONS_MEDIUM: "icons-medium",
            ICONS_LARGE: "icons-large",
            TILES: "tiles",
            TABLE: "table"
        },

        events: {
            click: 'click',
            start: isTouch ? 'touchstart' : 'mousedown',
            stop: isTouch ? 'touchend' : 'mouseup',
            move: isTouch ? 'touchmove' : 'mousemove',
            enter: isTouch ? 'touchstart' : 'mouseenter',

            startAll: 'mousedown touchstart',
            stopAll: 'mouseup touchend',
            moveAll: 'mousemove touchmove',

            leave: 'mouseleave',
            focus: 'focus',
            blur: 'blur',
            resize: 'resize',
            keyup: 'keyup',
            keydown: 'keydown',
            keypress: 'keypress',
            dblclick: 'dblclick',
            input: 'input',
            change: 'change',
            cut: 'cut',
            paste: 'paste',
            scroll: 'scroll',
            mousewheel: 'mousewheel',
            inputchange: "change input propertychange cut paste copy drop",
            dragstart: "dragstart",
            dragend: "dragend",
            dragenter: "dragenter",
            dragover: "dragover",
            dragleave: "dragleave",
            drop: 'drop',
            drag: 'drag'
        },

        keyCode: {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            BREAK: 19,
            CAPS: 20,
            ESCAPE: 27,
            SPACE: 32,
            PAGEUP: 33,
            PAGEDOWN: 34,
            END: 35,
            HOME: 36,
            LEFT_ARROW: 37,
            UP_ARROW: 38,
            RIGHT_ARROW: 39,
            DOWN_ARROW: 40,
            COMMA: 188
        },

        media_queries: {
            FS: "(min-width: 0px)",
            XS: "(min-width: 360px)",
            SM: "(min-width: 576px)",
            MD: "(min-width: 768px)",
            LG: "(min-width: 992px)",
            XL: "(min-width: 1200px)",
            XXL: "(min-width: 1452px)"
        },

        media_sizes: {
            FS: 0,
            XS: 360,
            SM: 576,
            LD: 640,
            MD: 768,
            LG: 992,
            XL: 1200,
            XXL: 1452
        },

        media_mode: {
            FS: "fs",
            XS: "xs",
            SM: "sm",
            MD: "md",
            LG: "lg",
            XL: "xl",
            XXL: "xxl"
        },

        media_modes: ["fs","xs","sm","md","lg","xl","xxl"],

        actions: {
            REMOVE: 1,
            HIDE: 2
        },

        hotkeys: {},
        locales: {},
        utils: {},
        colors: {},
        dialog: null,
        pagination: null,
        md5: null,
        storage: null,
        export: null,
        animations: null,
        cookie: null,
        template: null,

        about: function(){
            var content =
                "<h3>About</h3>" +
                "<hr>" +
                "<div><b>Metro 4</b> - v" + Metro.version +". "+ Metro.showCompileTime() + "</div>" +
                "<div><b>M4Q</b> - " + m4q.version + "</div>";
            Metro.infobox.create(content)
        },

        info: function(){
            console.info("Metro 4 - v" + Metro.version +". "+ Metro.showCompileTime());
            console.info("m4q - " + m4q.version);
        },

        showCompileTime: function(){
            return "Built at: " + Metro.compileTime;
        },

        aboutDlg: function(){
            alert("Metro 4 - v" + Metro.version +". "+ Metro.showCompileTime());
        },

        ver: function(){
            return Metro.version;
        },

        build: function(){
            return Metro.build;
        },

        compile: function(){
            return Metro.compileTime;
        },

        observe: function(){
            var observer, observerCallback;
            var observerConfig = {
                childList: true,
                attributes: true,
                subtree: true
            };
            observerCallback = function(mutations){
                mutations.map(function(mutation){
                    if (mutation.type === 'attributes' && mutation.attributeName !== "data-role") {
                        if (mutation.attributeName === 'data-hotkey') {
                            Metro.initHotkeys([mutation.target], true);
                        } else {
                            var element = $(mutation.target);
                            var mc = element.data('metroComponent');
                            var attr = mutation.attributeName, newValue = element.attr(attr), oldValue = mutation.oldValue;

                            if (mc !== undefined) {
                                element.fire("attr-change", {
                                    attr: attr,
                                    newValue: newValue,
                                    oldValue: oldValue,
                                    __this: element[0]
                                });

                                $.each(mc, function(){
                                    var plug = Metro.getPlugin(element, this);
                                    if (plug && typeof plug.changeAttribute === "function") {
                                        plug.changeAttribute(attr, newValue, oldValue);
                                    }
                                });
                            }
                        }
                    } else

                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        var i, widgets = [];
                        var $node, node, nodes = mutation.addedNodes;

                        if (nodes.length) {
                            for(i = 0; i < nodes.length; i++) {
                                node = nodes[i];
                                $node = $(node);

                                if ($node.attr("data-role") !== undefined) {
                                    widgets.push(node);
                                }

                                $.each($node.find("[data-role]"), function(){
                                    var o = this;
                                    if (widgets.indexOf(o) !== -1) {
                                        return;
                                    }
                                    widgets.push(o);
                                });
                            }

                            if (widgets.length) Metro.initWidgets(widgets, "observe");
                        }

                    } else  {
                        //
                    }
                });
            };
            observer = new MutationObserver(observerCallback);
            observer.observe($("html")[0], observerConfig);
        },

        init: function(){
            var widgets = $("[data-role]");
            var hotkeys = $("[data-hotkey]");
            var html = $("html");
            var that = this;

            if (window.METRO_BLUR_IMAGE) {
                html.addClass("use-blur-image");
            }

            if (window.METRO_SHOW_ABOUT) Metro.info(true);

            if (isTouch === true) {
                html.addClass("metro-touch-device");
            } else {
                html.addClass("metro-no-touch-device");
            }

            Metro.sheet = this.utils.newCssSheet();

            this.utils.addCssRule(Metro.sheet, "*, *::before, *::after", "box-sizing: border-box;");

            window.METRO_MEDIA = [];
            $.each(Metro.media_queries, function(key, query){
                if (that.utils.media(query)) {
                    window.METRO_MEDIA.push(Metro.media_mode[key]);
                }
            });

            Metro.observe();

            Metro.initHotkeys(hotkeys);
            Metro.initWidgets(widgets, "init");

            if (window.METRO_CLOAK_REMOVE !== "fade") {
                $(".m4-cloak").removeClass("m4-cloak");
                $(window).fire("metro-initiated");
            } else {
                $(".m4-cloak").animate({
                    draw: {
                        opacity: 1
                    },
                    dur: 300,
                    onDone: function(){
                        $(".m4-cloak").removeClass("m4-cloak");
                        $(window).fire("metro-initiated");
                    }
                });
            }
        },

        initHotkeys: function(hotkeys, redefine){
            $.each(hotkeys, function(){
                var element = $(this);
                var hotkey = element.attr('data-hotkey') ? element.attr('data-hotkey').toLowerCase() : false;
                var fn = element.attr('data-hotkey-func') ? element.attr('data-hotkey-func') : false;

                if (hotkey === false) {
                    return;
                }

                if (element.data('hotKeyBonded') === true && redefine !== true) {
                    return;
                }

                Metro.hotkeys[hotkey] = [this, fn];
                element.data('hotKeyBonded', true);
                element.fire("hot-key-bonded", {
                    __this: element[0],
                    hotkey: hotkey,
                    fn: fn
                });
            });
        },

        initWidgets: function(widgets) {
            var that = this;

            $.each(widgets, function () {
                var $this = $(this), roles;

                if (!this.hasAttribute("data-role")) {
                    return ;
                }

                roles = $this.attr('data-role').split(/\s*,\s*/);

                roles.map(function (func) {

                    var $$ = that.utils.$();
                    var _func = normalizeComponentName(func);

                    if ($$.fn[_func] !== undefined && $this.attr("data-role-"+_func) === undefined) {
                        try {
                            $$.fn[_func].call($this);
                            $this.attr("data-role-"+_func, true);

                            var mc = $this.data('metroComponent');

                            if (mc === undefined) {
                                mc = [_func];
                            } else {
                                mc.push(_func);
                            }
                            $this.data('metroComponent', mc);

                            $this.fire("create", {
                                __this: $this[0],
                                name: _func
                            });
                            $(document).fire("component-create", {
                                element: $this[0],
                                name: _func
                            });
                        } catch (e) {
                            console.error("Error creating component " + func + " for ", $this[0]);
                            throw e;
                        }
                    }
                });
            });
        },

        plugin: function(name, object){
            var _name = normalizeComponentName(name);

            var register = function($){
                $.fn[_name] = function( options ) {
                    return this.each(function() {
                        $.data( this, _name, Object.create(object).init(options, this ));
                    });
                };
            }

            register(m4q);

            if (window.useJQuery) {
                register(jQuery);
            }
        },

        destroyPlugin: function(element, name){
            var p, mc;
            var el = $(element);
            var _name = normalizeComponentName(name);

            p = Metro.getPlugin(el, _name);

            if (typeof p === 'undefined') {
                console.warn("Component "+name+" can not be destroyed: the element is not a Metro 4 component.");
                return ;
            }

            if (typeof p['destroy'] !== 'function') {
                console.warn("Component "+name+" can not be destroyed: method destroy not found.");
                return ;
            }

            p['destroy']();
            mc = el.data("metroComponent");
            this.utils.arrayDelete(mc, _name);
            el.data("metroComponent", mc);
            $.removeData(el[0], _name);
            el.removeAttr("data-role-"+_name);
        },

        destroyPluginAll: function(element){
            var el = $(element);
            var mc = el.data("metroComponent");

            if (mc !== undefined && mc.length > 0) $.each(mc, function(){
                Metro.destroyPlugin(el[0], this);
            });
        },

        noop: function(){},
        noop_true: function(){return true;},
        noop_false: function(){return false;},

        requestFullScreen: function(element){
            if (element["mozRequestFullScreen"]) {
                element["mozRequestFullScreen"]();
            } else if (element["webkitRequestFullScreen"]) {
                element["webkitRequestFullScreen"]();
            } else if (element["msRequestFullscreen"]) {
                element["msRequestFullscreen"]();
            } else {
                element.requestFullscreen().catch( function(err){
                    console.warn("Error attempting to enable full-screen mode: "+err.message+" "+err.name);
                });
            }
        },

        exitFullScreen: function(){
            if (document["mozCancelFullScreen"]) {
                document["mozCancelFullScreen"]();
            }
            else if (document["webkitCancelFullScreen"]) {
                document["webkitCancelFullScreen"]();
            }
            else if (document["msExitFullscreen"]) {
                document["msExitFullscreen"]();
            } else {
                document.exitFullscreen().catch( function(err){
                    console.warn("Error attempting to disable full-screen mode: "+err.message+" "+err.name);
                });
            }
        },

        inFullScreen: function(){
            var fsm = (document.fullscreenElement || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"]);
            return fsm !== undefined;
        },

        $: function(){
            return window.useJQuery ? jQuery : m4q;
        },

        get$el: function(el){
            return Metro.$()($(el)[0]);
        },

        getPlugin: function(el, name){
            var _name = normalizeComponentName(name);
            var $el = Metro.get$el(el);
            return $el.length ? $el.data(_name) : undefined;
        },

        makePlugin: function(el, name, options){
            var _name = normalizeComponentName(name);
            var $el = Metro.get$el(el);
            return $el.length && typeof $el[_name] === "function" ? $el[_name](options) : undefined;
        },

        Component: function(nameName, compObj){
            var name = normalizeComponentName(nameName);
            var Utils = Metro.utils;
            var component = $.extend({name: name}, {
                _super: function(el, options, defaults, setup){
                    var self = this;

                    this.elem = el;
                    this.element = $(el);
                    this.options = $.extend( {}, defaults, options );
                    this.component = this.elem;

                    this._setOptionsFromDOM();
                    this._runtime();

                    if (setup && typeof setup === 'object') {
                        $.each(setup, function(key, val){
                            self[key] = val;
                        })
                    }

                    this._createExec();
                },

                _setOptionsFromDOM: function(){
                    var element = this.element, o = this.options;

                    $.each(element.data(), function(key, value){
                        if (key in o) {
                            try {
                                o[key] = JSON.parse(value);
                            } catch (e) {
                                o[key] = value;
                            }
                        }
                    });
                },

                _runtime: function(){
                    var element = this.element, mc;
                    var roles = (element.attr("data-role") || "").toArray(",").map(function(v){
                        return normalizeComponentName(v);
                    });

                    if (!element.attr('data-role-'+this.name)) {
                        element.attr("data-role-"+this.name, true);
                        if (roles.indexOf(this.name) === -1) {
                            roles.push(this.name);
                            element.attr("data-role", roles.join(","));
                        }

                        mc = element.data('metroComponent');
                        if (mc === undefined) {
                            mc = [this.name];
                        } else {
                            mc.push(this.name);
                        }
                        element.data('metroComponent', mc);
                    }
                },

                _createExec: function(){
                    var that = this, timeout = this.options[this.name+'Deferred'];

                    if (timeout) {
                        setTimeout(function(){
                            that._create();
                        }, timeout)
                    } else {
                        that._create();
                    }
                },

                _fireEvent: function(eventName, data, log, noFire){
                    var element = this.element, o = this.options;
                    var _data;
                    var event = eventName.camelCase().capitalize();

                    data = $.extend({}, data, {__this: element[0]});

                    _data = data ? Object.values(data) : {};

                    if (log) {
                        console.warn(log);
                        console.warn("Event: " + "on"+eventName.camelCase().capitalize());
                        console.warn("Data: ", data);
                        console.warn("Element: ", element[0]);
                    }

                    if (noFire !== true)
                        element.fire(event.toLowerCase(), data);

                    return Utils.exec(o["on"+event], _data, element[0]);
                },

                getComponent: function(){
                    return this.component;
                },

                getComponentName: function(){
                    return this.name;
                }
            }, compObj);

            Metro.plugin(name, component);

            return component;
        }
    };

    $(window).on(Metro.events.resize, function(){
        window.METRO_MEDIA = [];
        $.each(Metro.media_queries, function(key, query){
            if (Metro.utils.media(query)) {
                window.METRO_MEDIA.push(Metro.media_mode[key]);
            }
        });
    });

    window.Metro = Metro;

    if (window.METRO_INIT ===  true) {
        $(function(){
            Metro.init()
        });
    }

    return Metro;

}));


(function(Metro, $) {
    $.extend(Metro.locales, {
        'cn-ZH': {
            "calendar": {
                "months": [
                    "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月",
                    "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"
                ],
                "days": [
                    "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六",
                    "日", "一", "二", "三", "四", "五", "六",
                    "周日", "周一", "周二", "周三", "周四", "周五", "周六"
                ],
                "time": {
                    "days": "天",
                    "hours": "时",
                    "minutes": "分",
                    "seconds": "秒",
                    "month": "月",
                    "day": "日",
                    "year": "年"
                }
            },
            "buttons": {
                "ok": "确认",
                "cancel": "取消",
                "done": "完成",
                "today": "今天",
                "now": "现在",
                "clear": "清除",
                "help": "帮助",
                "yes": "是",
                "no": "否",
                "random": "随机",
                "save": "保存",
                "reset": "重啟"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro['locales'], {
        'da-DK': {
            "calendar": {
                "months": [
                    "Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December",
                    "Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"
                ],
                "days": [
                    "Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag",
                    "Sø", "Ma", "Ti", "On", "To", "Fr", "Lø",
                    "Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
                ],
                "time": {
                    "days": "DAGE",
                    "hours": "TIMER",
                    "minutes": "MIN",
                    "seconds": "SEK",
                    "month": "MON",
                    "day": "DAG",
                    "year": "ÅR"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annuller",
                "done": "Færdig",
                "today": "Idag",
                "now": "Nu",
                "clear": "Ryd",
                "help": "Hjælp",
                "yes": "Ja",
                "no": "Nej",
                "random": "Tilfældig",
                "save": "Gem",
                "reset": "Nulstil"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'de-DE': {
            "calendar": {
                "months": [
                    "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember",
                    "Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"
                ],
                "days": [
                    "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag",
                    "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa",
                    "Son", "Mon", "Die", "Mit", "Don", "Fre", "Sam"
                ],
                "time": {
                    "days": "TAGE",
                    "hours": "STD",
                    "minutes": "MIN",
                    "seconds": "SEK"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Abbrechen",
                "done": "Fertig",
                "today": "Heute",
                "now": "Jetzt",
                "clear": "Löschen",
                "help": "Hilfe",
                "yes": "Ja",
                "no": "Nein",
                "random": "Zufällig",
                "save": "Speichern",
                "reset": "Zurücksetzen"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'en-US': {
            "calendar": {
                "months": [
                    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December",
                    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
                ],
                "days": [
                    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday",
                    "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa",
                    "Sun", "Mon", "Tus", "Wen", "Thu", "Fri", "Sat"
                ],
                "time": {
                    "days": "DAYS",
                    "hours": "HOURS",
                    "minutes": "MINS",
                    "seconds": "SECS",
                    "month": "MON",
                    "day": "DAY",
                    "year": "YEAR"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Cancel",
                "done": "Done",
                "today": "Today",
                "now": "Now",
                "clear": "Clear",
                "help": "Help",
                "yes": "Yes",
                "no": "No",
                "random": "Random",
                "save": "Save",
                "reset": "Reset"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'es-MX': {
            "calendar": {
                "months": [
                    "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre",
                    "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"
                ],
                "days": [
                    "Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado",
                    "Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa",
                    "Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"
                ],
                "time": {
                    "days": "DÍAS",
                    "hours": "HORAS",
                    "minutes": "MINS",
                    "seconds": "SEGS",
                    "month": "MES",
                    "day": "DÍA",
                    "year": "AÑO"
                }
            },
            "buttons": {
                "ok": "Aceptar",
                "cancel": "Cancelar",
                "done": "Hecho",
                "today": "Hoy",
                "now": "Ahora",
                "clear": "Limpiar",
                "help": "Ayuda",
                "yes": "Si",
                "no": "No",
                "random": "Aleatorio",
                "save": "Salvar",
                "reset": "Reiniciar"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'fr-FR': {
            "calendar": {
                "months": [
                    "Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre",
                    "Janv", "Févr", "Mars", "Avr", "Mai", "Juin", "Juil", "Août", "Sept", "Oct", "Nov", "Déc"
                ],
                "days": [
                    "Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi",
                    "Di", "Lu", "Ma", "Me", "Je", "Ve", "Sa",
                    "Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"
                ],
                "time": {
                    "days": "JOURS",
                    "hours": "HEURES",
                    "minutes": "MINS",
                    "seconds": "SECS",
                    "month": "MOIS",
                    "day": "JOUR",
                    "year": "ANNEE"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annulé",
                "done": "Fait",
                "today": "Aujourd'hui",
                "now": "Maintenant",
                "clear": "Effacé",
                "help": "Aide",
                "yes": "Oui",
                "no": "Non",
                "random": "Aléatoire",
                "save": "Sauvegarder",
                "reset": "Réinitialiser"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'hu-HU': {
            "calendar": {
                "months": [
                    'Január', 'Február', 'Március', 'Április', 'Május', 'Június', 'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December',
                    'Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún', 'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'
                ],
                "days": [
                    'Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat',
                    'V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz',
                    'Vas', 'Hét', 'Ke', 'Sze', 'Csü', 'Pén', 'Szom'
                ],
                "time": {
                    "days": "NAP",
                    "hours": "ÓRA",
                    "minutes": "PERC",
                    "seconds": "MP"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Mégse",
                "done": "Kész",
                "today": "Ma",
                "now": "Most",
                "clear": "Törlés",
                "help": "Segítség",
                "yes": "Igen",
                "no": "Nem",
                "random": "Véletlen",
                "save": "Mentés",
                "reset": "Visszaállítás"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'it-IT': {
            "calendar": {
                "months": [
                    "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre",
                    "Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"
                ],
                "days": [
                    "Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato",
                    "Do", "Lu", "Ma", "Me", "Gi", "Ve", "Sa",
                    "Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
                ],
                "time": {
                    "days": "GIORNI",
                    "hours": "ORE",
                    "minutes": "MIN",
                    "seconds": "SEC",
                    "month": "MESE",
                    "day": "GIORNO",
                    "year": "ANNO"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annulla",
                "done": "Fatto",
                "today": "Oggi",
                "now": "Adesso",
                "clear": "Cancella",
                "help": "Aiuto",
                "yes": "Sì",
                "no": "No",
                "random": "Random",
                "save": "Salvare",
                "reset": "Reset"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'pt-BR': {
            "calendar": {
                "months": [
                    "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro",
                    "Jan", "Fev", "Mar", "Abr", "Maio", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"
                ],
                "days": [
                    "Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado",
                    "Do", "Se", "Te", "Qa", "Qi", "Se", "Sa",
                    "Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"
                ],
                "time": {
                    "days": "DIAS",
                    "hours": "HORAS",
                    "minutes": "MINUTOS",
                    "seconds": "SEGUNDOS",
                    "month": "MÊS",
                    "day": "DIA",
                    "year": "ANO"
                }
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Cancelar",
                "done": "Feito",
                "today": "Hoje",
                "now": "Agora",
                "clear": "Limpar",
                "help": "Ajuda",
                "yes": "Sim",
                "no": "Não",
                "random": "Aleatório",
                "save": "Salvar",
                "reset": "Restaurar"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'ru-RU': {
            "calendar": {
                "months": [
                    "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь",
                    "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"
                ],
                "days": [
                    "Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота",
                    "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб",
                    "Вос", "Пон", "Вто", "Сре", "Чет", "Пят", "Суб"
                ],
                "time": {
                    "days": "ДНИ",
                    "hours": "ЧАСЫ",
                    "minutes": "МИН",
                    "seconds": "СЕК"
                }
            },
            "buttons": {
                "ok": "ОК",
                "cancel": "Отмена",
                "done": "Готово",
                "today": "Сегодня",
                "now": "Сейчас",
                "clear": "Очистить",
                "help": "Помощь",
                "yes": "Да",
                "no": "Нет",
                "random": "Случайно",
                "save": "Сохранить",
                "reset": "Сброс"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'tw-ZH': {
            "calendar": {
                "months": [
                    "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月",
                    "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"
                ],
                "days": [
                    "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六",
                    "日", "一", "二", "三", "四", "五", "六",
                    "週日", "週一", "週二", "週三", "週四", "週五", "週六"
                ],
                "time": {
                    "days": "天",
                    "hours": "時",
                    "minutes": "分",
                    "seconds": "秒",
                    "month": "月",
                    "day": "日",
                    "year": "年"
                }
            },
            "buttons": {
                "ok": "確認",
                "cancel": "取消",
                "done": "完成",
                "today": "今天",
                "now": "現在",
                "clear": "清除",
                "help": "幫助",
                "yes": "是",
                "no": "否",
                "random": "隨機",
                "save": "保存",
                "reset": "重啟"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'uk-UA': {
            "calendar": {
                "months": [
                    "Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень",
                    "Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"
                ],
                "days": [
                    "Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П’ятниця", "Субота",
                    "Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб",
                    "Нед", "Пон", "Вiв", "Сер", "Чет", "Пят", "Суб"
                ],
                "time": {
                    "days": "ДНІ",
                    "hours": "ГОД",
                    "minutes": "ХВИЛ",
                    "seconds": "СЕК"
                }
            },
            "buttons": {
                "ok": "ОК",
                "cancel": "Відміна",
                "done": "Готово",
                "today": "Сьогодні",
                "now": "Зараз",
                "clear": "Очистити",
                "help": "Допомога",
                "yes": "Так",
                "no": "Ні",
                "random": "Випадково",
                "save": "Зберегти",
                "reset": "Скинути"
            }
        }
    });
}(Metro, m4q));

(function() {
    'use strict';

    if (typeof Array.shuffle !== "function") {
        Array.prototype.shuffle = function () {
            var currentIndex = this.length, temporaryValue, randomIndex;

            while (0 !== currentIndex) {

                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                temporaryValue = this[currentIndex];
                this[currentIndex] = this[randomIndex];
                this[randomIndex] = temporaryValue;
            }

            return this;
        };
    }

    if (typeof Array.clone !== "function") {
        Array.prototype.clone = function () {
            return this.slice(0);
        };
    }

    if (typeof Array.unique !== "function") {
        Array.prototype.unique = function () {
            var a = this.concat();
            for (var i = 0; i < a.length; ++i) {
                for (var j = i + 1; j < a.length; ++j) {
                    if (a[i] === a[j])
                        a.splice(j--, 1);
                }
            }

            return a;
        };
    }

    if (typeof Array.from !== "function") {
        Array.prototype.from = function(val) {
            var i, a = [];

            if (val.length === undefined && typeof val === "object") {
                return Object.values(val);
            }

            if (val.length !== undefined) {
                for(i = 0; i < val.length; i++) {
                    a.push(val[i]);
                }
                return a;
            }

            throw new Error("Value can not be converted to array");
        };
    }

    if (typeof Array.contains !== "function") {
        Array.prototype.contains = function(val, from){
            return this.indexOf(val, from) > -1;
        }
    }

    if (typeof Array.includes !== "function") {
        Array.prototype.includes = function(val, from){
            return this.indexOf(val, from) > -1;
        }
    }
}());

(function(Metro) {
    'use strict';
    Date.prototype.getWeek = function (dowOffset) {
        var nYear, nday, newYear, day, daynum, weeknum;

        dowOffset = !Utils.isValue(dowOffset) ? METRO_WEEK_START : typeof dowOffset === 'number' ? parseInt(dowOffset) : 0;
        newYear = new Date(this.getFullYear(),0,1);
        day = newYear.getDay() - dowOffset;
        day = (day >= 0 ? day : day + 7);
        daynum = Math.floor((this.getTime() - newYear.getTime() -
            (this.getTimezoneOffset()-newYear.getTimezoneOffset())*60000)/86400000) + 1;

        if(day < 4) {
            weeknum = Math.floor((daynum+day-1)/7) + 1;
            if(weeknum > 52) {
                nYear = new Date(this.getFullYear() + 1,0,1);
                nday = nYear.getDay() - dowOffset;
                nday = nday >= 0 ? nday : nday + 7;
                weeknum = nday < 4 ? 1 : 53;
            }
        }
        else {
            weeknum = Math.floor((daynum+day-1)/7);
        }
        return weeknum;
    };

    Date.prototype.getYear = function(){
        return this.getFullYear().toString().substr(-2);
    };

    Date.prototype.format = function(format, locale){

        if (locale === undefined) {
            locale = "en-US";
        }

        var cal = (Metro.locales !== undefined && Metro.locales[locale] !== undefined ? Metro.locales[locale] : Metro.locales["en-US"])['calendar'];

        var date = this;
        var nDay = date.getDay(),
            nDate = date.getDate(),
            nMonth = date.getMonth(),
            nYear = date.getFullYear(),
            nHour = date.getHours(),
            aDays = cal['days'],
            aMonths = cal['months'],
            aDayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
            isLeapYear = function() {
                return (nYear%4===0 && nYear%100!==0) || nYear%400===0;
            },
            getThursday = function() {
                var target = new Date(date);
                target.setDate(nDate - ((nDay+6)%7) + 3);
                return target;
            },
            zeroPad = function(nNum, nPad) {
                return ('' + (Math.pow(10, nPad) + nNum)).slice(1);
            };
        return format.replace(/(%[a-z])/gi, function(sMatch) {
            return {
                '%a': aDays[nDay].slice(0,3),
                '%A': aDays[nDay],
                '%b': aMonths[nMonth].slice(0,3),
                '%B': aMonths[nMonth],
                '%c': date.toUTCString(),
                '%C': Math.floor(nYear/100),
                '%d': zeroPad(nDate, 2),
                'dd': zeroPad(nDate, 2),
                '%e': nDate,
                '%F': date.toISOString().slice(0,10),
                '%G': getThursday().getFullYear(),
                '%g': ('' + getThursday().getFullYear()).slice(2),
                '%H': zeroPad(nHour, 2),
                // 'HH': zeroPad(nHour, 2),
                '%I': zeroPad((nHour+11)%12 + 1, 2),
                '%j': zeroPad(aDayCount[nMonth] + nDate + ((nMonth>1 && isLeapYear()) ? 1 : 0), 3),
                '%k': '' + nHour,
                '%l': (nHour+11)%12 + 1,
                '%m': zeroPad(nMonth + 1, 2),
                // 'mm': zeroPad(nMonth + 1, 2),
                '%M': zeroPad(date.getMinutes(), 2),
                // 'MM': zeroPad(date.getMinutes(), 2),
                '%p': (nHour<12) ? 'AM' : 'PM',
                '%P': (nHour<12) ? 'am' : 'pm',
                '%s': Math.round(date.getTime()/1000),
                // 'ss': Math.round(date.getTime()/1000),
                '%S': zeroPad(date.getSeconds(), 2),
                // 'SS': zeroPad(date.getSeconds(), 2),
                '%u': nDay || 7,
                '%V': (function() {
                    var target = getThursday(),
                        n1stThu = target.valueOf();
                    target.setMonth(0, 1);
                    var nJan1 = target.getDay();
                    if (nJan1!==4) target.setMonth(0, 1 + ((4-nJan1)+7)%7);
                    return zeroPad(1 + Math.ceil((n1stThu-target)/604800000), 2);
                })(),
                '%w': '' + nDay,
                '%x': date.toLocaleDateString(),
                '%X': date.toLocaleTimeString(),
                '%y': ('' + nYear).slice(2),
                // 'yy': ('' + nYear).slice(2),
                '%Y': nYear,
                // 'YYYY': nYear,
                '%z': date.toTimeString().replace(/.+GMT([+-]\d+).+/, '$1'),
                '%Z': date.toTimeString().replace(/.+\((.+?)\)$/, '$1')
            }[sMatch] || sMatch;
        });
    };

    Date.prototype.addHours = function(n) {
        this.setTime(this.getTime() + (n*60*60*1000));
        return this;
    };

    Date.prototype.addDays = function(n) {
        this.setDate(this.getDate() + (n));
        return this;
    };

    Date.prototype.addMonths = function(n) {
        this.setMonth(this.getMonth() + (n));
        return this;
    };

    Date.prototype.addYears = function(n) {
        this.setFullYear(this.getFullYear() + (n));
        return this;
    };
}(Metro));

(function() {
    'use strict';

    /**
     * Number.prototype.format(n, x, s, c)
     *
     * @param  n: length of decimal
     * @param  x: length of whole part
     * @param  s: sections delimiter
     * @param  c: decimal delimiter
     */
    Number.prototype.format = function(n, x, s, c) {
        var re = '\\d(?=(\\d{' + (x || 3) + '})+' + (n > 0 ? '\\D' : '$') + ')',
            num = this.toFixed(Math.max(0, ~~n));

        return (c ? num.replace('.', c) : num).replace(new RegExp(re, 'g'), '$&' + (s || ','));
    };
}());

(function() {
    'use strict';

    if ( typeof Object.create !== 'function' ) {
        Object.create = function (o) {
            function F() {}
            F.prototype = o;
            return new F();
        };
    }

    if (typeof Object.values !== 'function') {
        Object.values = function(obj) {
            return Object.keys(obj).map(function(e) {
                return obj[e]
            });
        }
    }
}());

(function(Metro, $) {
    'use strict';

    String.prototype.camelCase = function(){
        return $.camelCase(this);
    };

    String.prototype.dashedName = function(){
        return $.dashedName(this);
    };

    String.prototype.shuffle = function(){
        var _shuffle = function (a) {
            var currentIndex = a.length, temporaryValue, randomIndex;

            while (0 !== currentIndex) {

                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                temporaryValue = a[currentIndex];
                a[currentIndex] = a[randomIndex];
                a[randomIndex] = temporaryValue;
            }

            return a;
        };

        return _shuffle(this.split("")).join("");
    }

    String.prototype.capitalize = function() {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };

    String.prototype.contains = function() {
        return !!~String.prototype.indexOf.apply(this, arguments);
    };

    if (typeof String.includes !== "function") {
        String.prototype.includes = function(){
            return !!~String.prototype.indexOf.apply(this, arguments);
        }
    }

    String.prototype.toDate = function(format, locale) {
        var result;
        var normalized, normalizedFormat, formatItems, dateItems, checkValue;
        var monthIndex, dayIndex, yearIndex, hourIndex, minutesIndex, secondsIndex;
        var year, month, day, hour, minute, second;
        var parsedMonth;

        locale = locale || "en-US";

        var monthNameToNumber = function(month){
            var d, months, index, i;
            var Locales = Metro.locales;

            if (typeof month === "undefined" || month === null) {
                return -1;
            }

            month = month.substr(0, 3);

            if (
                locale !== undefined
                && locale !== "en-US"
                && Locales !== undefined
                && Locales[locale] !== undefined
                && Locales[locale]['calendar'] !== undefined
                && Locales[locale]['calendar']['months'] !== undefined
            ) {
                months = Locales[locale]['calendar']['months'];
                for(i = 12; i < months.length; i++) {
                    if (months[i].toLowerCase() === month.toLowerCase()) {
                        index = i - 12;
                        break;
                    }
                }
                month = Locales["en-US"]['calendar']['months'][index];
            }

            d = Date.parse(month + " 1, 1972");
            if(!isNaN(d)){
                return new Date(d).getMonth() + 1;
            }
            return -1;
        };

        if (format === undefined || format === null || format === "") {
            return new Date(this);
        }

        /* eslint-disable-next-line */
        normalized      = this.replace(/[\/,.:\s]/g, '-');
        /* eslint-disable-next-line */
        normalizedFormat= format.toLowerCase().replace(/[^a-zA-Z0-9%]/g, '-');
        formatItems     = normalizedFormat.split('-');
        dateItems       = normalized.split('-');
        checkValue      = normalized.replace(/-/g,"");

        if (checkValue.trim() === "") {
            return "Invalid Date";
        }

        monthIndex  = formatItems.indexOf("mm") > -1 ? formatItems.indexOf("mm") : formatItems.indexOf("%m");
        dayIndex    = formatItems.indexOf("dd") > -1 ? formatItems.indexOf("dd") : formatItems.indexOf("%d");
        yearIndex   = formatItems.indexOf("yyyy") > -1 ? formatItems.indexOf("yyyy") : formatItems.indexOf("yy") > -1 ? formatItems.indexOf("yy") : formatItems.indexOf("%y");
        hourIndex     = formatItems.indexOf("hh") > -1 ? formatItems.indexOf("hh") : formatItems.indexOf("%h");
        minutesIndex  = formatItems.indexOf("ii") > -1 ? formatItems.indexOf("ii") : formatItems.indexOf("mi") > -1 ? formatItems.indexOf("mi") : formatItems.indexOf("%i");
        secondsIndex  = formatItems.indexOf("ss") > -1 ? formatItems.indexOf("ss") : formatItems.indexOf("%s");

        if (monthIndex > -1 && dateItems[monthIndex] !== "") {
            if (isNaN(parseInt(dateItems[monthIndex]))) {
                dateItems[monthIndex] = monthNameToNumber(dateItems[monthIndex]);
                if (dateItems[monthIndex] === -1) {
                    return "Invalid Date";
                }
            } else {
                parsedMonth = parseInt(dateItems[monthIndex]);
                if (parsedMonth < 1 || parsedMonth > 12) {
                    return "Invalid Date";
                }
            }
        } else {
            return "Invalid Date";
        }

        year  = yearIndex >-1 && dateItems[yearIndex] !== "" ? dateItems[yearIndex] : null;
        month = monthIndex >-1 && dateItems[monthIndex] !== "" ? dateItems[monthIndex] : null;
        day   = dayIndex >-1 && dateItems[dayIndex] !== "" ? dateItems[dayIndex] : null;

        hour    = hourIndex >-1 && dateItems[hourIndex] !== "" ? dateItems[hourIndex] : null;
        minute  = minutesIndex>-1 && dateItems[minutesIndex] !== "" ? dateItems[minutesIndex] : null;
        second  = secondsIndex>-1 && dateItems[secondsIndex] !== "" ? dateItems[secondsIndex] : null;

        result = new Date(year,month-1,day,hour,minute,second);

        return result;
    };

    String.prototype.toArray = function(delimiter, type, format){
        var str = this;
        var a;

        type = type || "string";
        delimiter = delimiter || ",";
        format = format === undefined || format === null ? false : format;

        a = (""+str).split(delimiter);

        return a.map(function(s){
            var result;

            switch (type) {
                case "int":
                case "integer": result = isNaN(s) ? s.trim() : parseInt(s); break;
                case "number":
                case "float": result = isNaN(s) ? s : parseFloat(s); break;
                case "date": result = !format ? new Date(s) : s.toDate(format); break;
                default: result = s.trim();
            }

            return result;
        });
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    Metro.utils = {
        isVisible: function(element){
            var el = $(element)[0];
            return this.getStyleOne(el, "display") !== "none"
                && this.getStyleOne(el, "visibility") !== "hidden"
                && el.offsetParent !== null;
        },

        isUrl: function (val) {
            /* eslint-disable-next-line */
            return /^(\.\/|\.\.\/|ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@\-\/]))?/.test(val);
        },

        isTag: function(val){
            /* eslint-disable-next-line */
            return /^<\/?[\w\s="/.':;#-\/\?]+>/gi.test(val);
        },

        isColor: function (val) {
            /* eslint-disable-next-line */
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(val);
        },

        isEmbedObject: function(val){
            var embed = ["iframe", "object", "embed", "video"];
            var result = false;
            $.each(embed, function(){
                if (typeof val === "string" && val.toLowerCase() === this) {
                    result = true;
                } else if (val.nodeType !== undefined && val.tagName.toLowerCase() === this) {
                    result = true;
                }
            });
            return result;
        },

        isVideoUrl: function(val){
            return /youtu\.be|youtube|vimeo/gi.test(val);
        },

        isDate: function(val, format){
            var result;

            if (this.isDateObject(val)) {
                return true;
            }

            if (this.isValue(format)) {
                result = String(val).toDate(format);
            } else {
                result = String(new Date(val));
            }

            return result !== "Invalid Date";
        },

        isDateObject: function(v){
            return typeof v === 'object' && v.getMonth !== undefined;
        },

        isInt: function(n){
            return !isNaN(n) && +n % 1 === 0;
        },

        isFloat: function(n){
            return (!isNaN(n) && +n % 1 !== 0) || /^\d*\.\d+$/.test(n);
        },

        isFunc: function(f){
            return this.isType(f, 'function');
        },

        isObject: function(o){
            return this.isType(o, 'object');
        },

        isType: function(o, t){
            if (!this.isValue(o)) {
                return false;
            }

            if (typeof o === t) {
                return o;
            }

            if ((""+t).toLowerCase() === 'tag' && this.isTag(o)) {
                return o;
            }

            if ((""+t).toLowerCase() === 'url' && this.isUrl(o)) {
                return o;
            }

            if ((""+t).toLowerCase() === 'array' && Array.isArray(o)) {
                return o;
            }

            if (this.isTag(o) || this.isUrl(o)) {
                return false;
            }

            if (typeof window[o] === t) {
                return window[o];
            }

            if (typeof o === 'string' && o.indexOf(".") === -1) {
                return false;
            }

            if (typeof o === 'string' && /[/\s([]+/gm.test(o)) {
                return false;
            }

            if (typeof o === "number" && t.toLowerCase() !== "number") {
                return false;
            }

            var ns = o.split(".");
            var i, context = window;

            for(i = 0; i < ns.length; i++) {
                context = context[ns[i]];
            }

            return typeof context === t ? context : false;
        },

        $: function(){
            return window.useJQuery ? jQuery : m4q;
        },

        isMetroObject: function(el, type){
            var $el = $(el), el_obj = Metro.getPlugin(el, type);

            if ($el.length === 0) {
                console.warn(type + ' ' + el + ' not found!');
                return false;
            }

            if (el_obj === undefined) {
                console.warn('Element not contain role '+ type +'! Please add attribute data-role="'+type+'" to element ' + el);
                return false;
            }

            return true;
        },

        isJQuery: function(el){
            return (typeof jQuery !== "undefined" && el instanceof jQuery);
        },

        isM4Q: function(el){
            return (typeof m4q !== "undefined" && el instanceof m4q);
        },

        isQ: function(el){
            return this.isJQuery(el) || this.isM4Q(el);
        },

        isIE11: function(){
            return !!window.MSInputMethodContext && !!document["documentMode"];
        },

        embedObject: function(val){
            return "<div class='embed-container'>" + $(val)[0].outerHTML + "</div>";
        },

        embedUrl: function(val){
            if (val.indexOf("youtu.be") !== -1) {
                val = "https://www.youtube.com/embed/" + val.split("/").pop();
            }
            return "<div class='embed-container'><iframe src='"+val+"'></iframe></div>";
        },

        secondsToTime: function(secs) {
            var hours = Math.floor(secs / (60 * 60));

            var divisor_for_minutes = secs % (60 * 60);
            var minutes = Math.floor(divisor_for_minutes / 60);

            var divisor_for_seconds = divisor_for_minutes % 60;
            var seconds = Math.ceil(divisor_for_seconds);

            return {
                "h": hours,
                "m": minutes,
                "s": seconds
            };
        },

        hex2rgba: function(hex, alpha){
            var c;
            alpha = isNaN(alpha) ? 1 : alpha;
            if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length=== 3){
                    c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c= '0x'+c.join('');
                return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+alpha+')';
            }
            throw new Error('Hex2rgba error. Bad Hex value');
        },

        elementId: function(prefix){
            return prefix+"-"+(new Date()).getTime()+$.random(1, 1000);
        },

        secondsToFormattedString: function(time){
            var sec_num = parseInt(time, 10);
            var hours   = Math.floor(sec_num / 3600);
            var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
            var seconds = sec_num - (hours * 3600) - (minutes * 60);

            if (hours   < 10) {hours   = "0"+hours;}
            if (minutes < 10) {minutes = "0"+minutes;}
            if (seconds < 10) {seconds = "0"+seconds;}

            return [hours, minutes, seconds].join(":");
        },

        func: function(f){
            /* jshint -W054 */
            return new Function("a", f);
        },

        exec: function(f, args, context){
            var result;
            if (f === undefined || f === null) {return false;}
            var func = this.isFunc(f);

            if (func === false) {
                func = this.func(f);
            }

            try {
                result = func.apply(context, args);
            } catch (err) {
                result = null;
                if (window.METRO_THROWS === true) {
                    throw err;
                }
            }
            return result;
        },

        isOutsider: function(element) {
            var el = $(element);
            var inViewport;
            var clone = el.clone();

            clone.removeAttr("data-role").css({
                visibility: "hidden",
                position: "absolute",
                display: "block"
            });
            el.parent().append(clone);

            inViewport = this.inViewport(clone[0]);

            clone.remove();

            return !inViewport;
        },

        inViewport: function(el){
            var rect = this.rect(el);

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        },

        rect: function(el){
            return el.getBoundingClientRect();
        },

        getCursorPosition: function(el, e){
            var a = this.rect(el);
            return {
                x: this.pageXY(e).x - a.left - window.pageXOffset,
                y: this.pageXY(e).y - a.top - window.pageYOffset
            };
        },

        getCursorPositionX: function(el, e){
            return this.getCursorPosition(el, e).x;
        },

        getCursorPositionY: function(el, e){
            return this.getCursorPosition(el, e).y;
        },

        objectLength: function(obj){
            return Object.keys(obj).length;
        },

        percent: function(total, part, round_value){
            if (total === 0) {
                return 0;
            }
            var result = part * 100 / total;
            return round_value === true ? Math.round(result) : Math.round(result * 100) / 100;
        },

        objectShift: function(obj){
            var min = 0;
            $.each(obj, function(i){
                if (min === 0) {
                    min = i;
                } else {
                    if (min > i) {
                        min = i;
                    }
                }
            });
            delete obj[min];

            return obj;
        },

        objectDelete: function(obj, key){
            if (obj[key] !== undefined) delete obj[key];
        },

        arrayDeleteByMultipleKeys: function(arr, keys){
            keys.forEach(function(ind){
                delete arr[ind];
            });
            return arr.filter(function(item){
                return item !== undefined;
            });
        },

        arrayDelete: function(arr, val){
            if (arr.indexOf(val) > -1) arr.splice(arr.indexOf(val), 1);
        },

        arrayDeleteByKey: function(arr, key){
            arr.splice(key, 1);
        },

        nvl: function(data, other){
            return data === undefined || data === null ? other : data;
        },

        objectClone: function(obj){
            var copy = {};
            for(var key in obj) {
                if ($.hasProp(obj, key)) {
                    copy[key] = obj[key];
                }
            }
            return copy;
        },

        github: function(repo, callback){
            var that = this;
            $.json('https://api.github.com/repos/' + repo).then(function(data){
                that.exec(callback, [data]);
            });
        },

        detectIE: function() {
            var ua = window.navigator.userAgent;
            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },

        detectChrome: function(){
            return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        },

        encodeURI: function(str){
            return encodeURI(str).replace(/%5B/g, '[').replace(/%5D/g, ']');
        },

        pageHeight: function(){
            var body = document.body,
                html = document.documentElement;

            return Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight );
        },

        cleanPreCode: function(selector){
            var els = Array.prototype.slice.call(document.querySelectorAll(selector), 0);

            els.forEach(function(el){
                var txt = el.textContent
                    .replace(/^[\r\n]+/, "")	// strip leading newline
                    .replace(/\s+$/g, "");

                if (/^\S/gm.test(txt)) {
                    el.textContent = txt;
                    return;
                }

                var mat, str, re = /^[\t ]+/gm, len, min = 1e3;

                /* jshint -W084 */
                /* eslint-disable-next-line */
                while (mat = re.exec(txt)) {
                    len = mat[0].length;

                    if (len < min) {
                        min = len;
                        str = mat[0];
                    }
                }

                if (min === 1e3)
                    return;

                el.textContent = txt.replace(new RegExp("^" + str, 'gm'), "").trim();
            });
        },

        coords: function(element){
            var el = $(element)[0];
            var box = el.getBoundingClientRect();

            return {
                top: box.top + window.pageYOffset,
                left: box.left + window.pageXOffset
            };
        },

        positionXY: function(e, t){
            switch (t) {
                case 'client': return this.clientXY(e);
                case 'screen': return this.screenXY(e);
                case 'page': return this.pageXY(e);
                default: return {x: 0, y: 0};
            }
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        clientXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
                y: e.changedTouches ? e.changedTouches[0].clientY : e.clientY
            };
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        screenXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].screenX : e.screenX,
                y: e.changedTouches ? e.changedTouches[0].screenY : e.screenY
            };
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        pageXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].pageX : e.pageX,
                y: e.changedTouches ? e.changedTouches[0].pageY : e.pageY
            };
        },

        isRightMouse: function(e){
            return "which" in e ? e.which === 3 : "button" in e ? e.button === 2 : undefined;
        },

        hiddenElementSize: function(el, includeMargin){
            var width, height, clone = $(el).clone(true);

            clone.removeAttr("data-role").css({
                visibility: "hidden",
                position: "absolute",
                display: "block"
            });
            $("body").append(clone);

            if (!this.isValue(includeMargin)) {
                includeMargin = false;
            }

            width = clone.outerWidth(includeMargin);
            height = clone.outerHeight(includeMargin);
            clone.remove();
            return {
                width: width,
                height: height
            };
        },

        getStyle: function(element, pseudo){
            var el = $(element)[0];
            return window.getComputedStyle(el, pseudo);
        },

        getStyleOne: function(el, property){
            return this.getStyle(el).getPropertyValue(property);
        },

        getTransformMatrix: function(el, returnArray){
            var computedMatrix = this.getStyleOne(el, "transform");
            var a = computedMatrix
                .replace("matrix(", '')
                .slice(0, -1)
                .split(',');
            return returnArray !== true ? {
                a: a[0],
                b: a[1],
                c: a[2],
                d: a[3],
                tx: a[4],
                ty: a[5]
            } : a;
        },

        computedRgbToHex: function(rgb){
            var a = rgb.replace(/[^\d,]/g, '').split(',');
            var result = "#", i;

            for(i = 0; i < 3; i++) {
                var h = parseInt(a[i]).toString(16);
                result += h.length === 1 ? "0" + h : h;
            }

            return result;
        },

        computedRgbToRgba: function(rgb, alpha){
            var a = rgb.replace(/[^\d,]/g, '').split(',');
            if (alpha === undefined) {
                alpha = 1;
            }
            a.push(alpha);
            return "rgba("+a.join(",")+")";
        },

        computedRgbToArray: function(rgb){
            return rgb.replace(/[^\d,]/g, '').split(',');
        },

        hexColorToArray: function(hex){
            var c;
            if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length === 3){
                    c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c= '0x'+c.join('');
                return [(c>>16)&255, (c>>8)&255, c&255];
            }
            return [0,0,0];
        },

        hexColorToRgbA: function(hex, alpha){
            var c;
            if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length === 3){
                    c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c= '0x'+c.join('');
                return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255, alpha ? alpha : 1].join(',')+')';
            }
            return 'rgba(0,0,0,1)';
        },

        getInlineStyles: function(element){
            var i, l, styles = {}, el = $(element)[0];
            for (i = 0, l = el.style.length; i < l; i++) {
                var s = el.style[i];
                styles[s] = el.style[s];
            }

            return styles;
        },

        updateURIParameter: function(uri, key, value) {
            var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
            var separator = uri.indexOf('?') !== -1 ? "&" : "?";
            if (uri.match(re)) {
                return uri.replace(re, '$1' + key + "=" + value + '$2');
            }
            else {
                return uri + separator + key + "=" + value;
            }
        },

        getURIParameter: function(url, name){
            if (!url) url = window.location.href;
            /* eslint-disable-next-line */
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        },

        getLocales: function(){
            return Object.keys(Metro.locales);
        },

        addLocale: function(locale){
            Metro.locales = $.extend( {}, Metro.locales, locale );
        },

        aspectRatioH: function(width, a){
            if (a === "16/9") return width * 9 / 16;
            if (a === "21/9") return width * 9 / 21;
            if (a === "4/3") return width * 3 / 4;
        },

        aspectRatioW: function(height, a){
            if (a === "16/9") return height * 16 / 9;
            if (a === "21/9") return height * 21 / 9;
            if (a === "4/3") return height * 4 / 3;
        },

        valueInObject: function(obj, value){
            return Object.values(obj).indexOf(value) > -1;
        },

        keyInObject: function(obj, key){
            return Object.keys(obj).indexOf(key) > -1;
        },

        inObject: function(obj, key, val){
            return obj[key] !== undefined && obj[key] === val;
        },

        newCssSheet: function(media){
            var style = document.createElement("style");

            if (media !== undefined) {
                style.setAttribute("media", media);
            }

            style.appendChild(document.createTextNode(""));

            document.head.appendChild(style);

            return style.sheet;
        },

        addCssRule: function(sheet, selector, rules, index){
            if("insertRule" in sheet) {
                sheet.insertRule(selector + "{" + rules + "}", index);
            }
            else if("addRule" in sheet) {
                sheet.addRule(selector, rules, index);
            }
        },

        media: function(query){
            return window.matchMedia(query).matches;
        },

        mediaModes: function(){
            return window.METRO_MEDIA;
        },

        mediaExist: function(media){
            return window.METRO_MEDIA.indexOf(media) > -1;
        },

        inMedia: function(media){
            return window.METRO_MEDIA.indexOf(media) > -1 && window.METRO_MEDIA.indexOf(media) === window.METRO_MEDIA.length - 1;
        },

        isValue: function(val){
            return val !== undefined && val !== null && val !== "";
        },

        isNull: function(val){
            return val === undefined || val === null;
        },

        isNegative: function(val){
            return parseFloat(val) < 0;
        },

        isPositive: function(val){
            return parseFloat(val) > 0;
        },

        isZero: function(val){
            return (parseFloat(val.toFixed(2))) === 0.00;
        },

        between: function(val, bottom, top, equals){
            return equals === true ? val >= bottom && val <= top : val > bottom && val < top;
        },

        parseMoney: function(val){
            return Number(parseFloat(val.replace(/[^0-9-.]/g, '')));
        },

        parseCard: function(val){
            return val.replace(/[^0-9]/g, '');
        },

        parsePhone: function(val){
            return this.parseCard(val);
        },

        parseNumber: function(val, thousand, decimal){
            return val.replace(new RegExp('\\'+thousand, "g"), "").replace(new RegExp('\\'+decimal, 'g'), ".");
        },

        nearest: function(val, precision, down){
            val /= precision;
            val = Math[down === true ? 'floor' : 'ceil'](val) * precision;
            return val;
        },

        bool: function(value){
            switch(value){
                case true:
                case "true":
                case 1:
                case "1":
                case "on":
                case "yes":
                    return true;
                default:
                    return false;
            }
        },

        copy: function(element){
            var body = document.body, range, sel;
            var el = $(element)[0];

            if (document.createRange && window.getSelection) {
                range = document.createRange();
                sel = window.getSelection();
                sel.removeAllRanges();
                try {
                    range.selectNodeContents(el);
                    sel.addRange(range);
                } catch (e) {
                    range.selectNode(el);
                    sel.addRange(range);
                }
            } else if (body["createTextRange"]) {
                range = body["createTextRange"]();
                range["moveToElementText"](el);
                range.select();
            }

            document.execCommand("Copy");

            if (window.getSelection) {
                if (window.getSelection().empty) {  // Chrome
                    window.getSelection().empty();
                } else if (window.getSelection().removeAllRanges) {  // Firefox
                    window.getSelection().removeAllRanges();
                }
            } else if (document["selection"]) {  // IE?
                document["selection"].empty();
            }
        },

        decCount: function(v){
            return v % 1 === 0 ? 0 : v.toString().split(".")[1].length;
        },

        randomColor: function(){
            var r, g, b;

            r = $.random(0, 255);
            g = $.random(0, 255);
            b = $.random(0, 255);

            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Utils = Metro.utils;
    }
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var AnimationDefaultConfig = {
        duration: METRO_ANIMATION_DURATION,
        ease: "linear"
    }

    Metro.animations = {

        switchIn: function(el){
            $(el)
                .hide()
                .css({
                    left: 0,
                    top: 0
                })
                .show();
        },

        switchOut: function(el){
            $(el).hide();
        },

        switch: function(current, next){
            this.switchOut(current);
            this.switchIn(next);
        },

        slideUpIn: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    top: h,
                    left: 0,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        top: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideUpOut: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        top: -h,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideUp: function(current, next, o){
            this.slideUpOut(current, o);
            this.slideUpIn(next, o);
        },

        slideDownIn: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: 0,
                    top: -h,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        top: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideDownOut: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        top: h,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideDown: function(current, next, o){
            this.slideDownOut(current, o);
            this.slideDownIn(next, o);
        },

        slideLeftIn: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: w,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        left: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideLeftOut: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        left: -w,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideLeft: function(current, next, o){
            this.slideLeftOut(current, o);
            this.slideLeftIn(next, o);
        },

        slideRightIn: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: -w,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        left: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideRightOut: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        left:  w,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideRight: function(current, next, o){
            this.slideRightOut(current, o);
            this.slideRightIn(next, o);
        },

        fadeIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0
                })
                .animate({
                    draw: {
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        fadeOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .animate({
                    draw: {
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        fade: function(current, next, o){
            this.fadeOut(current, o);
            this.fadeIn(next, o);
        },

        zoomIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0,
                    transform: "scale(3)",
                    zIndex: 2
                })
                .animate({
                    draw: {
                        scale: 1,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        zoomOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        scale: 3,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        zoom: function(current, next, o){
            this.zoomOut(current, o);
            this.zoomIn(next, o);
        },

        swirlIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0,
                    transform: "scale(3) rotate(180deg)",
                    zIndex: 2
                })
                .animate({
                    draw: {
                        scale: 1,
                        rotate: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        swirlOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        scale: 3,
                        rotate: "180deg",
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        swirl: function(current, next, o){
            this.swirlOut(current, o);
            this.swirlIn(next, o);
        }
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Animations = Metro.animations;
    }
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Types = {
        HEX: "hex",
        HEXA: "hexa",
        RGB: "rgb",
        RGBA: "rgba",
        HSV: "hsv",
        HSL: "hsl",
        HSLA: "hsla",
        CMYK: "cmyk",
        UNKNOWN: "unknown"
    };

    Metro.colorsSetup = function (options) {
        ColorsDefaultConfig = $.extend({}, ColorsDefaultConfig, options);
    };

    if (typeof window["metroColorsSetup"] !== undefined) {
        Metro.colorsSetup(window["metroColorsSetup"]);
    }

    var ColorsDefaultConfig = {
        angle: 30,
        algorithm: 1,
        step: 0.1,
        distance: 5,
        tint1: 0.8,
        tint2: 0.4,
        shade1: 0.6,
        shade2: 0.3,
        alpha: 1
    };

    // function HEX(r, g, b) {
    //     this.r = r || "00";
    //     this.g = g || "00";
    //     this.b = b || "00";
    // }
    //
    // HEX.prototype.toString = function(){
    //     return "#" + [this.r, this.g, this.b].join("");
    // }

    function RGB(r, g, b){
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
    }

    RGB.prototype.toString = function(){
        return "rgb(" + [this.r, this.g, this.b].join(",") + ")";
    }

    function RGBA(r, g, b, a){
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
        this.a = typeof a !== "undefined" ? a ? a : 1 : 1;
    }

    RGBA.prototype.toString = function(){
        return "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")";
    }

    function HSV(h, s, v){
        this.h = h || 0;
        this.s = s || 0;
        this.v = v || 0;
    }

    HSV.prototype.toString = function(){
        return "hsv(" + [this.h, this.s, this.v].join(",") + ")";
    }

    function HSL(h, s, l){
        this.h = h || 0;
        this.s = s || 0;
        this.l = l || 0;
    }

    HSL.prototype.toString = function(){
        return "hsl(" + [this.h, this.s, this.l].join(",") + ")";
    }

    function HSLA(h, s, l, a){
        this.h = h || 0;
        this.s = s || 0;
        this.l = l || 0;
        this.a = typeof a !== "undefined" ? a ? a : 1 : 1;
    }

    HSLA.prototype.toString = function(){
        return "hsla(" + [this.h, this.s, this.l, this.a].join(",") + ")";
    }

    function CMYK(c, m, y, k){
        this.c = c || 0;
        this.m = m || 0;
        this.y = y || 0;
        this.k = k || 0;
    }

    CMYK.prototype.toString = function(){
        return "cmyk(" + [this.c, this.m, this.y, this.k].join(",") + ")";
    }

    var Colors = {

        PALETTES: {
            ALL: "all",
            METRO: "metro",
            STANDARD: "standard"
        },

        metro: {
            lime: '#a4c400',
            green: '#60a917',
            emerald: '#008a00',
            blue: '#00AFF0',
            teal: '#00aba9',
            cyan: '#1ba1e2',
            cobalt: '#0050ef',
            indigo: '#6a00ff',
            violet: '#aa00ff',
            pink: '#dc4fad',
            magenta: '#d80073',
            crimson: '#a20025',
            red: '#CE352C',
            orange: '#fa6800',
            amber: '#f0a30a',
            yellow: '#fff000',
            brown: '#825a2c',
            olive: '#6d8764',
            steel: '#647687',
            mauve: '#76608a',
            taupe: '#87794e'
        },

        standard: {
            aliceBlue: "#f0f8ff",
            antiqueWhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedAlmond: "#ffebcd",
            blue: "#0000ff",
            blueViolet: "#8a2be2",
            brown: "#a52a2a",
            burlyWood: "#deb887",
            cadetBlue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerBlue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkBlue: "#00008b",
            darkCyan: "#008b8b",
            darkGoldenRod: "#b8860b",
            darkGray: "#a9a9a9",
            darkGreen: "#006400",
            darkKhaki: "#bdb76b",
            darkMagenta: "#8b008b",
            darkOliveGreen: "#556b2f",
            darkOrange: "#ff8c00",
            darkOrchid: "#9932cc",
            darkRed: "#8b0000",
            darkSalmon: "#e9967a",
            darkSeaGreen: "#8fbc8f",
            darkSlateBlue: "#483d8b",
            darkSlateGray: "#2f4f4f",
            darkTurquoise: "#00ced1",
            darkViolet: "#9400d3",
            deepPink: "#ff1493",
            deepSkyBlue: "#00bfff",
            dimGray: "#696969",
            dodgerBlue: "#1e90ff",
            fireBrick: "#b22222",
            floralWhite: "#fffaf0",
            forestGreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#DCDCDC",
            ghostWhite: "#F8F8FF",
            gold: "#ffd700",
            goldenRod: "#daa520",
            gray: "#808080",
            green: "#008000",
            greenYellow: "#adff2f",
            honeyDew: "#f0fff0",
            hotPink: "#ff69b4",
            indianRed: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavender: "#e6e6fa",
            lavenderBlush: "#fff0f5",
            lawnGreen: "#7cfc00",
            lemonChiffon: "#fffacd",
            lightBlue: "#add8e6",
            lightCoral: "#f08080",
            lightCyan: "#e0ffff",
            lightGoldenRodYellow: "#fafad2",
            lightGray: "#d3d3d3",
            lightGreen: "#90ee90",
            lightPink: "#ffb6c1",
            lightSalmon: "#ffa07a",
            lightSeaGreen: "#20b2aa",
            lightSkyBlue: "#87cefa",
            lightSlateGray: "#778899",
            lightSteelBlue: "#b0c4de",
            lightYellow: "#ffffe0",
            lime: "#00ff00",
            limeGreen: "#32dc32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumAquaMarine: "#66cdaa",
            mediumBlue: "#0000cd",
            mediumOrchid: "#ba55d3",
            mediumPurple: "#9370db",
            mediumSeaGreen: "#3cb371",
            mediumSlateBlue: "#7b68ee",
            mediumSpringGreen: "#00fa9a",
            mediumTurquoise: "#48d1cc",
            mediumVioletRed: "#c71585",
            midnightBlue: "#191970",
            mintCream: "#f5fffa",
            mistyRose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajoWhite: "#ffdead",
            navy: "#000080",
            oldLace: "#fdd5e6",
            olive: "#808000",
            oliveDrab: "#6b8e23",
            orange: "#ffa500",
            orangeRed: "#ff4500",
            orchid: "#da70d6",
            paleGoldenRod: "#eee8aa",
            paleGreen: "#98fb98",
            paleTurquoise: "#afeeee",
            paleVioletRed: "#db7093",
            papayaWhip: "#ffefd5",
            peachPuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderBlue: "#b0e0e6",
            purple: "#800080",
            rebeccaPurple: "#663399",
            red: "#ff0000",
            rosyBrown: "#bc8f8f",
            royalBlue: "#4169e1",
            saddleBrown: "#8b4513",
            salmon: "#fa8072",
            sandyBrown: "#f4a460",
            seaGreen: "#2e8b57",
            seaShell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            slyBlue: "#87ceeb",
            slateBlue: "#6a5acd",
            slateGray: "#708090",
            snow: "#fffafa",
            springGreen: "#00ff7f",
            steelBlue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whiteSmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowGreen: "#9acd32"
        },

        all: {},

        init: function(){
            this.all = $.extend( {}, this.standard, this.metro );
            return this;
        },

        color: function(name, palette){
            palette = palette || this.PALETTES.ALL;
            return this[palette][name] !== undefined ? this[palette][name] : false;
        },

        palette: function(palette){
            palette = palette || this.PALETTES.ALL;
            return Object.keys(this[palette]);
        },

        expandHexColor: function(hex){
            if (typeof hex !== "string") {
                throw new Error("Value is not a string!");
            }
            if (hex[0] === "#" && hex.length === 4) {
                var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                return (
                    "#" +
                    hex.replace(shorthandRegex, function(m, r, g, b) {
                        return r + r + g + g + b + b;
                    })
                );
            }
            return hex[0] === "#" ? hex : "#" + hex;
        },

        colors: function(palette){
            palette = palette || this.PALETTES.ALL;
            return Object.values(this[palette]);
        },

        random: function(colorType, alpha){
            colorType = colorType || Types.HEX;
            alpha = typeof alpha !== "undefined" ? alpha : 1;

            var hex, r, g, b;

            r = $.random(0, 255);
            g = $.random(0, 255);
            b = $.random(0, 255);

            hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);

            return colorType === "hex" ? hex : this.toColor(hex, colorType, alpha);
        },

        parse: function(color){
            var _color = color.toLowerCase();

            var a = _color
                .replace(/[^\d.,]/g, "")
                .split(",")
                .map(function(v) {
                    return v.indexOf(".") > -1 ? parseFloat(v) : parseInt(v);
                });

            if (_color[0] === "#") {
                return this.expandHexColor(_color);
            }

            if (_color.indexOf("rgba") > -1) {
                return new RGBA(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("rgb") > -1) {
                return new RGB(a[0], a[1], a[2]);
            }
            if (_color.indexOf("cmyk") > -1) {
                return new CMYK(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("hsv") > -1) {
                return new HSV(a[0], a[1], a[2]);
            }
            if (_color.indexOf("hsla") > -1) {
                return new HSLA(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("hsl") > -1) {
                return new HSL(a[0], a[1], a[2]);
            }
            return _color;
        },

        createColor: function(colorType, from){
            colorType = colorType || "hex";
            from = from || "#000000";

            var baseColor;

            if (typeof from === "string") {
                baseColor = this.parse(from);
            }

            if (!this.isColor(baseColor)) {
                baseColor = "#000000";
            }

            return this.toColor(baseColor, colorType.toLowerCase());
        },

        isDark: function(color){
            if (!this.isColor(color)) return;
            var rgb = this.toRGB(color);
            var YIQ = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            return YIQ < 128;
        },

        isLight: function(color){
            return !this.isDark(color);
        },

        isHSV: function(color){
            return color instanceof HSV;
        },

        isHSL: function(color){
            return color instanceof HSL;
        },

        isHSLA: function(color){
            return color instanceof HSLA;
        },

        isRGB: function(color){
            return color instanceof RGB;
        },

        isRGBA: function(color){
            return color instanceof RGBA;
        },

        isCMYK: function(color){
            return color instanceof CMYK;
        },

        isHEX: function(color){
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
        },

        isColor: function(color){
            return !color
                ? false
                : this.isHEX(color) ||
                  this.isRGB(color) ||
                  this.isRGBA(color) ||
                  this.isHSV(color) ||
                  this.isHSL(color) ||
                  this.isHSLA(color) ||
                  this.isCMYK(color);
        },

        check: function(color, type){
            if (!this["is"+type.toUpperCase()](color)) {
                throw new Error("Value is not a " + type + " color type!");
            }
        },

        colorType: function(color){
            if (this.isHEX(color)) return Types.HEX;
            if (this.isRGB(color)) return Types.RGB;
            if (this.isRGBA(color)) return Types.RGBA;
            if (this.isHSV(color)) return Types.HSV;
            if (this.isHSL(color)) return Types.HSL;
            if (this.isHSLA(color)) return Types.HSLA;
            if (this.isCMYK(color)) return Types.CMYK;

            return Types.UNKNOWN;
        },

        equal: function(color1, color2){
            if (!this.isColor(color1) || !this.isColor(color2)) {
                return false;
            }

            return this.toHEX(color1) === this.toHEX(color2);
        },

        colorToString: function(color){
            return color.toString();
        },

        hex2rgb: function(color){
            if (typeof color !== "string") {
                throw new Error("Value is not a string!")
            }
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                this.expandHexColor(color)
            );
            var rgb = [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ];
            return result ? new RGB(rgb[0], rgb[1], rgb[2]) : null;
        },

        rgb2hex: function(color){
            this.check(color, "rgb");
            return (
                "#" +
                ((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).slice(1)
            );
        },

        rgb2hsv: function(color){
            this.check(color, "rgb");
            var hsv = new HSV();
            var h, s, v;
            var r = color.r / 255,
                g = color.g / 255,
                b = color.b / 255;

            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var delta = max - min;

            v = max;

            if (max === 0) {
                s = 0;
            } else {
                s = 1 - min / max;
            }

            if (max === min) {
                h = 0;
            } else if (max === r && g >= b) {
                h = 60 * ((g - b) / delta);
            } else if (max === r && g < b) {
                h = 60 * ((g - b) / delta) + 360;
            } else if (max === g) {
                h = 60 * ((b - r) / delta) + 120;
            } else if (max === b) {
                h = 60 * ((r - g) / delta) + 240;
            } else {
                h = 0;
            }

            hsv.h = h;
            hsv.s = s;
            hsv.v = v;

            return hsv;
        },

        hsv2rgb: function(color){
            this.check(color, "hsv");
            var r, g, b;
            var h = color.h,
                s = color.s * 100,
                v = color.v * 100;
            var Hi = Math.floor(h / 60);
            var Vmin = ((100 - s) * v) / 100;
            var alpha = (v - Vmin) * ((h % 60) / 60);
            var Vinc = Vmin + alpha;
            var Vdec = v - alpha;

            switch (Hi) {
                case 0:
                    r = v;
                    g = Vinc;
                    b = Vmin;
                    break;
                case 1:
                    r = Vdec;
                    g = v;
                    b = Vmin;
                    break;
                case 2:
                    r = Vmin;
                    g = v;
                    b = Vinc;
                    break;
                case 3:
                    r = Vmin;
                    g = Vdec;
                    b = v;
                    break;
                case 4:
                    r = Vinc;
                    g = Vmin;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = Vmin;
                    b = Vdec;
                    break;
            }

            return new RGB(
                Math.round((r * 255) / 100),
                Math.round((g * 255) / 100),
                Math.round((b * 255) / 100)
            );
        },

        hsv2hex: function(color){
            this.check(color, "hsv");
            return this.rgb2hex(this.hsv2rgb(color));
        },

        hex2hsv: function(color){
            this.check(color, "hex");
            return this.rgb2hsv(this.hex2rgb(color));
        },

        rgb2cmyk: function(color){
            this.check(color, "rgb");
            var cmyk = new CMYK();

            var r = color.r / 255;
            var g = color.g / 255;
            var b = color.b / 255;

            cmyk.k = Math.min(1 - r, 1 - g, 1 - b);

            cmyk.c = 1 - cmyk.k === 0 ? 0 : (1 - r - cmyk.k) / (1 - cmyk.k);
            cmyk.m = 1 - cmyk.k === 0 ? 0 : (1 - g - cmyk.k) / (1 - cmyk.k);
            cmyk.y = 1 - cmyk.k === 0 ? 0 : (1 - b - cmyk.k) / (1 - cmyk.k);

            cmyk.c = Math.round(cmyk.c * 100);
            cmyk.m = Math.round(cmyk.m * 100);
            cmyk.y = Math.round(cmyk.y * 100);
            cmyk.k = Math.round(cmyk.k * 100);

            return cmyk;
        },

        cmyk2rgb: function(color){
            this.check(color, "cmyk");
            var r = Math.floor(255 * (1 - color.c / 100) * (1 - color.k / 100));
            var g = Math.ceil(255 * (1 - color.m / 100) * (1 - color.k / 100));
            var b = Math.ceil(255 * (1 - color.y / 100) * (1 - color.k / 100));

            return new RGB(r, g, b);
        },

        hsv2hsl: function(color){
            this.check(color, "hsv");
            var h, s, l, d;
            h = color.h;
            l = (2 - color.s) * color.v;
            s = color.s * color.v;
            if (l === 0) {
                s = 0;
            } else {
                d = l <= 1 ? l : 2 - l;
                if (d === 0) {
                    s = 0;
                } else {
                    s /= d;
                }
            }
            l /= 2;
            return new HSL(h, s, l);
        },

        hsl2hsv: function(color){
            this.check(color, "hsl");
            var h, s, v, l;
            h = color.h;
            l = color.l * 2;
            s = color.s * (l <= 1 ? l : 2 - l);

            v = (l + s) / 2;

            if (l + s === 0) {
                s = 0;
            } else {
                s = (2 * s) / (l + s);
            }

            return new HSV(h, s, v);
        },

        rgb2websafe: function(color){
            this.check(color, "rgb");
            return new RGB(
                Math.round(color.r / 51) * 51,
                Math.round(color.g / 51) * 51,
                Math.round(color.b / 51) * 51
            );
        },

        rgba2websafe: function(color){
            this.check(color, "rgba");
            var rgbWebSafe = this.rgb2websafe(color);
            return new RGBA(rgbWebSafe.r, rgbWebSafe.g, rgbWebSafe.b, color.a);
        },

        hex2websafe: function(color){
            this.check(color, "hex");
            return this.rgb2hex(this.rgb2websafe(this.hex2rgb(color)));
        },

        hsv2websafe: function(color){
            this.check(color, "hsv");
            return this.rgb2hsv(this.rgb2websafe(this.toRGB(color)));
        },

        hsl2websafe: function(color){
           this.check(color, "hsl");
            return this.hsv2hsl(this.rgb2hsv(this.rgb2websafe(this.toRGB(color))));
        },

        cmyk2websafe: function(color){
            this.check(color, "cmyk");
            return this.rgb2cmyk(this.rgb2websafe(this.cmyk2rgb(color)));
        },

        websafe: function(color){
            if (this.isHEX(color)) return this.hex2websafe(color);
            if (this.isRGB(color)) return this.rgb2websafe(color);
            if (this.isRGBA(color)) return this.rgba2websafe(color);
            if (this.isHSV(color)) return this.hsv2websafe(color);
            if (this.isHSL(color)) return this.hsl2websafe(color);
            if (this.isCMYK(color)) return this.cmyk2websafe(color);

            return color;
        },

        toColor: function(color, type, alpha){
            var result;
            switch (type.toLowerCase()) {
                case "hex":
                    result = this.toHEX(color);
                    break;
                case "rgb":
                    result = this.toRGB(color);
                    break;
                case "rgba":
                    result = this.toRGBA(color, alpha);
                    break;
                case "hsl":
                    result = this.toHSL(color);
                    break;
                case "hsla":
                    result = this.toHSLA(color, alpha);
                    break;
                case "hsv":
                    result = this.toHSV(color);
                    break;
                case "cmyk":
                    result = this.toCMYK(color);
                    break;
                default:
                    result = color;
            }
            return result;
        },

        toHEX: function(color){
            return typeof color === "string"
                ? this.expandHexColor(color)
                : this.rgb2hex(this.toRGB(color));
        },

        toRGB: function(color){
            if (this.isRGB(color)) return color;
            if (this.isRGBA(color)) return new RGB(color.r, color.g, color.b);
            if (this.isHSV(color)) return this.hsv2rgb(color);
            if (this.isHSL(color)) return this.hsv2rgb(this.hsl2hsv(color));
            if (this.isHSLA(color)) return this.hsv2rgb(this.hsl2hsv(color));
            if (this.isHEX(color)) return this.hex2rgb(color);
            if (this.isCMYK(color)) return this.cmyk2rgb(color);

            throw new Error("Unknown color format!");
        },

        toRGBA: function(color, alpha){
            if (this.isRGBA(color)) {
                if (alpha) {
                    color.a = alpha;
                }
                return color;
            }
            var rgb = this.toRGB(color);
            return new RGBA(rgb.r, rgb.g, rgb.b, alpha);
        },

        toHSV: function(color){
            return this.rgb2hsv(this.toRGB(color));
        },

        toHSL: function(color){
            return this.hsv2hsl(this.rgb2hsv(this.toRGB(color)));
        },

        toHSLA: function(color, alpha){
            if (this.isHSLA(color)) {
                if (alpha) {
                    color.a = alpha;
                }
                return color;
            }
            var hsla = this.hsv2hsl(this.rgb2hsv(this.toRGB(color)));
            hsla.a = alpha;
            return new HSLA(hsla.h, hsla.s, hsla.l, hsla.a);
        },

        toCMYK: function(color){
            return this.rgb2cmyk(this.toRGB(color));
        },

        grayscale: function(color){
            var rgb = this.toRGB(color);
            var type = this.colorType(color).toLowerCase();
            var gray = Math.round(rgb.r * 0.2125 + rgb.g * 0.7154 + rgb.b * 0.0721);
            var mono = new RGB(gray, gray, gray);

            return this.toColor(mono, type);
        },

        darken: function(color, amount){
            amount = amount || 10;
            return this.lighten(color, -1 * Math.abs(amount));
        },

        lighten: function(color, amount){
            var type, res, alpha, ring;

            amount = amount || 10;

            var calc = function (_color, _amount) {
                var r, g, b;
                var col = _color.slice(1);

                var num = parseInt(col, 16);
                r = (num >> 16) + _amount;

                if (r > 255) r = 255;
                else if (r < 0) r = 0;

                b = ((num >> 8) & 0x00ff) + _amount;

                if (b > 255) b = 255;
                else if (b < 0) b = 0;

                g = (num & 0x0000ff) + _amount;

                if (g > 255) g = 255;
                else if (g < 0) g = 0;

                return "#" + (g | (b << 8) | (r << 16)).toString(16);
            };

            ring = amount > 0;

            type = this.colorType(color).toLowerCase();

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            do {
                res = calc(this.toHEX(color), amount);
                ring ? amount-- : amount++;
            } while (res.length < 7);

            return this.toColor(res, type, alpha);
        },

        hueShift: function(color, hue, saturation, value){
            var hsv = this.toHSV(color);
            var type = this.colorType(color).toLowerCase();
            var h = hsv.h;
            var alpha;
            var _h = hue || 0;
            var _s = saturation || 0;
            var _v = value || 0;

            h += _h;
            while (h >= 360.0) h -= 360.0;
            while (h < 0.0) h += 360.0;
            hsv.h = h;

            hsv.s += _s;
            if (hsv.s > 1) {hsv.s = 1;}
            if (hsv.s < 0) {hsv.s = 0;}

            hsv.v += _v;
            if (hsv.v > 1) {hsv.v = 1;}
            if (hsv.v < 0) {hsv.v = 0;}

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(hsv, type, alpha);
        },

        createScheme: function(color, name, format, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var i, scheme = [], hsv, rgb, h, s, v;
            var self = this;

            hsv = this.toHSV(color);
            h = hsv.h;
            s = hsv.s;
            v = hsv.v;

            if (this.isHSV(hsv) === false) {
                console.warn("The value is a not supported color format!");
                return false;
            }

            function convert(source, format) {
                var result;
                switch (format) {
                    case "hex":
                        result = source.map(function (v) {
                            return self.toHEX(v);
                        });
                        break;
                    case "rgb":
                        result = source.map(function (v) {
                            return self.toRGB(v);
                        });
                        break;
                    case "rgba":
                        result = source.map(function (v) {
                            return self.toRGBA(v, opt.alpha);
                        });
                        break;
                    case "hsl":
                        result = source.map(function (v) {
                            return self.toHSL(v);
                        });
                        break;
                    case "hsla":
                        result = source.map(function (v) {
                            return self.toHSLA(v, opt.alpha);
                        });
                        break;
                    case "cmyk":
                        result = source.map(function (v) {
                            return self.toCMYK(v);
                        });
                        break;
                    default:
                        result = source;
                }

                return result;
            }

            function clamp(num, min, max) {
                return Math.max(min, Math.min(num, max));
            }

            function toRange(a, b, c) {
                return a < b ? b : a > c ? c : a;
            }

            function shift(h, s) {
                h += s;
                while (h >= 360.0) h -= 360.0;
                while (h < 0.0) h += 360.0;
                return h;
            }

            switch (name) {
                case "monochromatic":
                case "mono":
                    if (opt.algorithm === 1) {
                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(
                            Math.round(rgb.r + (255 - rgb.r) * opt.tint1),
                            0,
                            255
                        );
                        rgb.g = toRange(
                            Math.round(rgb.g + (255 - rgb.g) * opt.tint1),
                            0,
                            255
                        );
                        rgb.b = toRange(
                            Math.round(rgb.b + (255 - rgb.b) * opt.tint1),
                            0,
                            255
                        );
                        scheme.push(this.rgb2hsv(rgb));

                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(
                            Math.round(rgb.r + (255 - rgb.r) * opt.tint2),
                            0,
                            255
                        );
                        rgb.g = toRange(
                            Math.round(rgb.g + (255 - rgb.g) * opt.tint2),
                            0,
                            255
                        );
                        rgb.b = toRange(
                            Math.round(rgb.b + (255 - rgb.b) * opt.tint2),
                            0,
                            255
                        );
                        scheme.push(this.rgb2hsv(rgb));

                        scheme.push(hsv);

                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(Math.round(rgb.r * opt.shade1), 0, 255);
                        rgb.g = toRange(Math.round(rgb.g * opt.shade1), 0, 255);
                        rgb.b = toRange(Math.round(rgb.b * opt.shade1), 0, 255);
                        scheme.push(this.rgb2hsv(rgb));

                        rgb = this.hsv2rgb(hsv);
                        rgb.r = toRange(Math.round(rgb.r * opt.shade2), 0, 255);
                        rgb.g = toRange(Math.round(rgb.g * opt.shade2), 0, 255);
                        rgb.b = toRange(Math.round(rgb.b * opt.shade2), 0, 255);
                        scheme.push(this.rgb2hsv(rgb));

                    } else if (opt.algorithm === 2) {

                        scheme.push(hsv);
                        for (i = 1; i <= opt.distance; i++) {
                            v = clamp(v - opt.step, 0, 1);
                            s = clamp(s - opt.step, 0, 1);
                            scheme.push(new HSV(h, s, v));
                        }

                    } else if (opt.algorithm === 3) {

                        scheme.push(hsv);
                        for (i = 1; i <= opt.distance; i++) {
                            v = clamp(v - opt.step, 0, 1);
                            scheme.push(new HSV(h, s, v));
                        }

                    } else {

                        v = clamp(hsv.v + opt.step * 2, 0, 1);
                        scheme.push(new HSV(h, s, v));

                        v = clamp(hsv.v + opt.step, 0, 1);
                        scheme.push(new HSV(h, s, v));

                        scheme.push(hsv);
                        s = hsv.s;
                        v = hsv.v;

                        v = clamp(hsv.v - opt.step, 0, 1);
                        scheme.push(new HSV(h, s, v));

                        v = clamp(hsv.v - opt.step * 2, 0, 1);
                        scheme.push(new HSV(h, s, v));

                    }
                    break;

                case "complementary":
                case "complement":
                case "comp":
                    scheme.push(hsv);

                    h = shift(hsv.h, 180.0);
                    scheme.push(new HSV(h, s, v));
                    break;

                case "double-complementary":
                case "double-complement":
                case "double":
                    scheme.push(hsv);

                    h = shift(h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    h = shift(h, opt.angle);
                    scheme.push(new HSV(h, s, v));

                    h = shift(h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    break;

                case "analogous":
                case "analog":
                    h = shift(h, opt.angle);
                    scheme.push(new HSV(h, s, v));

                    scheme.push(hsv);

                    h = shift(hsv.h, 0.0 - opt.angle);
                    scheme.push(new HSV(h, s, v));

                    break;

                case "triadic":
                case "triad":
                    scheme.push(hsv);
                    for (i = 1; i < 3; i++) {
                        h = shift(h, 120.0);
                        scheme.push(new HSV(h, s, v));
                    }
                    break;

                case "tetradic":
                case "tetra":
                    scheme.push(hsv);

                    h = shift(hsv.h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    h = shift(hsv.h, -1 * opt.angle);
                    scheme.push(new HSV(h, s, v));

                    h = shift(h, 180.0);
                    scheme.push(new HSV(h, s, v));

                    break;

                case "square":
                    scheme.push(hsv);
                    for (i = 1; i < 4; i++) {
                        h = shift(h, 90.0);
                        scheme.push(new HSV(h, s, v));
                    }
                    break;

                case "split-complementary":
                case "split-complement":
                case "split":
                    h = shift(h, 180.0 - opt.angle);
                    scheme.push(new HSV(h, s, v));

                    scheme.push(hsv);

                    h = shift(hsv.h, 180.0 + opt.angle);
                    scheme.push(new HSV(h, s, v));
                    break;

                default:
                    console.warn("Unknown scheme name");
            }

            return convert(scheme, format);
        },

        getScheme: function(){
            return this.createScheme.apply(this, arguments)
        },

        mix: function(color1, color2, returnAs){
            var c1 = this.toRGBA(color1);
            var c2 = this.toRGBA(color2);
            var result = new RGBA();
            var to = (""+returnAs).toLowerCase() || "hex";

            result.r = Math.round((c1.r + c2.r) / 2);
            result.g = Math.round((c1.g + c2.g) / 2);
            result.b = Math.round((c1.b + c2.b) / 2);
            result.a = Math.round((c1.a + c2.a) / 2);

            return this["to"+to.toUpperCase()](result);
        }
    };

    var Color = function(color, options){
        this._setValue(color);
        this._setOptions(options);
    }

    Color.prototype = {
        _setValue: function(color){
            var _color;

            if (typeof color === "string") {
                _color = Colors.parse(color);
            } else {
                _color = color;
            }

            if (!Colors.isColor(_color)) {
                _color = "#000000";
            }

            this._value = _color;
            this._type = Colors.colorType(this._value);
        },

        _setOptions: function(options){
            options = typeof options === "object" ? options : {};
            this._options = $.extend({}, ColorsDefaultConfig, options);
        },

        getOptions: function(){
            return this._options;
        },

        setOptions: function(options){
            this._setOptions(options);
        },

        setValue: function(color){
            this._setValue(color);
        },

        getValue: function(){
            return this._value;
        },

        channel: function(ch, val){
            var currentType = this._type.toUpperCase();

            if (["red", "green", "blue"].indexOf(ch) > -1) {
                this.toRGB();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (ch === "alpha" && this._value.a) {
                this._value.a = val;
            }
            if (["hue", "saturation", "value"].indexOf(ch) > -1) {
                this.toHSV();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (["lightness"].indexOf(ch) > -1) {
                this.toHSL();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (["cyan", "magenta", "yellow", "black"].indexOf(ch) > -1) {
                this.toCMYK();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }

            return this;
        },

        channels: function(obj){
            var that = this;

            $.each(obj, function(key, val){
                that.channel(key, val);
            });

            return this;
        },

        toRGB: function() {
            this._value = Colors.toRGB(this._value);
            this._type = Types.RGB;
            return this;
        },

        rgb: function(){
            return this._value ? new Color(Colors.toRGB(this._value)) : undefined;
        },

        toRGBA: function(alpha) {
            if (Colors.isRGBA(this._value)) {
                if (alpha) {
                    this._value = Colors.toRGBA(this._value, alpha);
                }
            } else {
                this._value = Colors.toRGBA(this._value, alpha);
            }
            this._type = Types.RGBA;
            return this;
        },

        rgba: function(alpha) {
            return this._value ? new Color(Colors.toRGBA(this._value, alpha)) : undefined;
        },

        toHEX: function() {
            this._value = Colors.toHEX(this._value);
            this._type = Types.HEX;
            return this;
        },

        hex: function() {
            return this._value ? new Color(Colors.toHEX(this._value)) : undefined;
        },

        toHSV: function() {
            this._value = Colors.toHSV(this._value);
            this._type = Types.HSV;
            return this;
        },

        hsv: function() {
            return this._value ? new Color(Colors.toHSV(this._value)) : undefined;
        },

        toHSL: function() {
            this._value = Colors.toHSL(this._value);
            this._type = Types.HSL;
            return this;
        },

        hsl: function() {
            return this._value ? new Color(Colors.toHSL(this._value)) : undefined;
        },

        toHSLA: function(alpha) {
            if (Colors.isHSLA(this._value)) {
                if (alpha) {
                    this._value = Colors.toHSLA(this._value, alpha);
                }
            } else {
                this._value = Colors.toHSLA(this._value, alpha);
            }
            this._type = Types.HSLA;
            return this;
        },

        hsla: function(alpha) {
            return this._value ? new Color(Colors.toHSLA(this._value, alpha)) : undefined;
        },

        toCMYK: function() {
            this._value = Colors.toCMYK(this._value);
            this._type = Types.CMYK;
            return this;
        },

        cmyk: function() {
            return this._value ? new Color(Colors.toCMYK(this._value)) : undefined;
        },

        toWebsafe: function() {
            this._value = Colors.websafe(this._value);
            this._type = Colors.colorType(this._value);
            return this;
        },

        websafe: function() {
            return this._value ? new Color(Colors.websafe(this._value)) : undefined;
        },

        toString: function() {
            return this._value ? Colors.colorToString(this._value) : "undefined";
        },

        toDarken: function(amount) {
            this._value = Colors.darken(this._value, amount);
            return this;
        },

        darken: function(amount){
            return new Color(Colors.darken(this._value, amount));
        },

        toLighten: function(amount) {
            this._value = Colors.lighten(this._value, amount);
            return this;
        },

        lighten: function(amount){
            return new Color(Colors.lighten(this._value, amount))
        },

        isDark: function() {
            return this._value ? Colors.isDark(this._value) : undefined;
        },

        isLight: function() {
            return this._value ? Colors.isLight(this._value) : undefined;
        },

        toHueShift: function(hue, saturation, value) {
            this._value = Colors.hueShift(this._value, hue, saturation, value);
            return this;
        },

        hueShift: function (hue, saturation, value) {
            return new Color(Colors.hueShift(this._value, hue, saturation, value));
        },

        toGrayscale: function() {
            this._value = Colors.grayscale(this._value, this._type);
            return this;
        },

        grayscale: function(){
            return new Color(Colors.grayscale(this._value, this._type));
        },

        type: function() {
            return Colors.colorType(this._value);
        },

        createScheme: function(name, format, options) {
            return this._value
                ? Colors.createScheme(this._value, name, format, options)
                : undefined;
        },

        getScheme: function(){
            return this.createScheme.apply(this, arguments);
        },

        equal: function(color) {
            return Colors.equal(this._value, color);
        },

        toMix: function(color){
            this._value = Colors.mix(this._value, color, this._type);
            return this;
        },

        mix: function(color){
            return new Color(Colors.mix(this._value, color, this._type));
        }
    }

    Metro.colors = Colors.init();
    window.Color = Metro.Color = Color;
    window.ColorPrimitive = Metro.colorPrimitive = {
        RGB: RGB,
        RGBA: RGBA,
        HSV: HSV,
        HSL: HSL,
        HSLA: HSLA,
        CMYK: CMYK
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Colors = Metro.colors;
    }

}(Metro, m4q));

(function (Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Export = {

        init: function () {
            return this;
        },

        options: {
            csvDelimiter: "\t",
            csvNewLine: "\r\n",
            includeHeader: true
        },

        setup: function (options) {
            this.options = $.extend({}, this.options, options);
            return this;
        },

        base64: function (data) {
            return window.btoa(unescape(encodeURIComponent(data)));
        },

        b64toBlob: function (b64Data, contentType, sliceSize) {
            contentType = contentType || '';
            sliceSize = sliceSize || 512;

            var byteCharacters = window.atob(b64Data);
            var byteArrays = [];

            var offset;
            for (offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                var slice = byteCharacters.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                var i;
                for (i = 0; i < slice.length; i = i + 1) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new window.Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, {
                type: contentType
            });
        },

        tableToCSV: function (table, filename, options) {
            var o;
            var body, head, data = "";
            var i, j, row, cell;

            o = $.extend({}, this.options, options);

            table = $(table)[0];

            if (Utils.bool(o.includeHeader)) {

                head = table.querySelectorAll("thead")[0];

                for (i = 0; i < head.rows.length; i++) {
                    row = head.rows[i];
                    for (j = 0; j < row.cells.length; j++) {
                        cell = row.cells[j];
                        data += (j ? o.csvDelimiter : '') + cell.textContent.trim();
                    }
                    data += o.csvNewLine;
                }
            }

            body = table.querySelectorAll("tbody")[0];

            for (i = 0; i < body.rows.length; i++) {
                row = body.rows[i];
                for (j = 0; j < row.cells.length; j++) {
                    cell = row.cells[j];
                    data += (j ? o.csvDelimiter : '') + cell.textContent.trim();
                }
                data += o.csvNewLine;
            }

            if (Utils.isValue(filename)) {
                return this.createDownload(this.base64("\uFEFF" + data), 'application/csv', filename);
            }

            return data;
        },

        createDownload: function (data, contentType, filename) {
            var blob, anchor, url;

            anchor = document.createElement('a');
            anchor.style.display = "none";
            document.body.appendChild(anchor);

            blob = this.b64toBlob(data, contentType);

            url = window.URL.createObjectURL(blob);
            anchor.href = url;
            anchor.download = filename || Utils.elementId("download");
            anchor.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(anchor);
            return true;
        },

        arrayToCsv: function(array, filename, options){
            var o, data = "", i, row;

            o = $.extend({}, this.options, options);

            for (i = 0; i < array.length; i++) {
                row = array[i];

                if (typeof row !== "object") {
                    data += row + o.csvNewLine;
                } else {
                    $.each(row, function(key, val){
                        data += (key ? o.csvDelimiter : '') + val.toString();
                    });
                    data += o.csvNewLine;
                }
            }

            if (Utils.isValue(filename)) {
                return this.createDownload(this.base64("\uFEFF" + data), 'application/csv', filename);
            }

            return data;
        }
    };

    Metro.export = Export.init();

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Export = Metro.export;
    }
}(Metro, m4q));

(function(Metro) {
    'use strict';
    Metro.md5 = function (string) {
        function RotateLeft(lValue, iShiftBits) {
            return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
        }

        function AddUnsigned(lX,lY) {
            var lX4,lY4,lX8,lY8,lResult;
            lX8 = (lX & 0x80000000);
            lY8 = (lY & 0x80000000);
            lX4 = (lX & 0x40000000);
            lY4 = (lY & 0x40000000);
            lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
            if (lX4 & lY4) {
                return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
            }
            if (lX4 | lY4) {
                if (lResult & 0x40000000) {
                    return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                } else {
                    return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                }
            } else {
                return (lResult ^ lX8 ^ lY8);
            }
        }

        function F(x,y,z) { return (x & y) | ((~x) & z); }
        function G(x,y,z) { return (x & z) | (y & (~z)); }
        function H(x,y,z) { return (x ^ y ^ z); }
        function I(x,y,z) { return (y ^ (x | (~z))); }

        function FF(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function GG(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function HH(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function II(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function ConvertToWordArray(string) {
            var lWordCount;
            var lMessageLength = string.length;
            var lNumberOfWords_temp1=lMessageLength + 8;
            var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
            var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
            var lWordArray=Array(lNumberOfWords-1);
            var lBytePosition = 0;
            var lByteCount = 0;
            while ( lByteCount < lMessageLength ) {
                lWordCount = (lByteCount-(lByteCount % 4))/4;
                lBytePosition = (lByteCount % 4)*8;
                lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
                lByteCount++;
            }
            lWordCount = (lByteCount-(lByteCount % 4))/4;
            lBytePosition = (lByteCount % 4)*8;
            lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
            lWordArray[lNumberOfWords-2] = lMessageLength<<3;
            lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
            return lWordArray;
        }

        function WordToHex(lValue) {
            var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
            for (lCount = 0;lCount<=3;lCount++) {
                lByte = (lValue>>>(lCount*8)) & 255;
                WordToHexValue_temp = "0" + lByte.toString(16);
                WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
            }
            return WordToHexValue;
        }

        function Utf8Encode(string) {
            string = string.replace(/\r\n/g,"\n");
            var utftext = "";

            for (var n = 0; n < string.length; n++) {

                var c = string.charCodeAt(n);

                if (c < 128) {
                    utftext += String.fromCharCode(c);
                }
                else if((c > 127) && (c < 2048)) {
                    utftext += String.fromCharCode((c >> 6) | 192);
                    utftext += String.fromCharCode((c & 63) | 128);
                }
                else {
                    utftext += String.fromCharCode((c >> 12) | 224);
                    utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                    utftext += String.fromCharCode((c & 63) | 128);
                }

            }

            return utftext;
        }

        var x=[];
        var k,AA,BB,CC,DD,a,b,c,d;
        var S11=7, S12=12, S13=17, S14=22;
        var S21=5, S22=9 , S23=14, S24=20;
        var S31=4, S32=11, S33=16, S34=23;
        var S41=6, S42=10, S43=15, S44=21;

        string = Utf8Encode(string);

        x = ConvertToWordArray(string);

        a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

        for (k=0;k<x.length;k+=16) {
            AA=a; BB=b; CC=c; DD=d;
            a=FF(a,b,c,d,x[k], S11,0xD76AA478);
            d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
            c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
            b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
            a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
            d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
            c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
            b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
            a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
            d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
            c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
            b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
            a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
            d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
            c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
            b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
            a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
            d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
            c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
            b=GG(b,c,d,a,x[k], S24,0xE9B6C7AA);
            a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
            d=GG(d,a,b,c,x[k+10],S22,0x2441453);
            c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
            b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
            a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
            d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
            c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
            b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
            a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
            d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
            c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
            b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
            a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
            d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
            c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
            b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
            a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
            d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
            c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
            b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
            a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
            d=HH(d,a,b,c,x[k], S32,0xEAA127FA);
            c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
            b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
            a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
            d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
            c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
            b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
            a=II(a,b,c,d,x[k], S41,0xF4292244);
            d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
            c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
            b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
            a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
            d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
            c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
            b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
            a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
            d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
            c=II(c,d,a,b,x[k+6], S43,0xA3014314);
            b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
            a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
            d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
            c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
            b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
            a=AddUnsigned(a,AA);
            b=AddUnsigned(b,BB);
            c=AddUnsigned(c,CC);
            d=AddUnsigned(d,DD);
        }

        var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);

        return temp.toLowerCase();
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.md5 = Metro.md5;
    }
}(Metro, m4q));

(function(Metro, $){
    'use strict';
    var Utils = Metro.utils;
    var AccordionDefaultConfig = {
        accordionDeferred: 0,
        showMarker: true,
        material: false,
        duration: METRO_ANIMATION_DURATION,
        oneFrame: true,
        showActive: true,
        activeFrameClass: "",
        activeHeadingClass: "",
        activeContentClass: "",
        onFrameOpen: Metro.noop,
        onFrameBeforeOpen: Metro.noop_true,
        onFrameClose: Metro.noop,
        onFrameBeforeClose: Metro.noop_true,
        onAccordionCreate: Metro.noop
    };

    Metro.accordionSetup = function(options){
        AccordionDefaultConfig = $.extend({}, AccordionDefaultConfig, options);
    };

    if (typeof window["metroAccordionSetup"] !== undefined) {
        Metro.accordionSetup(window["metroAccordionSetup"]);
    }

    Metro.Component('accordion', {
        init: function( options, elem ) {
            this._super(elem, options, AccordionDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent('accordionCreate', {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var frames = element.children(".frame");
            var active = element.children(".frame.active");
            var frame_to_open;

            element.addClass("accordion");

            if (o.showMarker === true) {
                element.addClass("marker-on");
            }

            if (o.material === true) {
                element.addClass("material");
            }

            if (active.length === 0) {
                frame_to_open = frames[0];
            } else {
                frame_to_open = active[0];
            }

            this._hideAll();

            if (o.showActive === true) {
                if (o.oneFrame === true) {
                    this._openFrame(frame_to_open);
                } else {
                    $.each(active, function(){
                        that._openFrame(this);
                    });
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var active = element.children(".frame.active");

            element.on(Metro.events.click, ".heading", function(){
                var heading = $(this);
                var frame = heading.parent();

                if (heading.closest(".accordion")[0] !== element[0]) {
                    return false;
                }

                if (frame.hasClass("active")) {
                    if (active.length === 1 && o.oneFrame) {
                        /* eslint-disable-next-line */

                    } else {
                        that._closeFrame(frame);
                    }
                } else {
                    that._openFrame(frame);
                }
            });
        },

        _openFrame: function(f){
            var element = this.element, o = this.options;
            var frame = $(f);

            if (Utils.exec(o.onFrameBeforeOpen, [frame[0]], element[0]) === false) {
                return false;
            }

            if (o.oneFrame === true) {
                this._closeAll(frame[0]);
            }

            frame.addClass("active " + o.activeFrameClass);
            frame.children(".heading").addClass(o.activeHeadingClass);
            frame.children(".content").addClass(o.activeContentClass).slideDown(o.duration);

            this._fireEvent("frameOpen", {
                frame: frame[0]
            });
        },

        _closeFrame: function(f){
            var element = this.element, o = this.options;
            var frame = $(f);

            if (!frame.hasClass("active")) {
                return ;
            }

            if (Utils.exec(o.onFrameBeforeClose, [frame[0]], element[0]) === false) {
                return ;
            }

            frame.removeClass("active " + o.activeFrameClass);
            frame.children(".heading").removeClass(o.activeHeadingClass);
            frame.children(".content").removeClass(o.activeContentClass).slideUp(o.duration);

            this._fireEvent("frameClose", {
                frame: frame[0]
            });
        },

        _closeAll: function(skip){
            var that = this, element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                if (skip === this) return;
                that._closeFrame(this);
            });
        },

        _hideAll: function(){
            var element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                $(this).children(".content").hide();
            });
        },

        _openAll: function(){
            var that = this, element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                that._openFrame(this);
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".heading");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ActivityDefaultConfig = {
        activityDeferred: 0,
        type: "ring",
        style: "light",
        size: 64,
        radius: 20,
        onActivityCreate: Metro.noop
    };

    Metro.activitySetup = function(options){
        ActivityDefaultConfig = $.extend({}, ActivityDefaultConfig, options);
    };

    if (typeof window["metroActivitySetup"] !== undefined) {
        Metro.activitySetup(window["metroActivitySetup"]);
    }

    Metro.Component('activity', {
        init: function( options, elem ) {
            this._super(elem, options, ActivityDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i, wrap;

            element
                .html('')
                .addClass(o.style + "-style")
                .addClass("activity-" + o.type);

            function _metro(){
                for(i = 0; i < 5 ; i++) {
                    $("<div/>").addClass('circle').appendTo(element);
                }
            }

            function _square(){
                for(i = 0; i < 4 ; i++) {
                    $("<div/>").addClass('square').appendTo(element);
                }
            }

            function _cycle(){
                $("<div/>").addClass('cycle').appendTo(element);
            }

            function _ring(){
                for(i = 0; i < 5 ; i++) {
                    wrap = $("<div/>").addClass('wrap').appendTo(element);
                    $("<div/>").addClass('circle').appendTo(wrap);
                }
            }

            function _simple(){
                $('<svg class="circular"><circle class="path" cx="'+o.size/2+'" cy="'+o.size/2+'" r="'+o.radius+'" fill="none" stroke-width="2" stroke-miterlimit="10"/></svg>').appendTo(element);
            }

            switch (o.type) {
                case 'metro': _metro(); break;
                case 'square': _square(); break;
                case 'cycle': _cycle(); break;
                case 'simple': _simple(); break;
                default: _ring();
            }

            this._fireEvent("activity-create", {
                element: element
            })
        },

        /*eslint-disable-next-line*/
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro.activity = {
        open: function(options){
            var o = options || {};
            var activity = '<div data-role="activity" data-type="'+( o.type ? o.type : 'cycle' )+'" data-style="'+( o.style ? o.style : 'color' )+'"></div>';
            var text = o.text ? '<div class="text-center">'+o.text+'</div>' : '';

            return Metro.dialog.create({
                content: activity + text,
                defaultAction: false,
                clsContent: "d-flex flex-column flex-justify-center flex-align-center bg-transparent no-shadow w-auto",
                clsDialog: "no-border no-shadow bg-transparent global-dialog",
                autoHide: o.autoHide ? o.autoHide : 0,
                overlayClickClose: o.overlayClickClose === true,
                overlayColor: o.overlayColor ? o.overlayColor : '#000000',
                overlayAlpha: o.overlayAlpha ? o.overlayAlpha : 0.5,
                clsOverlay: "global-overlay"
            });
        },

        close: function(a){
            Metro.dialog.close(a);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AdblockDefaultConfig = {
        adblockDeferred: 0,
        checkInterval: 1000,
        fireOnce: true,
        checkStop: 10,
        localhost: false,
        onAlert: Metro.noop,
        onFishingStart: Metro.noop,
        onFishingDone: Metro.noop
    };

    Metro.adblockSetup = function(options){
        AdblockDefaultConfig = $.extend({}, AdblockDefaultConfig, options);
    };

    if (typeof window["metroAdblockSetup"] !== undefined) {
        Metro.adblockSetup(window["metroAdblockSetup"]);
    }

    var Adblock = {
        bite: function(){
            var classes = "adblock-bite adsense google-adsense dblclick advert topad top_ads topAds textads sponsoredtextlink_container show_ads right-banner rekl mpu module-ad mid_ad mediaget horizontal_ad headerAd contentAd brand-link bottombanner bottom_ad_block block_ad bannertop banner-right banner-body b-banner b-article-aside__banner b-advert adwrapper adverts advertisment advertisement:not(body) advertise advert_list adtable adsense adpic adlist adleft adinfo adi adholder adframe addiv ad_text ad_space ad_right ad_links ad_body ad_block ad_Right adTitle adText";
            $("<div>")
                .addClass(classes.split(" ").shuffle().join(" "))
                .css({
                    position: "fixed",
                    height: 1,
                    width: 1,
                    overflow: "hidden",
                    visibility: "visible",
                    top: 0,
                    left: 0
                })
                .append($("<a href='https://dblclick.net'>").html('dblclick.net'))
                .appendTo('body');

            if (Adblock.options.adblockDeferred) {
                setTimeout(function () {
                    Adblock.fishing();
                }, Adblock.options.adblockDeferred);
            } else this.fishing();
        },

        fishing: function(){
            var o = Adblock.options;
            var checks = typeof o.fireOnce === "number" ? o.fireOnce : 0;
            var checkStop = o.checkStop;
            var interval = false;
            var run = function(){
                var a = $(".adsense.google-adsense.dblclick.advert.adblock-bite");
                var b = a.find("a");
                var done = function(){
                    clearInterval(interval);

                    Utils.exec(o.onFishingDone);
                    $(window).fire("fishing-done");

                    a.remove();
                };

                if (!o.localhost && $.localhost) {
                    done();
                    return ;
                }

                if (   !a.length
                    || !b.length
                    || a.css("display").indexOf('none') > -1
                    || b.css("display").indexOf('none') > -1
                ) {

                    Utils.exec(Adblock.options.onAlert);
                    $(window).fire("adblock-alert");

                    if (Adblock.options.fireOnce === true) {
                        done();
                    } else {
                        checks--;
                        if (checks === 0) {
                            done();
                        }
                    }
                } else {
                    if (checkStop !== false) {
                        checkStop--;
                        if (checkStop === 0) {
                            done();
                        }
                    }
                }
            };

            Utils.exec(o.onFishingStart);
            $(window).fire("fishing-start");

            interval = setInterval(function(){
                run();
            }, Adblock.options.checkInterval);

            run();
        }
    };

    Metro.Adblock = Adblock;

    $(function(){
        Adblock.options = $.extend({}, AdblockDefaultConfig);
        $(window).on("metro-initiated", function(){
            Adblock.bite();
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AudioPlayerDefaultConfig = {
        audioDeferred: 0,
        playlist: null,
        src: null,

        volume: .5,
        loop: false,
        autoplay: false,

        showLoop: true,
        showPlay: true,
        showStop: true,
        showMute: true,
        showFull: true,
        showStream: true,
        showVolume: true,
        showInfo: true,

        showPlaylist: true,
        showNext: true,
        showPrev: true,
        showFirst: true,
        showLast: true,
        showForward: true,
        showBackward: true,
        showShuffle: true,
        showRandom: true,

        loopIcon: "<span class='default-icon-loop'></span>",
        stopIcon: "<span class='default-icon-stop'></span>",
        playIcon: "<span class='default-icon-play'></span>",
        pauseIcon: "<span class='default-icon-pause'></span>",
        muteIcon: "<span class='default-icon-mute'></span>",
        volumeLowIcon: "<span class='default-icon-low-volume'></span>",
        volumeMediumIcon: "<span class='default-icon-medium-volume'></span>",
        volumeHighIcon: "<span class='default-icon-high-volume'></span>",

        playlistIcon: "<span class='default-icon-playlist'></span>",
        nextIcon: "<span class='default-icon-next'></span>",
        prevIcon: "<span class='default-icon-prev'></span>",
        firstIcon: "<span class='default-icon-first'></span>",
        lastIcon: "<span class='default-icon-last'></span>",
        forwardIcon: "<span class='default-icon-forward'></span>",
        backwardIcon: "<span class='default-icon-backward'></span>",
        shuffleIcon: "<span class='default-icon-shuffle'></span>",
        randomIcon: "<span class='default-icon-random'></span>",

        onPlay: Metro.noop,
        onPause: Metro.noop,
        onStop: Metro.noop,
        onEnd: Metro.noop,
        onMetadata: Metro.noop,
        onTime: Metro.noop,
        onAudioPlayerCreate: Metro.noop
    };

    Metro.audioPlayerSetup = function(options){
        AudioPlayerDefaultConfig = $.extend({}, AudioPlayerDefaultConfig, options);
    };

    if (typeof window["metroAudioPlayerSetup"] !== undefined) {
        Metro.audioPlayerSetup(window["metroAudioPlayerSetup"]);
    }

    Metro.Component('audio-player', {
        init: function( options, elem ) {
            this._super(elem, options, AudioPlayerDefaultConfig, {
                preloader: null,
                player: null,
                audio: elem,
                stream: null,
                volume: null,
                volumeBackup: 0,
                muted: false
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this._createPlayer();
            this._createControls();
            this._createEvents();

            if (o.autoplay === true) {
                this.play();
            }

            this._fireEvent("audio-player-create", {
                element: element,
                player: this.player
            })
        },

        _createPlayer: function(){
            var element = this.element, o = this.options, audio = this.audio;

            var prev = element.prev();
            var parent = element.parent();
            var player = $("<div>").addClass("media-player audio-player " + element[0].className);

            if (prev.length === 0) {
                parent.prepend(player);
            } else {
                player.insertAfter(prev);
            }

            element.appendTo(player);

            $.each(['muted', 'autoplay', 'controls', 'height', 'width', 'loop', 'poster', 'preload'], function(){
                element.removeAttr(this);
            });

            element.attr("preload", "auto");

            audio.volume = o.volume;

            if (o.src !== null) {
                this._setSource(o.src);
            }

            element[0].className = "";

            this.player = player;
        },

        _setSource: function(src){
            var element = this.element;

            element.find("source").remove();
            element.removeAttr("src");
            if (Array.isArray(src)) {
                $.each(src, function(){
                    var item = this;
                    if (item.src === undefined) return ;
                    $("<source>").attr('src', item.src).attr('type', item.type !== undefined ? item.type : '').appendTo(element);
                });
            } else {
                element.attr("src", src);
            }
        },

        _createControls: function(){
            var that = this, element = this.element, o = this.options, audio = this.elem;

            var controls = $("<div>").addClass("controls").addClass(o.clsControls).insertAfter(element);


            var stream = $("<div>").addClass("stream").appendTo(controls);
            var streamSlider = $("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);
            var preloader = $("<div>").addClass("load-audio").appendTo(stream);

            var volume = $("<div>").addClass("volume").appendTo(controls);
            var volumeSlider = $("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);

            var infoBox = $("<div>").addClass("info-box").appendTo(controls);

            if (o.showInfo !== true) {
                infoBox.hide();
            }

            preloader.activity({
                type: "metro",
                style: "color"
            });

            preloader.hide(0);

            this.preloader = preloader;

            Metro.makePlugin(streamSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                clsComplete: "bg-cyan",
                hint: true,
                onStart: function(){
                    if (!audio.paused) audio.pause();
                },
                onStop: function(val){
                    if (audio.seekable.length > 0) {
                        audio.currentTime = (that.duration * val / 100).toFixed(0);
                    }
                    if (audio.paused && audio.currentTime > 0) {
                        audio.play();
                    }
                }
            });

            this.stream = streamSlider;

            if (o.showStream !== true) {
                stream.hide();
            }

            Metro.makePlugin(volumeSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                hint: true,
                value: o.volume * 100,
                onChangeValue: function(val){
                    audio.volume = val / 100;
                }
            });

            this.volume = volumeSlider;

            if (o.showVolume !== true) {
                volume.hide();
            }

            var loop;

            if (o.showLoop === true) loop = $("<button>").attr("type", "button").addClass("button square loop").html(o.loopIcon).appendTo(controls);
            if (o.showPlay === true) $("<button>").attr("type", "button").addClass("button square play").html(o.playIcon).appendTo(controls);
            if (o.showStop === true) $("<button>").attr("type", "button").addClass("button square stop").html(o.stopIcon).appendTo(controls);
            if (o.showMute === true) $("<button>").attr("type", "button").addClass("button square mute").html(o.muteIcon).appendTo(controls);

            if (o.loop === true) {
                loop.addClass("active");
                element.attr("loop", "loop");
            }

            this._setVolume();

            if (o.muted) {
                that.volumeBackup = audio.volume;
                Metro.getPlugin(that.volume, 'slider').val(0);
                audio.volume = 0;
            }

            infoBox.html("00:00 / 00:00");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options, audio = this.elem, player = this.player;

            element.on("loadstart", function(){
                that.preloader.fadeIn();
            });

            element.on("loadedmetadata", function(){
                that.duration = audio.duration.toFixed(0);
                that._setInfo(0, that.duration);
                Utils.exec(o.onMetadata, [audio, player], element[0]);
            });

            element.on("canplay", function(){
                that._setBuffer();
                that.preloader.fadeOut();
            });

            element.on("progress", function(){
                that._setBuffer();
            });

            element.on("timeupdate", function(){
                var position = Math.round(audio.currentTime * 100 / that.duration);
                that._setInfo(audio.currentTime, that.duration);
                Metro.getPlugin(that.stream, 'slider').val(position);
                Utils.exec(o.onTime, [audio.currentTime, that.duration, audio, player], element[0]);
            });

            element.on("waiting", function(){
                that.preloader.fadeIn();
            });

            element.on("loadeddata", function(){

            });

            element.on("play", function(){
                player.find(".play").html(o.pauseIcon);
                Utils.exec(o.onPlay, [audio, player], element[0]);
            });

            element.on("pause", function(){
                player.find(".play").html(o.playIcon);
                Utils.exec(o.onPause, [audio, player], element[0]);
            });

            element.on("stop", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onStop, [audio, player], element[0]);
            });

            element.on("ended", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onEnd, [audio, player], element[0]);
            });

            element.on("volumechange", function(){
                that._setVolume();
            });

            player.on(Metro.events.click, ".play", function(){
                if (audio.paused) {
                    that.play();
                } else {
                    that.pause();
                }
            });

            player.on(Metro.events.click, ".stop", function(){
                that.stop();
            });

            player.on(Metro.events.click, ".mute", function(){
                that._toggleMute();
            });

            player.on(Metro.events.click, ".loop", function(){
                that._toggleLoop();
            });
        },

        _toggleLoop: function(){
            var loop = this.player.find(".loop");
            if (loop.length === 0) return ;
            loop.toggleClass("active");
            if (loop.hasClass("active")) {
                this.element.attr("loop", "loop");
            } else {
                this.element.removeAttr("loop");
            }
        },

        _toggleMute: function(){
            this.muted = !this.muted;
            if (this.muted === false) {
                this.audio.volume = this.volumeBackup;
            } else {
                this.volumeBackup = this.audio.volume;
                this.audio.volume = 0;
            }
            Metro.getPlugin(this.volume, 'slider').val(this.muted === false ? this.volumeBackup * 100 : 0);
        },

        _setInfo: function(a, b){
            this.player.find(".info-box").html(Utils.secondsToFormattedString(Math.round(a)) + " / " + Utils.secondsToFormattedString(Math.round(b)));
        },

        _setBuffer: function(){
            var buffer = this.audio.buffered.length ? Math.round(Math.floor(this.audio.buffered.end(0)) / Math.floor(this.audio.duration) * 100) : 0;
            Metro.getPlugin(this.stream, 'slider').buff(buffer);
        },

        _setVolume: function(){
            var audio = this.audio, player = this.player, o = this.options;

            var volumeButton = player.find(".mute");
            var volume = audio.volume * 100;
            if (volume > 1 && volume < 30) {
                volumeButton.html(o.volumeLowIcon);
            } else if (volume >= 30 && volume < 60) {
                volumeButton.html(o.volumeMediumIcon);
            } else if (volume >= 60 && volume <= 100) {
                volumeButton.html(o.volumeHighIcon);
            } else {
                volumeButton.html(o.muteIcon);
            }
        },

        play: function(src){
            if (src !== undefined) {
                this._setSource(src);
            }

            if (this.element.attr("src") === undefined && this.element.find("source").length === 0) {
                return ;
            }

            this.audio.play();
        },

        pause: function(){
            this.audio.pause();
        },

        resume: function(){
            if (this.audio.paused) {
                this.play();
            }
        },

        stop: function(){
            this.audio.pause();
            this.audio.currentTime = 0;
            Metro.getPlugin(this.stream, 'slider').val(0);
        },

        setVolume: function(v){
            if (v === undefined) {
                return this.audio.volume;
            }

            if (v > 1) {
                v /= 100;
            }

            this.audio.volume = v;
            Metro.getPlugin(this.volume, 'slider').val(v*100);
        },

        loop: function(){
            this._toggleLoop();
        },

        mute: function(){
            this._toggleMute();
        },

        changeSource: function(){
            var src = JSON.parse(this.element.attr('data-src'));
            this.play(src);
        },

        changeVolume: function(){
            var volume = this.element.attr("data-volume");
            this.setVolume(volume);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-src": this.changeSource(); break;
                case "data-volume": this.changeVolume(); break;
            }
        },

        destroy: function(){
            var element = this.element, player = this.player;

            element.off("all");
            player.off("all");

            Metro.getPlugin(this.stream, "slider").destroy();
            Metro.getPlugin(this.volume, "slider").destroy();

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ButtonGroupDefaultConfig = {
        buttongroupDeferred: 0,
        targets: "button",
        clsActive: "",
        requiredButton: false,
        mode: Metro.groupMode.ONE,
        onButtonClick: Metro.noop,
        onButtonGroupCreate: Metro.noop
    };

    Metro.buttonGroupSetup = function(options){
        ButtonGroupDefaultConfig = $.extend({}, ButtonGroupDefaultConfig, options);
    };

    if (typeof window["metroButtonGroupSetup"] !== undefined) {
        Metro.buttonGroupSetup(window["metroButtonGroupSetup"]);
    }

    Metro.Component('button-group', {
        init: function( options, elem ) {
            this._super(elem, options, ButtonGroupDefaultConfig, {
                active: null,
                id: Utils.elementId("button-group")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createGroup();
            this._createEvents();

            this._fireEvent("button-group-create", {
                element: element
            })
        },

        _createGroup: function(){
            var element = this.element, o = this.options;
            var buttons, buttons_active;

            element.addClass("button-group");

            buttons = element.find( o.targets );
            buttons_active = element.find( ".active" );

            if (o.mode === Metro.groupMode.ONE && buttons_active.length === 0 && o.requiredButton === true) {
                $(buttons[0]).addClass("active");
            }

            if (o.mode === Metro.groupMode.ONE && buttons_active.length > 1) {
                buttons.removeClass("active").removeClass(o.clsActive);
                $(buttons[0]).addClass("active");
            }

            element
                .find( ".active" )
                .addClass("js-active")
                .addClass(o.clsActive);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, o.targets, function(){
                var el = $(this);

                that._fireEvent("button-click", {
                    button: this
                })

                if (o.mode === Metro.groupMode.ONE && el.hasClass("active")) {
                    return ;
                }

                if (o.mode === Metro.groupMode.ONE) {
                    element.find(o.targets).removeClass(o.clsActive).removeClass("active js-active");
                    el.addClass("active").addClass(o.clsActive).addClass("js-active");
                } else {
                    el.toggleClass("active").toggleClass(o.clsActive).toggleClass("js-active");
                }

            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element, o = this.options;
            element.off(Metro.events.click, o.targets);
            return element;
        }

    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CalendarDefaultConfig = {
        calendarDeferred: 0,
        dayBorder: false,
        excludeDay: null,
        prevMonthIcon: "<span class='default-icon-chevron-left'></span>",
        nextMonthIcon: "<span class='default-icon-chevron-right'></span>",
        prevYearIcon: "<span class='default-icon-chevron-left'></span>",
        nextYearIcon: "<span class='default-icon-chevron-right'></span>",
        compact: false,
        wide: false,
        widePoint: null,
        pickerMode: false,
        show: null,
        locale: METRO_LOCALE,
        weekStart: METRO_WEEK_START,
        outside: true,
        buttons: 'cancel, today, clear, done',
        yearsBefore: 100,
        yearsAfter: 100,
        headerFormat: "%A, %b %e",
        showHeader: true,
        showFooter: true,
        showTimeField: true,
        showWeekNumber: false,
        clsCalendar: "",
        clsCalendarHeader: "",
        clsCalendarContent: "",
        clsCalendarFooter: "",
        clsCalendarMonths: "",
        clsCalendarYears: "",
        clsToday: "",
        clsSelected: "",
        clsExcluded: "",
        clsCancelButton: "",
        clsTodayButton: "",
        clsClearButton: "",
        clsDoneButton: "",
        isDialog: false,
        ripple: false,
        rippleColor: "#cccccc",
        exclude: null,
        preset: null,
        minDate: null,
        maxDate: null,
        weekDayClick: false,
        weekNumberClick: false,
        multiSelect: false,
        special: null,
        format: METRO_DATE_FORMAT,
        inputFormat: null,
        onCancel: Metro.noop,
        onToday: Metro.noop,
        onClear: Metro.noop,
        onDone: Metro.noop,
        onDayClick: Metro.noop,
        onDayDraw: Metro.noop,
        onWeekDayClick: Metro.noop,
        onWeekNumberClick: Metro.noop,
        onMonthChange: Metro.noop,
        onYearChange: Metro.noop,
        onCalendarCreate: Metro.noop
    };

    Metro.calendarSetup = function (options) {
        CalendarDefaultConfig = $.extend({}, CalendarDefaultConfig, options);
    };

    if (typeof window["metroCalendarSetup"] !== undefined) {
        Metro.calendarSetup(window["metroCalendarSetup"]);
    }

    Metro.Component('calendar', {
        init: function( options, elem ) {

            var now = new Date();
            now.setHours(0,0,0,0);

            this._super(elem, options, CalendarDefaultConfig, {
                today: now,
                show: now,
                current: {
                    year: now.getFullYear(),
                    month: now.getMonth(),
                    day: now.getDate()
                },
                preset: [],
                selected: [],
                exclude: [],
                special: [],
                excludeDay: [],
                min: null,
                max: null,
                locale: null,
                minYear: null,
                maxYear: null,
                offset: null,
                id: Utils.elementId("calendar")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.minYear = this.current.year - this.options.yearsBefore;
            this.maxYear = this.current.year + this.options.yearsAfter;
            this.offset = (new Date()).getTimezoneOffset() / 60 + 1;

            element.html("").addClass("calendar " + (o.compact === true ? "compact" : "")).addClass(o.clsCalendar);

            if (o.dayBorder === true) {
                element.addClass("day-border");
            }

            if (Utils.isValue(o.excludeDay)) {
                this.excludeDay = (""+o.excludeDay).toArray(",", "int");
            }

            if (Utils.isValue(o.preset)) {
                this._dates2array(o.preset, 'selected');
            }

            if (Utils.isValue(o.exclude)) {
                this._dates2array(o.exclude, 'exclude');
            }

            if (Utils.isValue(o.special)) {
                this._dates2array(o.special, 'special');
            }

            if (o.buttons !== false) {
                if (Array.isArray(o.buttons) === false) {
                    o.buttons = o.buttons.split(",").map(function(item){
                        return item.trim();
                    });
                }
            }

            if (o.minDate !== null && Utils.isDate(o.minDate, o.inputFormat)) {
                this.min = Utils.isValue(o.inputFormat) ? o.minDate.toDate(o.inputFormat) : (new Date(o.minDate));
            }

            if (o.maxDate !== null && Utils.isDate(o.maxDate, o.inputFormat)) {
                this.max = Utils.isValue(o.inputFormat) ? o.maxDate.toDate(o.inputFormat) : (new Date(o.maxDate));
            }

            if (o.show !== null && Utils.isDate(o.show, o.inputFormat)) {
                this.show = Utils.isValue(o.inputFormat) ? o.show.toDate(o.inputFormat) : (new Date(o.show));
                this.show.setHours(0,0,0,0);
                this.current = {
                    year: this.show.getFullYear(),
                    month: this.show.getMonth(),
                    day: this.show.getDate()
                }
            }

            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];

            this._drawCalendar();
            this._createEvents();

            if (o.wide === true) {
                element.addClass("calendar-wide");
            } else {
                if (!Utils.isNull(o.widePoint) && Utils.mediaExist(o.widePoint)) {
                    element.addClass("calendar-wide");
                }
            }


            if (o.ripple === true && Utils.isFunc(element.ripple) !== false) {
                element.ripple({
                    rippleTarget: ".button, .prev-month, .next-month, .prev-year, .next-year, .day",
                    rippleColor: this.options.rippleColor
                });
            }

            this._fireEvent("calendar-create");
        },

        _dates2array: function(val, category){
            var that = this, o = this.options;
            var dates;

            if (Utils.isNull(val)) {
                return ;
            }

            dates = typeof val === 'string' ? val.toArray() : val;

            $.each(dates, function(){
                var _d;

                if (!Utils.isDateObject(this)) {
                    _d = Utils.isValue(o.inputFormat) ? this.toDate(o.inputFormat) : new Date(this);
                    if (Utils.isDate(_d) === false) {
                        return ;
                    }
                    _d.setHours(0,0,0,0);
                } else {
                    _d = this;
                }

                that[category].push(_d.getTime());
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            $(window).on(Metro.events.resize, function(){
                if (o.wide !== true) {
                    if (!Utils.isNull(o.widePoint) && Utils.mediaExist(o.widePoint)) {
                        element.addClass("calendar-wide");
                    } else {
                        element.removeClass("calendar-wide");
                    }
                }
            }, {ns: this.id});

            element.on(Metro.events.click, function(){
                var months = element.find(".calendar-months");
                var years = element.find(".calendar-years");
                if (months.hasClass("open")) {
                    months.removeClass("open");
                }
                if (years.hasClass("open")) {
                    years.removeClass("open");
                }
            });

            element.on(Metro.events.click, ".prev-month, .next-month, .prev-year, .next-year", function(){
                var new_date, el = $(this);

                if (el.hasClass("prev-month")) {
                    new_date = new Date(that.current.year, that.current.month - 1, 1);
                    if (new_date.getFullYear() < that.minYear) {
                        return ;
                    }
                }
                if (el.hasClass("next-month")) {
                    new_date = new Date(that.current.year, that.current.month + 1, 1);
                    if (new_date.getFullYear() > that.maxYear) {
                        return ;
                    }
                }
                if (el.hasClass("prev-year")) {
                    new_date = new Date(that.current.year - 1, that.current.month, 1);
                    if (new_date.getFullYear() < that.minYear) {
                        return ;
                    }
                }
                if (el.hasClass("next-year")) {
                    new_date = new Date(that.current.year + 1, that.current.month, 1);
                    if (new_date.getFullYear() > that.maxYear) {
                        return ;
                    }
                }

                that.current = {
                    year: new_date.getFullYear(),
                    month: new_date.getMonth(),
                    day: new_date.getDate()
                };
                setTimeout(function(){
                    that._drawContent();
                    if (el.hasClass("prev-month") || el.hasClass("next-month")) {
                        that._fireEvent("month-change", {
                            current: that.current
                        });
                    }
                    if (el.hasClass("prev-year") || el.hasClass("next-year")) {
                        that._fireEvent("year-change", {
                            current: that.current
                        });
                    }
                }, o.ripple ? 300 : 1);
            });

            element.on(Metro.events.click, ".button.today", function(){
                that.toDay();
                that._fireEvent("today", {
                    today: that.today
                });
            });

            element.on(Metro.events.click, ".button.clear", function(){
                that.selected = [];
                that._drawContent();
                that._fireEvent("clear");
            });

            element.on(Metro.events.click, ".button.cancel", function(){
                that._drawContent();
                that._fireEvent("cancel");
            });

            element.on(Metro.events.click, ".button.done", function(){
                that._drawContent();
                that._fireEvent("done");
            });

            if (o.weekDayClick === true) {
                element.on(Metro.events.click, ".week-days .day", function (e) {
                    var day, index, days;

                    day = $(this);
                    index = day.index();

                    if (o.multiSelect === true) {
                        days = o.outside === true ? element.find(".days-row .day:nth-child(" + (index + 1) + ")") : element.find(".days-row .day:not(.outside):nth-child(" + (index + 1) + ")");
                        $.each(days, function () {
                            var d = $(this);
                            var dd = d.data('day');

                            if (d.hasClass("disabled") || d.hasClass("excluded")) return;

                            if (!that.selected.contains(dd))
                                that.selected.push(dd);
                            d.addClass("selected").addClass(o.clsSelected);
                        });
                    }

                    that._fireEvent("week-day-click", {
                        selected: that.selected,
                        day: day
                    });

                    e.preventDefault();
                    e.stopPropagation();
                });
            }

            if (o.weekNumberClick) {
                element.on(Metro.events.click, ".days-row .week-number", function (e) {
                    var weekNumElement, weekNumber, days;

                    weekNumElement = $(this);
                    weekNumber = weekNumElement.text();

                    if (o.multiSelect === true) {
                        days = $(this).siblings(".day");
                        $.each(days, function () {
                            var d = $(this);
                            var dd = d.data('day');

                            if (d.hasClass("disabled") || d.hasClass("excluded")) return;

                            if (!that.selected.contains(dd))
                                that.selected.push(dd);
                            d.addClass("selected").addClass(o.clsSelected);
                        });
                    }

                    that._fireEvent("week-number-click", {
                        selected: that.selected,
                        num: weekNumber,
                        numElement: weekNumElement
                    });

                    e.preventDefault();
                    e.stopPropagation();
                });
            }

            element.on(Metro.events.click, ".days-row .day", function(e){
                var day = $(this);
                var index, date;

                date = day.data('day');
                index = that.selected.indexOf(date);

                if (day.hasClass("outside")) {
                    date = new Date(date);
                    that.current = {
                        year: date.getFullYear(),
                        month: date.getMonth(),
                        day: date.getDate()
                    };
                    that._drawContent();

                    that._fireEvent("month-change", {
                        current: that.current
                    });

                    return ;
                }

                if (!day.hasClass("disabled")) {

                    if (o.pickerMode === true) {
                        that.selected = [date];
                        that.today = new Date(date);
                        that.current.year = that.today.getFullYear();
                        that.current.month = that.today.getMonth();
                        that.current.day = that.today.getDate();
                        that._drawHeader();
                        that._drawContent();
                    } else {
                        if (index === -1) {
                            if (o.multiSelect === false) {
                                element.find(".days-row .day").removeClass("selected").removeClass(o.clsSelected);
                                that.selected = [];
                            }
                            that.selected.push(date);
                            day.addClass("selected").addClass(o.clsSelected);
                        } else {
                            day.removeClass("selected").removeClass(o.clsSelected);
                            Utils.arrayDelete(that.selected, date);
                        }
                    }

                }

                that._fireEvent("day-click", {
                    selected: that.selected,
                    day: day
                });

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".curr-month", function(e){
                var target;
                var list = element.find(".months-list");

                list.find(".active").removeClass("active");
                list.scrollTop(0);
                element.find(".calendar-months").addClass("open");

                target = list.find(".js-month-"+that.current.month).addClass("active");

                setTimeout(function(){
                    list.animate({
                        draw: {
                            scrollTop: target.position().top - ( (list.height() - target.height() )/ 2)
                        },
                        dur: 200
                    })
                }, 300);

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".calendar-months li", function(e){
                that.current.month = $(this).index();
                that._drawContent();
                element.find(".calendar-months").removeClass("open");

                that._fireEvent("month-change", {
                    current: that.current
                });

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".curr-year", function(e){
                var target;
                var list = element.find(".years-list");

                list.find(".active").removeClass("active");
                list.scrollTop(0);
                element.find(".calendar-years").addClass("open");

                target = list.find(".js-year-"+that.current.year).addClass("active");

                setTimeout(function(){
                    list.animate({
                        draw: {
                            scrollTop: target.position().top - ( (list.height() - target.height() )/ 2)
                        },
                        dur: 200
                    })
                }, 300);

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".calendar-years li", function(e){
                that.current.year = $(this).text();
                that._drawContent();
                element.find(".calendar-years").removeClass("open");

                that._fireEvent("year-change", {
                    current: that.current
                });

                e.preventDefault();
                e.stopPropagation();
            });
        },

        _drawHeader: function(){
            var element = this.element, o = this.options;
            var header = element.find(".calendar-header");

            if (header.length === 0) {
                header = $("<div>").addClass("calendar-header").addClass(o.clsCalendarHeader).appendTo(element);
            }

            header.html("");

            $("<div>").addClass("header-year").html(this.today.getFullYear()).appendTo(header);
            $("<div>").addClass("header-day").html(this.today.format(o.headerFormat, o.locale)).appendTo(header);

            if (o.showHeader === false) {
                header.hide();
            }
        },

        _drawFooter: function(){
            var element = this.element, o = this.options;
            var buttons_locale = this.locale['buttons'];
            var footer = element.find(".calendar-footer");

            if (o.buttons === false) {
                return ;
            }

            if (footer.length === 0) {
                footer = $("<div>").addClass("calendar-footer").addClass(o.clsCalendarFooter).appendTo(element);
            }

            footer.html("");

            $.each(o.buttons, function(){
                var button = $("<button>").attr("type", "button").addClass("button " + this + " " + o['cls'+this.capitalize()+'Button']).html(buttons_locale[this]).appendTo(footer);
                if (this === 'cancel' || this === 'done') {
                    button.addClass("js-dialog-close");
                }
            });

            if (o.showFooter === false) {
                footer.hide();
            }
        },

        _drawMonths: function(){
            var element = this.element, o = this.options;
            var months = $("<div>").addClass("calendar-months").addClass(o.clsCalendarMonths).appendTo(element);
            var list = $("<ul>").addClass("months-list").appendTo(months);
            var calendar_locale = this.locale['calendar'];
            var i;
            for(i = 0; i < 12; i++) {
                $("<li>").addClass("js-month-"+i).html(calendar_locale['months'][i]).appendTo(list);
            }
        },

        _drawYears: function(){
            var element = this.element, o = this.options;
            var years = $("<div>").addClass("calendar-years").addClass(o.clsCalendarYears).appendTo(element);
            var list = $("<ul>").addClass("years-list").appendTo(years);
            var i;
            for(i = this.minYear; i <= this.maxYear; i++) {
                $("<li>").addClass("js-year-"+i).html(i).appendTo(list);
            }
        },

        _drawContent: function(){
            var element = this.element, o = this.options;
            var content = element.find(".calendar-content"), toolbar;
            var calendar_locale = this.locale['calendar'];
            var i, j, d, s, counter = 0;
            var first = new Date(this.current.year, this.current.month, 1);
            var first_day;
            var prev_month_days = (new Date(this.current.year, this.current.month, 0)).getDate();
            var year, month;

            if (content.length === 0) {
                content = $("<div>").addClass("calendar-content").addClass(o.clsCalendarContent).appendTo(element);
            }

            content.html("");

            toolbar = $("<div>").addClass("calendar-toolbar").appendTo(content);

            /**
             * Calendar toolbar
             */
            $("<span>").addClass("prev-month").html(o.prevMonthIcon).appendTo(toolbar);
            $("<span>").addClass("curr-month").html(calendar_locale['months'][this.current.month]).appendTo(toolbar);
            $("<span>").addClass("next-month").html(o.nextMonthIcon).appendTo(toolbar);

            $("<span>").addClass("prev-year").html(o.prevYearIcon).appendTo(toolbar);
            $("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
            $("<span>").addClass("next-year").html(o.nextYearIcon).appendTo(toolbar);

            /**
             * Week days
             */
            var week_days = $("<div>").addClass("week-days").appendTo(content);
            var day_class = "day";

            if (o.showWeekNumber === true) {
                $("<span>").addClass("week-number").html("#").appendTo(week_days);
                day_class += " and-week-number";
            }

            for (i = 0; i < 7; i++) {
                if (o.weekStart === 0) {
                    j = i;
                } else {
                    j = i + 1;
                    if (j === 7) j = 0;
                }
                $("<span>").addClass(day_class).html(calendar_locale["days"][j + 7]).appendTo(week_days);
            }

            /**
             * Calendar days
             */
            var days = $("<div>").addClass("days").appendTo(content);
            var days_row = $("<div>").addClass("days-row").appendTo(days);

            first_day = o.weekStart === 0 ? first.getDay() : (first.getDay() === 0 ? 6 : first.getDay() - 1);

            if (this.current.month - 1 < 0) {
                month = 11;
                year = this.current.year - 1;
            } else {
                month = this.current.month - 1;
                year = this.current.year;
            }

            if (o.showWeekNumber === true) {
                $("<div>").addClass("week-number").html((new Date(year, month, prev_month_days - first_day + 1)).getWeek(o.weekStart)).appendTo(days_row);
            }

            for(i = 0; i < first_day; i++) {
                var v = prev_month_days - first_day + i + 1;
                d = $("<div>").addClass(day_class+" outside").appendTo(days_row);

                s = new Date(year, month, v);
                s.setHours(0,0,0,0);

                d.data('day', s.getTime());

                if (o.outside === true) {
                    d.html(v);

                    if (this.excludeDay.length > 0) {
                        if (this.excludeDay.indexOf(s.getDay()) > -1) {
                            d.addClass("disabled excluded").addClass(o.clsExcluded);
                        }
                    }

                    this._fireEvent("day-draw", {
                        date: s,
                        cell: d[0]
                    });
                }

                counter++;
            }

            first.setHours(0,0,0,0);
            while(first.getMonth() === this.current.month) {

                d = $("<div>").addClass(day_class).html(first.getDate()).appendTo(days_row);

                d.data('day', first.getTime());

                if (this.show.getTime() === first.getTime()) {
                    d.addClass("showed");
                }

                if (this.today.getTime() === first.getTime()) {
                    d.addClass("today").addClass(o.clsToday);
                }

                if (this.special.length === 0) {

                    if (this.selected.indexOf(first.getTime()) !== -1) {
                        d.addClass("selected").addClass(o.clsSelected);
                    }
                    if (this.exclude.indexOf(first.getTime()) !== -1) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }

                    if (this.min !== null && first.getTime() < this.min.getTime()) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }
                    if (this.max !== null && first.getTime() > this.max.getTime()) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }

                    if (this.excludeDay.length > 0) {
                        if (this.excludeDay.indexOf(first.getDay()) > -1) {
                            d.addClass("disabled excluded").addClass(o.clsExcluded);
                        }
                    }
                } else {

                    if (this.special.indexOf(first.getTime()) === -1) {
                        d.addClass("disabled excluded").addClass(o.clsExcluded);
                    }

                }

                this._fireEvent("day-draw", {
                    date: first,
                    cell: d[0]
                });

                counter++;
                if (counter % 7 === 0) {
                    days_row = $("<div>").addClass("days-row").appendTo(days);
                    if (o.showWeekNumber === true) {
                        $("<div>").addClass("week-number").html((new Date(first.getFullYear(), first.getMonth(), first.getDate() + 1)).getWeek(o.weekStart)).appendTo(days_row);
                    }
                }
                first.setDate(first.getDate() + 1);
                first.setHours(0,0,0,0);
            }

            first_day = o.weekStart === 0 ? first.getDay() : (first.getDay() === 0 ? 6 : first.getDay() - 1);

            if (this.current.month + 1 > 11) {
                month = 0;
                year = this.current.year + 1;
            } else {
                month = this.current.month + 1;
                year = this.current.year;
            }

            if (first_day > 0) for(i = 0; i < 7 - first_day; i++) {
                d = $("<div>").addClass(day_class+" outside").appendTo(days_row);
                s = new Date(year, month, i + 1);
                s.setHours(0,0,0,0);
                d.data('day', s.getTime());
                if (o.outside === true) {
                    d.html(i + 1);

                    if (this.excludeDay.length > 0) {
                        if (this.excludeDay.indexOf(s.getDay()) > -1) {
                            d.addClass("disabled excluded").addClass(o.clsExcluded);
                        }
                    }

                    this._fireEvent("day-draw", {
                        date: s,
                        cell: d[0]
                    });

                }
            }
        },

        _drawCalendar: function(){
            var that = this;
            setTimeout(function(){
                that.element.html("");
                that._drawHeader();
                that._drawContent();
                that._drawFooter();
                that._drawMonths();
                that._drawYears();
            }, 0);
        },

        getPreset: function(){
            return this.preset;
        },

        getSelected: function(){
            return this.selected;
        },

        getExcluded: function(){
            return this.exclude;
        },

        getToday: function(){
            return this.today;
        },

        getCurrent: function(){
            return this.current;
        },

        clearSelected: function(){
            this.selected = [];
            this._drawContent();
        },

        toDay: function(){
            this.today = new Date();
            this.today.setHours(0,0,0,0);
            this.current = {
                year: this.today.getFullYear(),
                month: this.today.getMonth(),
                day: this.today.getDate()
            };
            this._drawHeader();
            this._drawContent();
        },

        setExclude: function(exclude){
            var element = this.element, o = this.options;
            if (Utils.isNull(exclude) && Utils.isNull(element.attr("data-exclude"))) {
                return ;
            }
            o.exclude = !Utils.isNull(exclude) ? exclude : element.attr("data-exclude");
            this._dates2array(o.exclude, 'exclude');
            this._drawContent();
        },

        setPreset: function(preset){
            var element = this.element, o = this.options;
            if (Utils.isNull(preset) && Utils.isNull(element.attr("data-preset"))) {
                return ;
            }

            o.preset = !Utils.isNull(preset) ? preset : element.attr("data-preset");
            this._dates2array(o.preset, 'selected');
            this._drawContent();
        },

        setSpecial: function(special){
            var element = this.element, o = this.options;
            if (Utils.isNull(special) && Utils.isNull(element.attr("data-special"))) {
                return ;
            }
            o.special = !Utils.isNull(special) ? special : element.attr("data-special");
            this._dates2array(o.exclude, 'special');
            this._drawContent();
        },

        setShow: function(show){
            var element = this.element, o = this.options;

            if (Utils.isNull(show) && Utils.isNull(element.attr("data-show"))) {
                return ;
            }
            o.show = !Utils.isNull(show) ? show : element.attr("data-show");

            this.show = Utils.isDateObject(show) ? show : Utils.isValue(o.inputFormat) ? o.show.toDate(o.inputFormat) : new Date(o.show);
            this.show.setHours(0,0,0,0);
            this.current = {
                year: this.show.getFullYear(),
                month: this.show.getMonth(),
                day: this.show.getDate()
            };

            this._drawContent();
        },

        setMinDate: function(date){
            var element = this.element, o = this.options;

            o.minDate = Utils.isValue(date) ? date : element.attr("data-min-date");
            if (Utils.isValue(o.minDate) && Utils.isDate(o.minDate, o.inputFormat)) {
                this.min = Utils.isValue(o.inputFormat) ? o.minDate.toDate(o.inputFormat) : (new Date(o.minDate));
            }

            this._drawContent();
        },

        setMaxDate: function(date){
            var element = this.element, o = this.options;

            o.maxDate = Utils.isValue(date) ? date : element.attr("data-max-date");
            if (Utils.isValue(o.maxDate) && Utils.isDate(o.maxDate, o.inputFormat)) {
                this.max = Utils.isValue(o.inputFormat) ? o.maxDate.toDate(o.inputFormat) : (new Date(o.maxDate));
            }

            this._drawContent();
        },

        setToday: function(val){
            var o = this.options;

            if (!Utils.isValue(val)) {
                val = new Date();
            }
            this.today = Utils.isDateObject(val) ? val : Utils.isValue(o.inputFormat) ? val.toDate(o.inputFormat) : new Date(val);
            this.today.setHours(0,0,0,0);
            this._drawHeader();
            this._drawContent();
        },

        i18n: function(val){
            var o = this.options;
            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }
            o.locale = val;
            this.locale = Metro.locales[o.locale];
            this._drawCalendar();
        },

        changeAttrLocale: function(){
            var element = this.element;
            this.i18n(element.attr("data-locale"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-exclude': this.setExclude(); break;
                case 'data-preset': this.setPreset(); break;
                case 'data-special': this.setSpecial(); break;
                case 'data-show': this.setShow(); break;
                case 'data-min-date': this.setMinDate(); break;
                case 'data-max-date': this.setMaxDate(); break;
                case 'data-locale': this.changeAttrLocale(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            element.off(Metro.events.click, ".prev-month, .next-month, .prev-year, .next-year");
            element.off(Metro.events.click, ".button.today");
            element.off(Metro.events.click, ".button.clear");
            element.off(Metro.events.click, ".button.cancel");
            element.off(Metro.events.click, ".button.done");
            element.off(Metro.events.click, ".week-days .day");
            element.off(Metro.events.click, ".days-row .day");
            element.off(Metro.events.click, ".curr-month");
            element.off(Metro.events.click, ".calendar-months li");
            element.off(Metro.events.click, ".curr-year");
            element.off(Metro.events.click, ".calendar-years li");
            element.off(Metro.events.click);

            if (o.ripple === true) {
                element.data("ripple").destroy();
            }

            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $('.calendar .calendar-years').each(function(){
            $(this).removeClass("open");
        });
        $('.calendar .calendar-months').each(function(){
            $(this).removeClass("open");
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CalendarPickerDefaultConfig = {
        label: "",
        value:'',
        calendarpickerDeferred: 0,
        nullValue: true,
        useNow: false,

        prepend: "",

        calendarWide: false,
        calendarWidePoint: null,


        dialogMode: false,
        dialogPoint: 640,
        dialogOverlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,

        locale: METRO_LOCALE,
        size: "100%",
        format: METRO_DATE_FORMAT,
        inputFormat: null,
        headerFormat: "%A, %b %e",
        clearButton: false,
        calendarButtonIcon: "<span class='default-icon-calendar'></span>",
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        copyInlineStyles: false,
        clsPicker: "",
        clsInput: "",

        yearsBefore: 100,
        yearsAfter: 100,
        weekStart: METRO_WEEK_START,
        outside: true,
        ripple: false,
        rippleColor: "#cccccc",
        exclude: null,
        minDate: null,
        maxDate: null,
        special: null,
        showHeader: true,

        showWeekNumber: false,

        clsCalendar: "",
        clsCalendarHeader: "",
        clsCalendarContent: "",
        clsCalendarMonths: "",
        clsCalendarYears: "",
        clsToday: "",
        clsSelected: "",
        clsExcluded: "",
        clsPrepend: "",
        clsLabel: "",

        onDayClick: Metro.noop,
        onCalendarPickerCreate: Metro.noop,
        onCalendarShow: Metro.noop,
        onCalendarHide: Metro.noop,
        onChange: Metro.noop,
        onMonthChange: Metro.noop,
        onYearChange: Metro.noop
    };

    Metro.calendarPickerSetup = function (options) {
        CalendarPickerDefaultConfig = $.extend({}, CalendarPickerDefaultConfig, options);
    };

    if (typeof window["metroCalendarPickerSetup"] !== undefined) {
        Metro.calendarPickerSetup(window["metroCalendarPickerSetup"]);
    }

    Metro.Component('calendar-picker', {
        init: function( options, elem ) {
            this._super(elem, options, CalendarPickerDefaultConfig, {
                value: null,
                value_date: null,
                calendar: null,
                overlay: null,
                id: Utils.elementId("calendar-picker")
            });

            return this;
        },

        _create: function(){

            this._createStructure();
            this._createEvents();

            this._fireEvent("calendar-picker-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container = $("<div>").addClass("input " + element[0].className + " calendar-picker");
            var buttons = $("<div>").addClass("button-group");
            var calendarButton, clearButton, cal = $("<div>").addClass("drop-shadow");
            var curr;
            var body = $("body");

            element.attr("type", "text");
            element.attr("autocomplete", "off");
            element.attr("readonly", true);

            curr = (""+o.value).trim() !== '' ? o.value : element.val().trim();

            if (!Utils.isValue(curr)) {
                if (o.useNow) this.value = new Date();
            } else {
                this.value = !Utils.isValue(o.inputFormat) ? new Date(curr) : curr.toDate(o.inputFormat, o.locale);
            }

            if (Utils.isValue(this.value)) this.value.setHours(0,0,0,0);

            element.val(!Utils.isValue(curr) && o.nullValue === true ? "" : that.value.format(o.format, o.locale));

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);
            cal.appendTo(o.dialogMode ? body : container);

            Metro.makePlugin(cal, "calendar", {
                wide: o.calendarWide,
                widePoint: o.calendarWidePoint,

                format: o.format,
                inputFormat: o.inputFormat,
                pickerMode: true,
                show: o.value,
                locale: o.locale,
                weekStart: o.weekStart,
                outside: o.outside,
                buttons: false,
                headerFormat: o.headerFormat,

                clsCalendar: [o.clsCalendar, "calendar-for-picker", (o.dialogMode ? "dialog-mode":"")].join(" "),
                clsCalendarHeader: o.clsCalendarHeader,
                clsCalendarContent: o.clsCalendarContent,
                clsCalendarFooter: "d-none",
                clsCalendarMonths: o.clsCalendarMonths,
                clsCalendarYears: o.clsCalendarYears,
                clsToday: o.clsToday,
                clsSelected: o.clsSelected,
                clsExcluded: o.clsExcluded,

                ripple: o.ripple,
                rippleColor: o.rippleColor,
                exclude: o.exclude,
                minDate: o.minDate,
                maxDate: o.maxDate,
                yearsBefore: o.yearsBefore,
                yearsAfter: o.yearsAfter,
                special: o.special,
                showHeader: o.showHeader,
                showFooter: false,
                showWeekNumber: o.showWeekNumber,
                onDayClick: function(sel, day, el){
                    var date = new Date(sel[0]);
                    date.setHours(0,0,0,0);

                    that._removeOverlay();

                    that.value = date;
                    element.val(date.format(o.format, o.locale));
                    element.trigger("change");
                    cal.removeClass("open open-up");
                    cal.hide();

                    that._fireEvent("change", {
                        val: that.value
                    });

                    that._fireEvent("day-click", {
                        sel: sel,
                        day: day,
                        el: el
                    });
                },
                onMonthChange: o.onMonthChange,
                onYearChange: o.onYearChange
            });

            this.calendar = cal;

            if (o.clearButton === true) {
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            }

            calendarButton = $("<button>").addClass("button").attr("tabindex", -1).attr("type", "button").html(o.calendarButtonIcon);
            calendarButton.appendTo(buttons);

            if (o.prepend !== "") {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl");
            }

            if (String(o.size).indexOf("%") > -1) {
                container.css({
                    width: o.size
                });
            } else {
                container.css({
                    width: parseInt(o.size) + "px"
                });
            }

            element[0].className = '';

            if (o.copyInlineStyles === true) {
                $.each(Utils.getInlineStyles(element), function(key, value){
                    container.css(key, value);
                });
            }

            container.addClass(o.clsPicker);
            element.addClass(o.clsInput);

            if (o.dialogOverlay === true) {
                this.overlay = that._overlay();
            }

            if (o.dialogMode === true) {
                container.addClass("dialog-mode");
            } else {
                if (Utils.media("(max-width: "+o.dialogPoint+"px)")) {
                    container.addClass("dialog-mode");
                    this.calendar.addClass("dialog-mode");
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.parent();
            var clear = container.find(".input-clear-button");
            var cal = this.calendar;
            var cal_plugin = Metro.getPlugin(cal[0], 'calendar');
            var calendar = this.calendar;

            $(window).on(Metro.events.resize, function(){
                if (o.dialogMode !== true) {
                    if (Utils.media("(max-width: " + o.dialogPoint + "px)")) {
                        container.addClass("dialog-mode");
                        calendar.appendTo("body").addClass("dialog-mode");
                    } else {
                        container.removeClass("dialog-mode");
                        calendar.appendTo(container).removeClass("dialog-mode");
                    }
                }
            }, {ns: this.id});

            if (clear.length > 0) clear.on(Metro.events.click, function(e){
                element.val("").trigger('change').blur(); // TODO change blur
                that.value = null;
                e.preventDefault();
                e.stopPropagation();
            });

            container.on(Metro.events.click, "button, input", function(e){

                var value = Utils.isValue(that.value) ? that.value : new Date();

                value.setHours(0,0,0,0);

                if (cal.hasClass("open") === false && cal.hasClass("open-up") === false) {

                    $(".calendar-picker .calendar").removeClass("open open-up").hide();

                    cal_plugin.setPreset([value]);
                    cal_plugin.setShow(value);
                    cal_plugin.setToday(value);

                    if (container.hasClass("dialog-mode")) {
                        that.overlay.appendTo($('body'));
                    }
                    cal.addClass("open");
                    if (!Utils.inViewport(cal[0])) {
                        cal.addClass("open-up");
                    }
                    // if (Utils.isOutsider(cal) === false) {
                    //     cal.addClass("open-up");
                    // }

                    that._fireEvent("calendar-show", {
                        calendar: cal
                    });

                } else {

                    that._removeOverlay();
                    cal.removeClass("open open-up");

                    that._fireEvent("calendar-hide", {
                        calendar: cal
                    });

                }
                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.blur, function(){container.removeClass("focused");});
            element.on(Metro.events.focus, function(){container.addClass("focused");});
            element.on(Metro.events.change, function(){
                Utils.exec(o.onChange, [that.value], element[0]);
            });

            container.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            })
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay for-calendar-picker").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        _removeOverlay: function(){
            $('body').find('.overlay.for-calendar-picker').remove();
        },

        val: function(v){
            var element = this.element, o = this.options;

            if (Utils.isNull(v)) {
                return this.value;
            }

            if (Utils.isDate(v, o.inputFormat) === true) {
                Metro.getPlugin(this.calendar[0],"calendar").clearSelected();
                this.value = typeof v === 'string' ? o.inputFormat ? v.toDate(o.inputFormat, o.locale) : new Date(v) : v;
                if (Utils.isValue(this.value)) this.value.setHours(0,0,0,0);
                element.val(this.value.format(o.format, o.locale));
                element.trigger("change");
            }
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        i18n: function(val){
            var o = this.options;
            var hidden;
            var cal = this.calendar;
            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }

            hidden = cal[0].hidden;
            if (hidden) {
                cal.css({
                    visibility: "hidden",
                    display: "block"
                });
            }
            Metro.getPlugin(cal[0], 'calendar').i18n(val);
            if (hidden) {
                cal.css({
                    visibility: "visible",
                    display: "none"
                });
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;
            var cal = Metro.getPlugin(this.calendar[0], "calendar");

            var changeAttrLocale = function(){
                that.i18n(element.attr("data-locale"));
            };

            var changeAttrSpecial = function(){
                cal.setSpecial(element.attr("data-special"));
            };

            var changeAttrExclude = function(){
                cal.setExclude(element.attr("data-exclude"));
            };

            var changeAttrMinDate = function(){
                cal.setMinDate(element.attr("data-min-date"));
            };

            var changeAttrMaxDate = function(){
                cal.setMaxDate(element.attr("data-max-date"));
            };

            var changeAttrValue = function(){
                that.val(element.attr("value"));
            };

            var changeDataValue = function(){
                that.val(element.attr("data-value"))
            };

            switch (attributeName) {
                case "value": changeAttrValue(); break;
                case 'disabled': this.toggleState(); break;
                case 'data-locale': changeAttrLocale(); break;
                case 'data-special': changeAttrSpecial(); break;
                case 'data-exclude': changeAttrExclude(); break;
                case 'data-min-date': changeAttrMinDate(); break;
                case 'data-max-date': changeAttrMaxDate(); break;
                case 'data-value': changeDataValue(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.parent();
            var clear = container.find(".input-clear-button");

            $(window).off(Metro.events.resize, {ns: this.id});
            clear.off(Metro.events.click);
            container.off(Metro.events.click, "button, input");
            element.off(Metro.events.blur);
            element.off(Metro.events.focus);
            element.off(Metro.events.change);

            Metro.getPlugin(this.calendar, "calendar").destroy();

            return element;
        }
    });

    $(document).on(Metro.events.click, ".overlay.for-calendar-picker",function(){
        $(this).remove();
        $(".calendar-for-picker.open").removeClass("open open-up");
    });

    $(document).on(Metro.events.click, function(){
        $(".calendar-picker .calendar").removeClass("open open-up");
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var effects = [
        "slide", "slide-v", "fade", "switch", "zoom", "swirl"
    ];
    var CarouselDefaultConfig = {
        carouselDeferred: 0,
        autoStart: false,
        width: "100%",
        height: "16/9", // 3/4, 21/9
        effect: effects[0],
        effectFunc: "linear",
        direction: "left", //left, right
        duration: METRO_ANIMATION_DURATION,
        period: 5000,
        stopOnMouse: true,

        controls: true,
        bullets: true,
        bulletsStyle: "square", // square, circle, rect, diamond
        bulletsSize: "default", // default, mini, small, large

        controlsOnMouse: false,
        controlsOutside: false,
        bulletsPosition: "default", // default, left, right

        controlPrev: '&#x23F4',
        controlNext: '&#x23F5',
        clsCarousel: "",
        clsSlides: "",
        clsSlide: "",
        clsControls: "",
        clsControlNext: "",
        clsControlPrev: "",
        clsBullets: "",
        clsBullet: "",
        clsBulletOn: "",
        clsThumbOn: "",

        onStop: Metro.noop,
        onStart: Metro.noop,
        onPlay: Metro.noop,
        onSlideClick: Metro.noop,
        onBulletClick: Metro.noop,
        onThumbClick: Metro.noop,
        onMouseEnter: Metro.noop,
        onMouseLeave: Metro.noop,
        onNextClick: Metro.noop,
        onPrevClick: Metro.noop,
        onSlideShow: Metro.noop,
        onSlideHide: Metro.noop,
        onCarouselCreate: Metro.noop
    };

    Metro.carouselSetup = function (options) {
        CarouselDefaultConfig = $.extend({}, CarouselDefaultConfig, options);
    };

    if (typeof window["metroCarouselSetup"] !== undefined) {
        Metro.carouselSetup(window["metroCarouselSetup"]);
    }

    Metro.Component('carousel', {
        init: function( options, elem ) {
            this._super(elem, options, CarouselDefaultConfig, {
                height: 0,
                width: 0,
                slides: [],
                current: null,
                currentIndex: null,
                dir: "left",
                interval: false,
                isAnimate: false,
                id: Utils.elementId("carousel")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var slides = element.find(".slide");
            var slides_container = element.find(".slides");

            this.dir = this.options.direction;

            element.addClass("carousel").addClass(o.clsCarousel);

            element.css({
                maxWidth: o.width
            });


            if (o.controlsOutside === true) {
                element.addClass("controls-outside");
            }

            if (slides_container.length === 0) {
                slides_container = $("<div>").addClass("slides").appendTo(element);
                slides.appendTo(slides_container);
            }

            slides.addClass(o.clsSlides);

            if (slides.length > 0) {

                this._createSlides();
                this._createControls();
                this._createBullets();
                this._createEvents();
                this._resize();

                if (o.controlsOnMouse === true) {
                    element.find("[class*=carousel-switch]").fadeOut(0);
                    element.find(".carousel-bullets").fadeOut(0);
                }

                if (o.autoStart === true) {
                    this._start();
                } else {
                    this._fireEvent("slide-show", {
                        current: this.slides[this.currentIndex][0],
                        prev: undefined
                    });
                }

            }

            this._fireEvent("carousel-create", {
                element: element
            });
        },

        _start: function(){
            var that = this, element = this.element, o = this.options;
            var period = o.period;
            var current = this.slides[this.currentIndex];

            if (current.data("period") !== undefined) {
                period = current.data("period");
            }

            if (this.slides.length <= 1) {
                return ;
            }

            if (this.interval === false) this.interval = setTimeout(function run() {
                var t = o.direction === 'left' ? 'next' : 'prior';
                that._slideTo(t, true);
            }, period);

            this._fireEvent("start", {
                element: element
            });
        },

        _stop: function(){
            clearInterval(this.interval);
            this.interval = false;
        },

        _resize: function(){
            var element = this.element, o = this.options;
            var width = element.outerWidth();
            var height;
            var medias = [];

            if (["16/9", "21/9", "4/3"].indexOf(o.height) > -1) {
                height = Utils.aspectRatioH(width, o.height);
            } else {
                if (String(o.height).indexOf("@") > -1) {
                    medias = o.height.substr(1).toArray("|");
                    $.each(medias, function(){
                        var media = this.toArray(",");
                        if (window.matchMedia(media[0]).matches) {
                            if (["16/9", "21/9", "4/3"].indexOf(media[1]) > -1) {
                                height = Utils.aspectRatioH(width, media[1]);
                            } else {
                                height = parseInt(media[1]);
                            }
                        }
                    });
                } else {
                    height = parseInt(o.height);
                }
            }

            element.css({
                height: height
            });
        },

        _createSlides: function(){
            var that = this, element = this.element, o = this.options;
            var slides = element.find(".slide");

            $.each(slides, function(i){
                var slide = $(this);
                if (slide.data("cover") !== undefined) {
                    slide.css({
                        backgroundImage: "url("+slide.data('cover')+")"
                    });
                }

                if (i !== 0) {
                    switch (o.effect) {
                        case "switch":
                        case "slide":
                            slide.css("left", "100%");
                            break;
                        case "slide-v":
                            slide.css("top", "100%");
                            break;
                        case "fade":
                        case "zoom":
                        case "swirl":
                            slide.css("opacity", "0");
                            break;
                    }
                } else {
                    slide.addClass("active-slide");
                }

                slide.addClass(o.clsSlide);

                that.slides.push(slide);
            });

            this.currentIndex = 0;
            this.current = this.slides[this.currentIndex];
        },

        _createControls: function(){
            var element = this.element, o = this.options;
            var next, prev;

            if (o.controls === false) {
                return ;
            }

            next = $('<span/>').addClass('carousel-switch-next').addClass(o.clsControls).addClass(o.clsControlNext).html(">");
            prev = $('<span/>').addClass('carousel-switch-prev').addClass(o.clsControls).addClass(o.clsControlPrev).html("<");

            if (o.controlNext) {
                next.html(o.controlNext);
            }

            if (o.controlPrev) {
                prev.html(o.controlPrev);
            }

            next.appendTo(element);
            prev.appendTo(element);
        },

        _createBullets: function(){
            var element = this.element, o = this.options;
            var bullets, i;

            if (o.bullets === false) {
                return ;
            }

            bullets = $('<div>').addClass("carousel-bullets").addClass(o.bulletsSize+"-size").addClass("bullet-style-"+o.bulletsStyle).addClass(o.clsBullets);
            if (o.bulletsPosition === 'default' || o.bulletsPosition === 'center') {
                bullets.addClass("flex-justify-center");
            } else if (o.bulletsPosition === 'left') {
                bullets.addClass("flex-justify-start");
            } else {
                bullets.addClass("flex-justify-end");
            }

            for (i = 0; i < this.slides.length; i++) {
                var bullet = $('<span>').addClass("carousel-bullet").addClass(o.clsBullet).data("slide", i);
                if (i === 0) {
                    bullet.addClass('bullet-on').addClass(o.clsBulletOn);
                }
                bullet.appendTo(bullets);
            }

            bullets.appendTo(element);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".carousel-bullet", function(){
                var bullet = $(this);
                if (that.isAnimate === false) {
                    that._slideToSlide(bullet.data('slide'));
                    that._fireEvent("bullet-click", {
                        bullet: bullet
                    });
                }
            });

            element.on(Metro.events.click, ".carousel-switch-next", function(){
                if (that.isAnimate === false) {
                    that._slideTo("next", false);
                    that._fireEvent("next-click", {
                        button: this
                    });
                }
            });

            element.on(Metro.events.click, ".carousel-switch-prev", function(){
                if (that.isAnimate === false) {
                    that._slideTo("prev", false);
                    that._fireEvent("prev-click", {
                        button: this
                    });
                }
            });

            if (o.stopOnMouse === true && o.autoStart === true) {
                element.on(Metro.events.enter, function () {
                    that._stop();
                    that._fireEvent("mouse-enter", {
                        element: element
                    }, false, true);
                });
                element.on(Metro.events.leave, function () {
                    that._start();
                    that._fireEvent("mouse-leave", {
                        element: element
                    }, false, true);
                });
            }

            if (o.controlsOnMouse === true) {
                element.on(Metro.events.enter, function () {
                    element.find("[class*=carousel-switch]").fadeIn();
                    element.find(".carousel-bullets").fadeIn();
                });
                element.on(Metro.events.leave, function () {
                    element.find("[class*=carousel-switch]").fadeOut();
                    element.find(".carousel-bullets").fadeOut();
                });
            }

            element.on(Metro.events.click, ".slide", function(){
                var slide = $(this);
                that._fireEvent("slide-click", {
                    slide: slide
                });
            });

            $(window).on(Metro.events.resize, function(){
                that._resize();
            }, {ns: this.id});
        },

        _slideToSlide: function(index){
            var element = this.element, o = this.options;
            var current, next, to;

            if (this.slides[index] === undefined) {
                return ;
            }

            if (this.currentIndex === index) {
                return ;
            }

            to = index > this.currentIndex ? "next" : "prev";
            current = this.slides[this.currentIndex];
            next = this.slides[index];

            this.currentIndex = index;

            this._effect(current, next, o.effect, to);

            element.find(".carousel-bullet").removeClass("bullet-on").removeClass(o.clsBulletOn);
            element.find(".carousel-bullet:nth-child("+(this.currentIndex+1)+")").addClass("bullet-on").addClass(o.clsBulletOn);
        },

        _slideTo: function(to, interval){
            var element = this.element, o = this.options;
            var current, next;

            if (to === undefined) {
                to = "next";
            }

            current = this.slides[this.currentIndex];

            if (to === "next") {
                this.currentIndex++;
                if (this.currentIndex >= this.slides.length) {
                    this.currentIndex = 0;
                }
            } else {
                this.currentIndex--;
                if (this.currentIndex < 0) {
                    this.currentIndex = this.slides.length - 1;
                }
            }

            next = this.slides[this.currentIndex];

            this._effect(current, next, o.effect, to, interval);

            element.find(".carousel-bullet").removeClass("bullet-on").removeClass(o.clsBulletOn);
            element.find(".carousel-bullet:nth-child("+(this.currentIndex+1)+")").addClass("bullet-on").addClass(o.clsBulletOn);
        },

        _effect: function(current, next, effect, to, interval){
            var that = this, o = this.options;
            var duration = o.duration;
            var func, effectFunc = o.effectFunc;
            var period = o.period;

            var run = function(f, c, n, o){
                Metro.animations[f](c, n, o);
            }

            if (next.data('duration') !== undefined) {
                duration = next.data('duration');
            }

            if (next.data('effectFunc') !== undefined) {
                effectFunc = next.data('effectFunc');
            }

            if (effect === 'switch') {
                duration = 0;
            }

            current.stop(true);
            next.stop(true);
            this.isAnimate = true;

            setTimeout(function(){that.isAnimate = false;}, duration + 100);

            if (effect === 'slide') {
                func = to === 'next' ? 'slideLeft': 'slideRight';
            } else
            if (effect === 'slide-v') {
                func = to === 'next' ? 'slideUp': 'slideDown';
            } else {
                func = effect;
            }

            if (!effects.includes(effect)) {
                func = "switch";
            }

            run(func, current, next, {duration: duration, ease: effectFunc});

            current.removeClass("active-slide");
            next.addClass("active-slide");

            setTimeout(function(){
                that._fireEvent("slide-show", {
                    current: next[0],
                    prev: current[0]
                })
            }, duration);

            setTimeout(function(){
                that._fireEvent("slide-hide", {
                    current: current[0],
                    next: next[0]
                })
            }, duration);

            if (interval === true) {

                if (next.data('period') !== undefined) {
                    period = next.data('period');
                }

                this.interval = setTimeout(function run() {
                    var t = o.direction === 'left' ? 'next' : 'prior';
                    that._slideTo(t, true);
                }, period);
            }
        },

        toSlide: function(index){
            this._slideToSlide(index);
        },

        next: function(){
            this._slideTo("next");
        },

        prev: function(){
            this._slideTo("prev");
        },

        stop: function () {
            clearInterval(this.interval);
            this._fireEvent("stop");
        },

        play: function(){
            this._start();
            this._fireEvent("play");
        },

        setEffect: function(effect){
            var element = this.element, o = this.options;
            var slides = element.find(".slide");

            if (!effects.includes(effect)) return ;

            o.effect = effect;

            slides.removeStyleProperty("transform").css({
                top: 0,
                left: 0
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName, newValue){
            if (attributeName === 'data-effect') {
                this.setEffect(newValue);
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            element.off(Metro.events.click, ".carousel-bullet");
            element.off(Metro.events.click, ".carousel-switch-next");
            element.off(Metro.events.click, ".carousel-switch-prev");

            if (o.stopOnMouse === true && o.autoStart === true) {
                element.off(Metro.events.enter);
                element.off(Metro.events.leave);
            }

            if (o.controlsOnMouse === true) {
                element.off(Metro.events.enter);
                element.off(Metro.events.leave);
            }

            element.off(Metro.events.click, ".slide");
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CharmsDefaultConfig = {
        charmsDeferred: 0,
        position: "right",
        opacity: 1,
        clsCharms: "",
        onCharmCreate: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onToggle: Metro.noop
    };

    Metro.charmsSetup = function (options) {
        CharmsDefaultConfig = $.extend({}, CharmsDefaultConfig, options);
    };

    if (typeof window["metroCharmsSetup"] !== undefined) {
        Metro.charmsSetup(window["metroCharmsSetup"]);
    }

    Metro.Component('charms', {
        init: function( options, elem ) {
            this._super(elem, options, CharmsDefaultConfig, {
                origin: {
                    background: ""
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("charm-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element
                .addClass("charms")
                .addClass(o.position + "-side")
                .addClass(o.clsCharms);

            this.origin.background = element.css("background-color");

            element.css({
                backgroundColor: Utils.computedRgbToRgba(Utils.getStyleOne(element, "background-color"), o.opacity)
            });
        },

        _createEvents: function(){
        },

        open: function(){
            var element = this.element;

            element.addClass("open");

            this._fireEvent("open");
        },

        close: function(){
            var element = this.element;

            element.removeClass("open");

            this._fireEvent("close");
        },

        toggle: function(){
            var element = this.element;

            if (element.hasClass("open") === true) {
                this.close();
            } else {
                this.open();
            }

            this._fireEvent("toggle");
        },

        opacity: function(v){
            var element = this.element, o = this.options;

            if (v === undefined) {
                return o.opacity;
            }

            var opacity = Math.abs(parseFloat(v));
            if (opacity < 0 || opacity > 1) {
                return ;
            }
            o.opacity = opacity;
            element.css({
                backgroundColor: Utils.computedRgbToRgba(Utils.getStyleOne(element, "background-color"), opacity)
            });
        },

        changeOpacity: function(){
            var element = this.element;
            this.opacity(element.attr("data-opacity"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-opacity": this.changeOpacity(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['charms'] = {
        check: function(el){
            if (Utils.isMetroObject(el, "charms") === false) {
                console.warn("Element is not a charms component");
                return false;
            }
            return true;
        },

        isOpen: function(el){
            if (this.check(el) === false) return ;
            return $(el).hasClass("open");
        },

        open: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").open();
        },

        close: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").close();
        },

        toggle: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").toggle();
        },

        closeAll: function(){
            $('[data-role*=charms]').each(function() {
                Metro.getPlugin(this, 'charms').close();
            });
        },

        opacity: function(el, opacity){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").opacity(opacity);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var defaultAvatar = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gOTAK/9sAQwADAgIDAgIDAwMDBAMDBAUIBQUEBAUKBwcGCAwKDAwLCgsLDQ4SEA0OEQ4LCxAWEBETFBUVFQwPFxgWFBgSFBUU/9sAQwEDBAQFBAUJBQUJFA0LDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU/8AAEQgAUABQAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+t+KKPxo/GgA70Yo/Gj8aADFH4VesdC1HUl3WtjcXCf344yV/PGKW+0HUtNXddWNzbp/fkjIX88YoAofhR+FH40fjQAfhR+FH40fjQAUUUUAFepeAPh5D9li1LVYhK8g3Q27j5VXszDuT6f5HA+FtOXVvEWn2rjMcko3j1UckfkDX0MBgYHAoARVCKFUBVHAA6ClZQwKkZBGCDS0UAec+Pvh3BJay6lpUQimjBeW3QYVx3Kjsfbv/PyqvpuvnvxfpqaT4l1C1QbY0lJUDsrfMB+RoAyKKKKACiiigDa8GXq6f4p02eQgIJQpJ7Bvlz+tfQP4V8yDg17P4A8cw65ZxWV5IE1KMbfmP+uA7j39R+NAHaUfhSUUAL+FeA+OL1NQ8WalNGQU83YCO+0Bf6V6b498cQ6BZyWlrIJNSkXaApz5QP8AEff0FeKk5OTyTQAUUUUAH40fjRU1naTX93DbQIXmlYIijuTQBc0Dw/eeI74W1mm49XkbhUHqTXsHhz4eaXoCpI8YvbscmaYZAP8Asr0H8/etHwv4cg8M6XHaxANIfmllxy7dz9PStigA/Gk/GlooA5bxJ8PdL19XkWMWd43PnwjGT/tL0P8AP3rx/X/D954cvjbXibT1SReVceoNfRFZHijw5B4m0uS1lAWQfNFLjlG7H6etAHz5+NH41NeWk1hdzW06FJonKMp7EGoaACvQfhBowudTudRkXK2y7I8j+Nup/Afzrz6vafhRaCDwmkgHM8zufwO3/wBloA7Kiij8KACkpaSgBaSj8KKAPJvi/owttTttRjXC3K7JMf3l6H8R/KvPq9p+K1qJ/CbyEcwTI4P1O3/2avFqAP/Z";
    var ChatDefaultConfig = {
        chatDeferred: 0,
        inputTimeFormat: "%m-%d-%y",
        timeFormat: "%d %b %l:%M %p",
        name: "John Doe",
        avatar: defaultAvatar,
        welcome: null,
        title: null,
        width: "100%",
        height: "auto",
        randomColor: false,
        messages: null,
        sendButtonTitle: "Send",
        readonly: false,

        clsChat: "",
        clsName: "",
        clsTime: "",
        clsInput: "",
        clsSendButton: "",
        clsMessageLeft: "default",
        clsMessageRight: "default",

        onMessage: Metro.noop,
        onSend: Metro.noop,
        onSendButtonClick: Metro.noop,
        onChatCreate: Metro.noop
    };

    Metro.chatSetup = function (options) {
        ChatDefaultConfig = $.extend({}, ChatDefaultConfig, options);
    };

    if (typeof window["metroChatSetup"] !== undefined) {
        Metro.chatSetup(window["metroChatSetup"]);
    }

    Metro.Component('chat', {
        init: function( options, elem ) {
            this._super(elem, options, ChatDefaultConfig, {
                input: null,
                classes: "primary secondary success alert warning yellow info dark light".split(" "),
                lastMessage: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("chat-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var messages, messageInput, input;
            var customButtons = [
                {
                    html: o.sendButtonTitle,
                    cls: o.clsSendButton+" js-chat-send-button",
                    onclick: o.onSendButtonClick
                }
            ];

            element.addClass("chat").addClass(o.clsChat);

            element.css({
                width: o.width,
                height: o.height
            });

            if (Utils.isValue(o.title)) {
                $("<div>").addClass("title").html(o.title).appendTo(element);
            }

            messages = $("<div>").addClass("messages");
            messages.appendTo(element);
            messageInput = $("<div>").addClass("message-input").appendTo(element);
            input = $("<input type='text'>");
            input.appendTo(messageInput);
            input.input({
                customButtons: customButtons,
                clsInput: o.clsInput
            });

            if (o.welcome) {
                this.add({
                    text: o.welcome,
                    time: (new Date()),
                    position: "left",
                    name: "Welcome",
                    avatar: defaultAvatar
                })
            }

            if (Utils.isValue(o.messages) && typeof o.messages === "string") {
                o.messages = Utils.isObject(o.messages);
            }

            if (!Utils.isNull(o.messages) && typeof o.messages === "object" && Utils.objectLength(o.messages) > 0) {
                $.each(o.messages, function(){
                    that.add(this);
                });
            }

            element.find(".message-input")[o.readonly ? 'addClass':'removeClass']("disabled");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var sendButton = element.find(".js-chat-send-button");
            var input = element.find("input[type=text]");

            var send = function(){
                var msg = ""+input.val(), m;
                if (msg.trim() === "") {return false;}
                m = {
                    id: Utils.elementId("chat-message"),
                    name: o.name,
                    avatar: o.avatar,
                    text: msg,
                    position: "right",
                    time: (new Date())
                };
                that.add(m);
                input.val("");
                that._fireEvent("send", {
                    msg: m
                });
            };

            sendButton.on(Metro.events.click, function () {
                send();
            });

            input.on(Metro.events.keyup, function(e){
                if (e.keyCode === Metro.keyCode.ENTER) {
                    send();
                }
            })
        },

        add: function(msg){
            var that = this, element = this.element, o = this.options;
            var index, message, sender, time, item, avatar, text;
            var messages = element.find(".messages");
            var messageDate;

            messageDate = typeof msg.time === 'string' ? msg.time.toDate(o.inputTimeFormat) : msg.time;

            message = $("<div>").addClass("message").addClass(msg.position).appendTo(messages);
            sender = $("<div>").addClass("message-sender").addClass(o.clsName).html(msg.name).appendTo(message);
            time = $("<div>").addClass("message-time").addClass(o.clsTime).html(messageDate.format(o.timeFormat)).appendTo(message);
            item = $("<div>").addClass("message-item").appendTo(message);
            avatar = $("<img>").attr("src", msg.avatar).addClass("message-avatar").appendTo(item);
            text = $("<div>").addClass("message-text").html(msg.text).appendTo(item);

            if (Utils.isValue(msg.id)) {
                message.attr("id", msg.id);
            }

            if (o.randomColor === true) {
                index = $.random(0, that.classes.length - 1);
                text.addClass(that.classes[index]);
            } else {
                if (msg.position === 'left' && Utils.isValue(o.clsMessageLeft)) {
                    text.addClass(o.clsMessageLeft);
                }
                if (msg.position === 'right' && Utils.isValue(o.clsMessageRight)) {
                    text.addClass(o.clsMessageRight);
                }
            }

            that._fireEvent("message", {
                msg: msg,
                el: {
                    message: message,
                    sender: sender,
                    time: time,
                    item: item,
                    avatar: avatar,
                    text: text
                }
            });

            messages.animate({
                draw: {
                    scrollTop: messages[0].scrollHeight
                },
                dur: 1000
            });

            this.lastMessage = msg;

            return this;
        },

        addMessages: function(messages){
            var that = this;

            if (Utils.isValue(messages) && typeof messages === "string") {
                messages = Utils.isObject(messages);
            }

            if (typeof messages === "object" && Utils.objectLength(messages) > 0) {
                $.each(messages, function(){
                    that.add(this);
                });
            }

            return this;
        },

        delMessage: function(id){
            var element = this.element;

            element.find(".messages").find("#"+id).remove();

            return this;
        },

        updMessage: function(msg){
            var element = this.element;
            var message = element.find(".messages").find("#"+msg.id);

            if (message.length === 0) return this;

            message.find(".message-text").html(msg.text);
            message.find(".message-time").html(msg.time);

            return this;
        },

        clear: function(){
            var element = this.element;
            var messages = element.find(".messages");
            messages.html("");
            this.lastMessage = null;
        },

        toggleReadonly: function(readonly){
            var element = this.element, o = this.options;
            o.readonly = typeof readonly === "undefined" ? !o.readonly : readonly;
            element.find(".message-input")[o.readonly ? 'addClass':'removeClass']("disabled");
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-readonly": this.toggleReadonly(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var sendButton = element.find(".js-chat-send-button");
            var input = element.find("input[type=text]");

            sendButton.off(Metro.events.click);
            input.off(Metro.events.keyup);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CheckboxDefaultConfig = {
        checkboxDeferred: 0,
        transition: true,
        style: 1,
        caption: "",
        captionPosition: "right",
        indeterminate: false,
        clsCheckbox: "",
        clsCheck: "",
        clsCaption: "",
        onCheckboxCreate: Metro.noop
    };

    Metro.checkboxSetup = function (options) {
        CheckboxDefaultConfig = $.extend({}, CheckboxDefaultConfig, options);
    };

    if (typeof window["metroCheckboxSetup"] !== undefined) {
        Metro.checkboxSetup(window["metroCheckboxSetup"]);
    }

    Metro.Component('checkbox', {
        init: function( options, elem ) {
            this._super(elem, options, CheckboxDefaultConfig, {
                origin: {
                    className: ""
                }
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();
            this._fireEvent("checkbox-create");
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var checkbox;
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "checkbox");

            if (element.attr("readonly") !== undefined) {
                element.on("click", function(e){
                    e.preventDefault();
                })
            }

            checkbox = element
                .wrap("<label>")
                .addClass("checkbox " + element[0].className)
                .addClass(o.style === 2 ? "style2" : "");

            check.appendTo(checkbox);
            caption.appendTo(checkbox);

            if (o.transition === true) {
                checkbox.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                checkbox.addClass("caption-left");
            }

            this.origin.className = element[0].className;
            element[0].className = '';

            checkbox.addClass(o.clsCheckbox);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (o.indeterminate) {
                element[0].indeterminate = true;
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var element = this.element, check = element.siblings(".check");

            element.on("focus", function(){
                check.addClass("focused");
            });

            element.on("blur", function(){
                check.removeClass("focused");
            });
        },

        indeterminate: function(v){
            var element = this.element;

            v = Utils.isNull(v) ? true : Utils.bool(v);

            element[0].indeterminate = v;
            element.attr("data-indeterminate", v);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggle: function(v){
            var element = this.element;

            this.indeterminate(false);

            if (!Utils.isValue(v)) {
                element.prop("checked", !Utils.bool(element.prop("checked")));
            } else {
                if (v === -1) {
                    this.indeterminate(true);
                } else {
                    element.prop("checked", v === 1);
                }
            }
            return this;
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var parent = element.parent();

            var changeStyle = function(){
                var new_style = parseInt(element.attr("data-style"));

                if (!Utils.isInt(new_style)) return;

                o.style = new_style;
                parent.removeClass("style1 style2").addClass("style"+new_style);
            };

            var indeterminateState = function(){
                element[0].indeterminate = JSON.parse(element.attr("data-indeterminate")) === true;
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-indeterminate': indeterminateState(); break;
                case 'data-style': changeStyle(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            element.off("focus");
            element.off("blur");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ClockDefaultConfig = {
        clockDeferred: 0,
        showTime: true,
        showDate: true,
        timeFormat: '24',
        dateFormat: 'american',
        divider: "&nbsp;&nbsp;",
        leadingZero: true,
        dateDivider: '-',
        timeDivider: ":",
        onTick: Metro.noop,
        onSecond: Metro.noop,
        onClockCreate: Metro.noop
    };

    Metro.clockSetup = function (options) {
        ClockDefaultConfig = $.extend({}, ClockDefaultConfig, options);
    };

    if (typeof window["metroClockSetup"] !== undefined) {
        Metro.clockSetup(window["metroClockSetup"]);
    }

    Metro.Component('clock', {
        init: function( options, elem ) {
            this._super(elem, options, ClockDefaultConfig, {
                _clockInterval: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._fireEvent('clock-create', {
                element: element
            });

            this._tick();

            this._clockInterval = setInterval(function(){
                that._tick();
            }, 500);
            this._secondInterval = setInterval(function(){
                that._second();
            }, 1000);
        },

        _addLeadingZero: function(i){
            if (i<10){i="0" + i;}
            return i;
        },

        _second: function(){
            var timestamp = new Date();

            this._fireEvent('second', {
                timestamp: timestamp
            })
        },

        _tick: function(){
            var element = this.element, o = this.options;
            var timestamp = new Date();
            var result = "";
            var h = timestamp.getHours(),
                i = timestamp.getMinutes(),
                s = timestamp.getSeconds(),
                d = timestamp.getDate(),
                m = timestamp.getMonth() + 1,
                y = timestamp.getFullYear(),
                a = '';

            if (parseInt(o.timeFormat) === 12) {
                a = " AM";
                if (h > 11) { a = " PM"; }
                if (h > 12) { h = h - 12; }
                if (h === 0) { h = 12; }
            }

            i = this._addLeadingZero(i);
            s = this._addLeadingZero(s);

            if (o.leadingZero) {
                h = this._addLeadingZero(h);
                m = this._addLeadingZero(m);
                d = this._addLeadingZero(d);
            }

            if (o.showDate) {
                if (o.dateFormat === 'american') {
                    result += "<span class='date-month'>" + m + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-day'>" + d + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-year'>" + y + "</span>";
                } else {
                    result += "<span class='date-day'>" + d + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-month'>" + m + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-year'>" + y + "</span>";
                }
                result += o.divider;
            }

            if (o.showTime) {
                result += "<span class='clock-hour'>" + h + "</span>";
                result += "<span class='clock-divider'>" + o.timeDivider + "</span>";
                result += "<span class='clock-minute'>" + i + "</span>";
                result += "<span class='clock-divider'>" + o.timeDivider + "</span>";
                result += "<span class='clock-second'>" + s + "</span>";
                result += "<span class='clock-suffix'>" + a + "</span>";
            }

            element.html(result);

            this._fireEvent('tick', {
                timestamp: timestamp
            })
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            clearInterval(this._clockInterval);
            this._clockInterval = null;
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var CollapseDefaultConfig = {
        collapseDeferred: 0,
        collapsed: false,
        toggleElement: false,
        duration: 100,
        onExpand: Metro.noop,
        onCollapse: Metro.noop,
        onCollapseCreate: Metro.noop
    };

    Metro.collapseSetup = function (options) {
        CollapseDefaultConfig = $.extend({}, CollapseDefaultConfig, options);
    };

    if (typeof window["metroCollapseSetup"] !== undefined) {
        Metro.collapseSetup(window["metroCollapseSetup"]);
    }

    Metro.Component('collapse', {
        init: function( options, elem ) {
            this._super(elem, options, CollapseDefaultConfig, {
                toggle: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var toggle;

            toggle = o.toggleElement !== false ? $(o.toggleElement) : element.siblings('.collapse-toggle').length > 0 ? element.siblings('.collapse-toggle') : element.siblings('a:nth-child(1)');

            if (o.collapsed === true || element.attr("collapsed") === true) {
                element.hide(0);
            }

            toggle.on(Metro.events.click, function(e){
                if (element.css('display') === 'block' && !element.hasClass('keep-open')) {
                    that._close(element);
                } else {
                    that._open(element);
                }

                if (["INPUT"].indexOf(e.target.tagName) === -1) {
                    e.preventDefault();
                }
                e.stopPropagation();
            });

            this.toggle = toggle;

            this._fireEvent("collapse-create", {
                element: element
            });
        },

        _close: function(el, immediate){
            var elem = $(el);
            var dropdown  = Metro.getPlugin(elem[0], "collapse");
            var options = dropdown.options;
            var func = immediate ? 'show' : 'slideUp';
            var dur = immediate ? 0 : options.duration;

            this.toggle.removeClass("active-toggle");

            elem[func](dur, function(){
                el.trigger("onCollapse", null, el);
                el.data("collapsed", true);
                el.addClass("collapsed");

                dropdown._fireEvent("collapse");
            });
        },

        _open: function(el, immediate){
            var elem = $(el);
            var dropdown  = Metro.getPlugin(elem[0], "collapse");
            var options = dropdown.options;
            var func = immediate ? 'show' : 'slideDown';
            var dur = immediate ? 0 : options.duration;

            this.toggle.addClass("active-toggle");

            elem[func](dur, function(){
                el.trigger("onExpand", null, el);
                el.data("collapsed", false);
                el.removeClass("collapsed");

                dropdown._fireEvent("expand");
            });
        },

        collapse: function(immediate){
            this._close(this.element, immediate);
        },

        expand: function(immediate){
            this._open(this.element, immediate);
        },

        close: function(immediate){
            this._close(this.element, immediate);
        },

        open: function(immediate){
            this._open(this.element, immediate);
        },

        isCollapsed: function(){
            return this.element.data("collapsed");
        },

        toggleState: function(){
            var element = this.element;
            if (element.attr("collapsed") === true || element.data("collapsed") === true) {
                this.collapse();
            } else {
                this.expand();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "collapsed":
                case "data-collapsed": this.toggleState(); break;
            }
        },

        destroy: function(){
            this.toggle.off(Metro.events.click);
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var cookieDisclaimerDefaults = {
        name: 'cookies_accepted',
        template: null,
        templateSource: null,
        acceptButton: '.cookie-accept-button',
        cancelButton: '.cookie-cancel-button',
        message: 'Our website uses cookies to monitor traffic on our website and ensure that we can provide our customers with the best online experience possible.',
        duration: "30days",
        clsContainer: "",
        clsMessage: "",
        clsButtons: "",
        clsAcceptButton: "alert",
        clsCancelButton: "",
        onAccept: Metro.noop,
        onDecline: Metro.noop
    };

    Metro.cookieDisclaimer = {
        init: function(options){
            var that = this, cookie = Metro.cookie;

            this.options = $.extend({}, cookieDisclaimerDefaults, options);
            this.disclaimer = $("<div>");

            if (cookie.getCookie(this.options.name)) {
                return ;
            }

            if (this.options.template) {
                $.get(this.options.template).then(function(response){
                    that.create(response);
                });
            } else if (this.options.templateSource) {
                this.create($(this.options.templateSource));
            } else {
                this.create();
            }
        },

        create: function(html){
            var cookie = Metro.cookie;
            var o = this.options, wrapper = this.disclaimer, buttons;

            wrapper
                .addClass("cookie-disclaimer-block")
                .addClass(o.clsContainer);

            if (!html) {
                buttons = $("<div>")
                    .addClass("cookie-disclaimer-actions")
                    .addClass(o.clsButtons)
                    .append( $('<button>').addClass('button cookie-accept-button').addClass(o.clsAcceptButton).html('Accept') )
                    .append( $('<button>').addClass('button cookie-cancel-button').addClass(o.clsCancelButton).html('Cancel') );

                wrapper
                    .html( $("<div>").addClass(o.clsMessage).html(o.message) )
                    .append( $("<hr>").addClass('thin') )
                    .append(buttons);

            } else if (html instanceof $) {
                wrapper.append(html);
            } else {
                wrapper.html(html);
            }

            wrapper.appendTo($('body'));

            wrapper.on(Metro.events.click, o.acceptButton, function(){
                var dur = 0;
                var durations = (""+o.duration).toArray(" ");

                $.each(durations, function(){
                    var d = ""+this;
                    if (d.includes("day")) {
                        dur += parseInt(d)*24*60*60*1000;
                    } else
                    if (d.includes("hour")) {
                        dur += parseInt(d)*60*60*1000;
                    } else
                    if (d.includes("min")) {
                        dur += parseInt(d)*60*1000;
                    } else
                    if (d.includes("sec")) {
                        dur += parseInt(d)*1000;
                    } else {
                        dur += parseInt(d);
                    }
                })

                cookie.setCookie(o.name, true, dur);
                Utils.exec(o.onAccept);
                wrapper.remove();
            });

            wrapper.on(Metro.events.click, o.cancelButton, function(){
                Utils.exec(o.onDecline);
                wrapper.remove();
            });
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var CookieDefaultConfig = {
        path: "/",
        expires: null,
        maxAge: null,
        domain: null,
        secure: false,
        samesite: null
    }

    Metro.cookieSetup = function (options) {
        CookieDefaultConfig = $.extend({}, CookieDefaultConfig, options);
    };

    if (typeof window["metroCookieSetup"] !== undefined) {
        Metro.cookieSetup(window["metroCookieSetup"]);
    }

    Metro.cookie = {
        getCookies: function(){
            var a = document.cookie.toArray(";");
            var o = {};
            $.each(a, function(){
                var i = this.split('=');
                o[i[0]] = i[1];
            });
            return o;
        },

        getCookie: function(name){
            var cookieName = encodeURIComponent(name) + "=";
            var cookies = document.cookie.toArray(";");
            var i, cookie;

            for(i = 0; i < cookies.length; i++) {
                cookie = cookies[i];
                while (cookie.charAt(0) === ' ') {
                    cookie = cookie.substring(1, cookie.length);
                }
                if (cookie.indexOf(cookieName) === 0) {
                    return decodeURIComponent(cookie.substring(cookieName.length, cookie.length));
                }
            }
            return null;
        },

        setCookie: function(name, value, options){
            var date;
            var cookieName = encodeURIComponent(name);
            var cookieValue = encodeURIComponent(value);
            var opt, a = [];

            if (options && typeof options !== "object") {
                date = new Date();
                date.setTime(date.getTime()+(parseInt(options)));
                opt = $.extend({}, CookieDefaultConfig, {
                    expires: date.toUTCString()
                });
            } else {
                opt = $.extend({}, CookieDefaultConfig, options);
            }

            $.each(opt, function(key, val){
                if (key !== 'secure' && val) {
                    a.push($.dashedName(key) + "=" + val);
                }
                if (key === 'secure' && val === true) {
                    a.push( "secure" );
                }
            });

            document.cookie = cookieName + '=' + cookieValue + "; " +  a.join("; ");
        },

        delCookie: function(name){
            this.setCookie(name, false, {
                maxAge: -1
            });
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CountdownDefaultConfig = {
        countdownDeferred: 0,
        stopOnBlur: true,
        animate: "none",
        animationFunc: "linear",
        inputFormat: null,
        locale: METRO_LOCALE,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        date: null,
        start: true,
        clsCountdown: "",
        clsPart: "",
        clsZero: "",
        clsAlarm: "",
        clsDays: "",
        clsHours: "",
        clsMinutes: "",
        clsSeconds: "",
        onAlarm: Metro.noop,
        onTick: Metro.noop,
        onZero: Metro.noop,
        onBlink: Metro.noop,
        onCountdownCreate: Metro.noop
    };

    Metro.countdownSetup = function (options) {
        CountdownDefaultConfig = $.extend({}, CountdownDefaultConfig, options);
    };

    if (typeof window["metroCountdownSetup"] !== undefined) {
        Metro.countdownSetup(window["metroCountdownSetup"]);
    }

    Metro.Component('countdown', {
        init: function( options, elem ) {
            this._super(elem, options, CountdownDefaultConfig, {
                locale: Metro.locales["en-US"],
                breakpoint: (new Date()).getTime(),
                blinkInterval: null,
                tickInterval: null,
                zeroDaysFired: false,
                zeroHoursFired: false,
                zeroMinutesFired: false,
                zeroSecondsFired: false,
                fontSize: parseInt(Utils.getStyleOne(elem, "font-size")),
                current: {
                    d: 0, h: 0, m: 0, s: 0
                },
                inactiveTab: false,
                id: Utils.elementId("countdown")
            });

            return this;
        },

        _create: function(){
            var o = this.options;

            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];

            this._build();
            this._createEvents();
        },

        _setBreakpoint: function(){
            var o = this.options;
            var dm = 86400000, hm = 3600000, mm = 60000, sm = 1000;

            this.breakpoint = (new Date()).getTime();

            if (Utils.isValue(o.date) && Utils.isDate(o.date, o.inputFormat)) {
                this.breakpoint = Utils.isValue(o.inputFormat) ? (o.date.toDate(o.inputFormat)).getTime() : (new Date(o.date)).getTime();
            }

            if (parseInt(o.days) > 0) {
                this.breakpoint += parseInt(o.days) * dm;
            }
            if (parseInt(o.hours) > 0) {
                this.breakpoint += parseInt(o.hours) * hm;
            }
            if (parseInt(o.minutes) > 0) {
                this.breakpoint += parseInt(o.minutes) * mm;
            }
            if (parseInt(o.seconds) > 0) {
                this.breakpoint += parseInt(o.seconds) * sm;
            }
        },

        _build: function(){
            var that = this, element = this.element, o = this.options;
            var parts = ["days", "hours", "minutes", "seconds"];
            var dm = 24*60*60*1000;
            var delta_days;
            var now = (new Date()).getTime();
            var digit;

            if (!element.attr("id")) {
                element.attr("id", Utils.elementId("countdown"));
            }

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("countdown"));
            }

            element.addClass("countdown").addClass(o.clsCountdown);

            this._setBreakpoint();

            delta_days = Math.round((that.breakpoint - now) / dm);

            $.each(parts, function(){
                var part = $("<div>").addClass("part " + this).addClass(o.clsPart).attr("data-label", that.locale["calendar"]["time"][this]).appendTo(element);

                if (this === "days") {part.addClass(o.clsDays);}
                if (this === "hours") {part.addClass(o.clsHours);}
                if (this === "minutes") {part.addClass(o.clsMinutes);}
                if (this === "seconds") {part.addClass(o.clsSeconds);}

                $("<div>").addClass("digit").appendTo(part);
                $("<div>").addClass("digit").appendTo(part);

                if (this === "days" && delta_days >= 100) {

                    for(var i = 0; i < String(Math.round(delta_days/100)).length; i++) {
                        $("<div>").addClass("digit").appendTo(part);
                    }
                }

            });

            digit = element.find(".digit");
            digit.append($("<span class='digit-placeholder'>").html("0"));
            digit.append($("<span class='digit-value'>").html("0"));

            this._fireEvent("countdown-create", {
                element: element
            })

            if (o.start === true) {
                this.start();
            } else {
                this.tick();
            }
        },

        _createEvents: function(){
            var that = this;
            $(document).on("visibilitychange", function() {
                if (document.hidden) {
                    that.pause();
                } else {
                    that.resume();
                }
            }, {ns: this.id});
        },

        blink: function(){
            var element = this.element;
            element.toggleClass("blink");

            this._fireEvent("blink", {
                time: this.current
            });
        },

        tick: function(){
            var element = this.element, o = this.options;
            var dm = 24*60*60, hm = 60*60, mm = 60, sm = 1;
            var left, now = (new Date()).getTime();
            var d, h, m, s;
            var days = element.find(".days"),
                hours = element.find(".hours"),
                minutes = element.find(".minutes"),
                seconds = element.find(".seconds");

            left = Math.floor((this.breakpoint - now)/1000);

            if (left <= -1) {
                this.stop();
                element.addClass(o.clsAlarm);

                this._fireEvent("alarm", {
                    time: now
                });

                return ;
            }

            d = Math.floor(left / dm);

            left -= d * dm;
            if (this.current.d !== d) {
                this.current.d = d;
                this.draw("days", d);
            }

            if (d === 0) {
                if (this.zeroDaysFired === false) {
                    this.zeroDaysFired = true;
                    days.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "days",
                        value: days
                    });
                }
            }

            h = Math.floor(left / hm);
            left -= h*hm;
            if (this.current.h !== h) {
                this.current.h = h;
                this.draw("hours", h);
            }

            if (d === 0 && h === 0) {
                if (this.zeroHoursFired === false) {
                    this.zeroHoursFired = true;
                    hours.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "hours",
                        value: hours
                    });
                }
            }

            m = Math.floor(left / mm);
            left -= m*mm;
            if (this.current.m !== m) {
                this.current.m = m;
                this.draw("minutes", m);
            }

            if (d === 0 && h === 0 && m === 0) {
                if (this.zeroMinutesFired === false) {
                    this.zeroMinutesFired = true;
                    minutes.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "minutes",
                        value: minutes
                    });

                }
            }

            s = Math.floor(left / sm);
            if (this.current.s !== s) {
                this.current.s = s;
                this.draw("seconds", s);
            }

            if (d === 0 && h === 0 && m === 0 && s === 0) {
                if (this.zeroSecondsFired === false) {
                    this.zeroSecondsFired = true;
                    seconds.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "seconds",
                        value: seconds
                    });

                }
            }

            this._fireEvent("tick", {
                days: d,
                hours: h,
                minutes: m,
                seconds: s
            });
        },

        draw: function(part, value){
            var element = this.element, o = this.options;
            var digits, digits_length, digit_value, digit_current, digit;
            var len, i, duration = 900;

            var slideDigit = function(digit, value){
                var digit_copy, height = digit.height();

                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    top: -1 * height + 'px'
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            top: height,
                            opacity: 0
                        },
                        dur: duration,
                        ease: o.animationFunc,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            top: 0,
                            opacity: 1
                        },
                        dur: duration,
                        ease: o.animationFunc
                    });
            };

            var fadeDigit = function(digit, value){
                var digit_copy;
                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    opacity: 0
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            opacity: 0
                        },
                        dur: duration / 2,
                        ease: o.animationFunc,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            opacity: 1
                        },
                        dur: duration,
                        ease: o.animationFunc
                    });
            };

            var zoomDigit = function(digit, value) {
                var digit_copy, height = digit.height(), fs = parseInt(digit.style("font-size"));

                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    top: 0,
                    left: 0,
                    opacity: 1
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            top: height,
                            opacity: 0,
                            fontSize: 0
                        },
                        dur: duration,
                        ease: o.animationFunc,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            top: 0,
                            opacity: 1,
                            fontSize: [0, fs]
                        },
                        dur: duration,
                        ease: o.animationFunc
                    });
            };

            value = ""+value;

            if (value.length === 1) {
                value = '0'+value;
            }

            len = value.length;

            digits = element.find("."+part+" .digit:not(-old-digit)");
            digits_length = digits.length;

            for(i = 0; i < len; i++){
                digit = digits.eq(digits_length - 1).find(".digit-value");
                digit_value = Math.floor( parseInt(value) / Math.pow(10, i) ) % 10;
                digit_current = parseInt(digit.text());

                digits_length--;

                if (digit_current === digit_value) {
                    continue;
                }

                switch ((""+o.animate).toLowerCase()) {
                    case "slide": slideDigit(digit, digit_value); break;
                    case "fade": fadeDigit(digit, digit_value); break;
                    case "zoom": zoomDigit(digit, digit_value); break;
                    default: digit.html(digit_value);
                }
            }
        },

        start: function(){
            var that = this, element = this.element;

            if (element.data("paused") === false) {
                return;
            }

            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            element.data("paused", false);

            this._setBreakpoint();
            this.tick();

            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        stop: function(){
            var element = this.element;
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);
            element.data("paused", true);
            element.find(".digit").html("0");
            this.current = {
                d: 0, h:0, m: 0, s:0
            };
        },

        pause: function(){
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);
            this.element.data("paused", true);
        },

        resume: function(){
            var that = this;

            this.element.data("paused", false);
            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        reset: function(){
            var that = this, element = this.element, o = this.options;

            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            element.find(".part").removeClass(o.clsZero);
            element.find(".digit").html("0");

            this._setBreakpoint();

            element.data("paused", false);

            this.tick();

            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        togglePlay: function(){
            if (this.element.attr("data-pause") === true) {
                this.pause();
            } else {
                this.start();
            }
        },

        isPaused: function(){
            return this.element.data("paused");
        },

        getBreakpoint: function(asDate){
            return asDate === true ? new Date(this.breakpoint) : this.breakpoint;
        },

        getLeft: function(){
            var dm = 24*60*60*1000, hm = 60*60*1000, mm = 60*1000, sm = 1000;
            var now = (new Date()).getTime();
            var left_seconds = Math.floor(this.breakpoint - now);
            return {
                days: Math.round(left_seconds / dm),
                hours: Math.round(left_seconds / hm),
                minutes: Math.round(left_seconds / mm),
                seconds: Math.round(left_seconds / sm)
            };
        },

        i18n: function(val){
            var that = this, element = this.element, o = this.options;
            var parts = ["days", "hours", "minutes", "seconds"];


            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }
            o.locale = val;
            this.locale = Metro.locales[o.locale];

            $.each(parts, function(){
                var cls = ".part." + this;
                var part = element.find(cls);
                part.attr("data-label", that.locale["calendar"]["time"][this]);
            });
        },

        changeAttrLocale: function(){
            var element = this.element;
            var locale = element.attr('data-locale');
            this.i18n(locale);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-pause": this.togglePlay(); break;
                case "data-locale": this.changeAttrLocale(); break;
            }
        },

        destroy: function(){
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            $(document).off("visibilitychange", {ns: this.id});

            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DatePickerDefaultConfig = {
        label: "",
        datepickerDeferred: 0,
        gmt: 0,
        format: "%Y-%m-%d",
        inputFormat: null,
        locale: METRO_LOCALE,
        value: null,
        distance: 3,
        month: true,
        day: true,
        year: true,
        minYear: null,
        maxYear: null,
        scrollSpeed: 4,
        copyInlineStyles: false,
        clsPicker: "",
        clsPart: "",
        clsMonth: "",
        clsDay: "",
        clsYear: "",
        clsLabel: "",
        okButtonIcon: "<span class='default-icon-check'></span>",
        cancelButtonIcon: "<span class='default-icon-cross'></span>",
        onSet: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onScroll: Metro.noop,
        onDatePickerCreate: Metro.noop
    };

    Metro.datePickerSetup = function (options) {
        DatePickerDefaultConfig = $.extend({}, DatePickerDefaultConfig, options);
    };

    if (typeof window["metroDatePickerSetup"] !== undefined) {
        Metro.datePickerSetup(window["metroDatePickerSetup"]);
    }

    Metro.Component('date-picker', {
        init: function( options, elem ) {
            this._super(elem, options, DatePickerDefaultConfig, {
                picker: null,
                isOpen: false,
                value: new Date(),
                locale: null,
                offset: (new Date()).getTimezoneOffset() / 60 + 1,
                listTimer: {
                    day: null,
                    month: null,
                    year: null
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (o.distance < 1) {
                o.distance = 1;
            }

            if (Utils.isValue(element.val())) {
                o.value = element.val();
            }

            if (Utils.isValue(o.value)) {
                if (Utils.isValue(o.inputFormat)) {
                    this.value = (""+o.value).toDate(o.inputFormat);
                } else {
                    if (Utils.isDate(o.value)) {
                        this.value = new Date(o.value);
                    }
                }
            }

            if (Metro.locales[o.locale] === undefined) {
                o.locale = METRO_LOCALE;
            }

            this.locale = Metro.locales[o.locale]['calendar'];

            if (o.minYear === null) {
                o.minYear = (new Date()).getFullYear() - 100;
            }

            if (o.maxYear === null) {
                o.maxYear = (new Date()).getFullYear() + 100;
            }

            this._createStructure();
            this._createEvents();
            this._set();

            this._fireEvent("datepicker-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var picker, month, day, year, i, j;
            var dateWrapper, selectWrapper, selectBlock, actionBlock;

            var id = Utils.elementId("datepicker");

            picker = $("<div>").attr("id", id).addClass("wheel-picker date-picker " + element[0].className).addClass(o.clsPicker);

            picker.insertBefore(element);
            element.appendTo(picker);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(picker);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            dateWrapper = $("<div>").addClass("date-wrapper").appendTo(picker);

            if (o.month === true) {
                month = $("<div>").addClass("month").addClass(o.clsPart).addClass(o.clsMonth).appendTo(dateWrapper);
            }
            if (o.day === true) {
                day = $("<div>").addClass("day").addClass(o.clsPart).addClass(o.clsDay).appendTo(dateWrapper);
            }
            if (o.year === true) {
                year = $("<div>").addClass("year").addClass(o.clsPart).addClass(o.clsYear).appendTo(dateWrapper);
            }

            selectWrapper = $("<div>").addClass("select-wrapper").appendTo(picker);

            selectBlock = $("<div>").addClass("select-block").appendTo(selectWrapper);

            if (o.month === true) {
                month = $("<ul>").addClass("sel-month").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
                for (i = 0; i < 12; i++) {
                    $("<li>").addClass("js-month-"+i+" js-month-real-"+this.locale['months'][i].toLowerCase()).html(this.locale['months'][i]).data("value", i).appendTo(month);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
            }

            if (o.day === true) {
                day = $("<ul>").addClass("sel-day").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(day);
                for (i = 0; i < 31; i++) {
                    $("<li>").addClass("js-day-"+i+" js-day-real-"+(i+1)).html(i + 1).data("value", i + 1).appendTo(day);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(day);
            }

            if (o.year === true) {
                year = $("<ul>").addClass("sel-year").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(year);
                for (i = o.minYear, j = 0; i <= o.maxYear; i++, j++) {
                    $("<li>").addClass("js-year-"+ j + " js-year-real-" + i).html(i).data("value", i).appendTo(year);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(year);
            }

            selectBlock.height((o.distance * 2 + 1) * 40);

            actionBlock = $("<div>").addClass("action-block").appendTo(selectWrapper);
            $("<button>").attr("type", "button").addClass("button action-ok").html(o.okButtonIcon).appendTo(actionBlock);
            $("<button>").attr("type", "button").addClass("button action-cancel").html(o.cancelButtonIcon).appendTo(actionBlock);


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    picker.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.prop("disabled")) {
                picker.addClass("disabled");
            }

            this.picker = picker;
        },

        _createEvents: function(){
            var that = this, o = this.options;
            var picker = this.picker;

            picker.on(Metro.events.start, ".select-block ul", function(e){

                if (e.changedTouches) {
                    return ;
                }

                var target = this;
                var pageY = Utils.pageXY(e).y;

                $(document).on(Metro.events.move, function(e){

                    target.scrollTop -= o.scrollSpeed * (pageY  > Utils.pageXY(e).y ? -1 : 1);

                    pageY = Utils.pageXY(e).y;
                }, {ns: picker.attr("id")});

                $(document).on(Metro.events.stop, function(){
                    $(document).off(Metro.events.move, {ns: picker.attr("id")});
                    $(document).off(Metro.events.stop, {ns: picker.attr("id")});
                }, {ns: picker.attr("id")});
            });

            picker.on(Metro.events.click, function(e){
                if (that.isOpen === false) that.open();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-ok", function(e){
                var m, d, y;
                var sm = picker.find(".sel-month li.active"),
                    sd = picker.find(".sel-day li.active"),
                    sy = picker.find(".sel-year li.active");

                m = sm.length === 0 ? that.value.getMonth() : sm.data("value");
                d = sd.length === 0 ? that.value.getDate() : sd.data("value");
                y = sy.length === 0 ? that.value.getFullYear() : sy.data("value");

                that.value = new Date(y, m, d);
                that._correct();
                that._set();

                that.close();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-cancel", function(e){
                that.close();
                e.stopPropagation();
            });

            var scrollLatency = 150;
            $.each(["month", "day", "year"], function(){
                var part = this, list = picker.find(".sel-"+part);

                list.on("scroll", function(){
                    if (that.isOpen) {
                        if (that.listTimer[part]) {
                            clearTimeout(that.listTimer[part]);
                            that.listTimer[part] = null;
                        }

                        if (!that.listTimer[part]) that.listTimer[part] = setTimeout(function () {

                            var target, targetElement, scrollTop;

                            that.listTimer[part] = null;

                            target = Math.round((Math.ceil(list.scrollTop()) / 40));

                            targetElement = list.find(".js-" + part + "-" + target);
                            scrollTop = targetElement.position().top - (o.distance * 40);

                            list.find(".active").removeClass("active");

                            list[0].scrollTop = scrollTop;
                            targetElement.addClass("active");
                            Utils.exec(o.onScroll, [targetElement, list, picker], list[0]);

                        }, scrollLatency);
                    }
                })
            });
        },

        _correct: function(){
            var m = this.value.getMonth(),
                d = this.value.getDate(),
                y = this.value.getFullYear();

            this.value = new Date(y, m, d);
        },

        _set: function(){
            var element = this.element, o = this.options;
            var picker = this.picker;
            var m = this.locale['months'][this.value.getMonth()],
                d = this.value.getDate(),
                y = this.value.getFullYear();

            if (o.month === true) {
                picker.find(".month").html(m);
            }
            if (o.day === true) {
                picker.find(".day").html(d);
            }
            if (o.year === true) {
                picker.find(".year").html(y);
            }

            element.val(this.value.format(o.format, o.locale)).trigger("change");

            this._fireEvent("set", {
                value: this.value,
                elementValue: element.val(),
                picker: picker
            })
        },

        open: function(){
            var o = this.options;
            var picker = this.picker;
            var m = this.value.getMonth(), d = this.value.getDate() - 1, y = this.value.getFullYear();
            var m_list, d_list, y_list;
            var select_wrapper = picker.find(".select-wrapper");
            var select_wrapper_in_viewport, select_wrapper_rect;

            select_wrapper.parent().removeClass("for-top for-bottom");
            select_wrapper.show(0);
            picker.find("li").removeClass("active");

            select_wrapper_in_viewport = Utils.inViewport(select_wrapper[0]);
            select_wrapper_rect = Utils.rect(select_wrapper[0]);

            if (!select_wrapper_in_viewport && select_wrapper_rect.top > 0) {
                select_wrapper.parent().addClass("for-bottom");
            }

            if (!select_wrapper_in_viewport && select_wrapper_rect.top < 0) {
                select_wrapper.parent().addClass("for-top");
            }

            if (o.month === true) {
                m_list = picker.find(".sel-month");
                m_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: m_list.find("li.js-month-" + m).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }
            if (o.day === true) {
                d_list = picker.find(".sel-day");
                d_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: d_list.find("li.js-day-" + d).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }
            if (o.year === true) {
                y_list = picker.find(".sel-year");
                y_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: y_list.find("li.js-year-real-" + y).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }

            this.isOpen = true;

            this._fireEvent("open", {
                value: this.value,
                picker: picker
            })

        },

        close: function(){
            var picker = this.picker;
            picker.find(".select-wrapper").hide(0);
            this.isOpen = false;

            this._fireEvent("close", {
                value: this.value,
                picker: picker
            });
        },

        val: function(value){
            var o = this.options;

            if (!Utils.isValue(value)) {
                return this.element.val();
            }

            if (Utils.isValue(o.inputFormat)) {
                this.value = (""+value).toDate(o.inputFormat);
            } else {
                this.value = new Date(value);
            }

            // this.value = (new Date(t)).addHours(this.offset);
            this._set();
        },

        date: function(t){
            if (t === undefined) {
                return this.value;
            }

            try {
                this.value = new Date(t.format("%Y-%m-%d"));
                this._set();
            } catch (e) {
                return false;
            }
        },

        i18n: function(locale){
            var element = this.element, o = this.options;
            var month, i;

            o.locale = locale ? locale : element.attr("data-locale");
            this.locale = Metro.locales[o.locale]['calendar'];

            if (o.month === true) {
                month =  element.closest(".date-picker").find(".sel-month").html("");
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
                for (i = 0; i < 12; i++) {
                    $("<li>").addClass("js-month-"+i+" js-month-real-"+this.locale['months'][i].toLowerCase()).html(this.locale['months'][i]).data("value", i).appendTo(month);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
            }

            this._set();
        },


        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName, newValue){
            switch (attributeName) {
                case "disabled": this.toggleState(); break;
                case "data-value": this.val(newValue); break;
                case "data-locale": this.i18n(newValue); break;
                case "data-format":
                    this.options.format = newValue;
                    this._set();
                    break;
            }
        },

        destroy: function(){
            var element = this.element, picker = this.picker;

            $.each(["moth", "day", "year"], function(){
                picker.find(".sel-"+this).off("scroll");
            });

            picker.off(Metro.events.start, ".select-block ul");
            picker.off(Metro.events.click);
            picker.off(Metro.events.click, ".action-ok");
            picker.off(Metro.events.click, ".action-cancel");

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $.each($(".date-picker"), function(){
            $(this).find("input").each(function(){
                Metro.getPlugin(this, "datepicker").close();
            });
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DialogDefaultConfig = {
        dialogDeferred: 0,
        closeButton: false,
        leaveOverlayOnClose: false,
        toTop: false,
        toBottom: false,
        locale: METRO_LOCALE,
        title: "",
        content: "",
        actions: {},
        actionsAlign: "right",
        defaultAction: true,
        overlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,
        overlayClickClose: false,
        width: '480',
        height: 'auto',
        shadow: true,
        closeAction: true,
        clsDialog: "",
        clsTitle: "",
        clsContent: "",
        clsAction: "",
        clsDefaultAction: "",
        clsOverlay: "",
        autoHide: 0,
        removeOnClose: false,
        show: false,

        _runtime: false,

        onShow: Metro.noop,
        onHide: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onDialogCreate: Metro.noop
    };

    Metro.dialogSetup = function (options) {
        DialogDefaultConfig = $.extend({}, DialogDefaultConfig, options);
    };

    if (typeof window["metroDialogSetup"] !== undefined) {
        Metro.dialogSetup(window["metroDialogSetup"]);
    }

    Metro.Component('dialog', {
        _counter: 0,

        init: function( options, elem ) {
            this._super(elem, options, DialogDefaultConfig, {
                interval: null,
                overlay: null,
                id: Utils.elementId("dialog")
            });

            return this;
        },

        _create: function(){
            var o = this.options;
            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];
            this._build();
        },

        _build: function(){
            var that = this, element = this.element, o = this.options;
            var body = $("body");
            var overlay;

            element.addClass("dialog");

            if (o.shadow === true) {
                element.addClass("shadow-on");
            }

            if (o.title !== "") {
                this.setTitle(o.title);
            }

            if (o.content !== "") {
                this.setContent(o.content);
            }

            if (o.defaultAction === true || (o.actions !== false && typeof o.actions === 'object' && Utils.objectLength(o.actions) > 0)) {
                var buttons = element.find(".dialog-actions");
                var button;

                if (buttons.length === 0) {
                    buttons = $("<div>").addClass("dialog-actions").addClass("text-"+o.actionsAlign).appendTo(element);
                }

                if (o.defaultAction === true && (Utils.objectLength(o.actions) === 0 && element.find(".dialog-actions > *").length === 0)) {
                    button = $("<button>").addClass("button js-dialog-close").addClass(o.clsDefaultAction).html(this.locale["buttons"]["ok"]);
                    button.appendTo(buttons);
                }

                if (Utils.isObject(o.actions)) $.each(Utils.isObject(o.actions), function(){
                    var item = this;
                    button = $("<button>").addClass("button").addClass(item.cls).html(item.caption);
                    if (item.onclick !== undefined) button.on(Metro.events.click, function(){
                        Utils.exec(item.onclick, [element]);
                    });
                    button.appendTo(buttons);
                });
            }

            if (o.overlay === true) {
                overlay  = this._overlay();
                this.overlay = overlay;
            }

            if (o.closeAction === true) {
                element.on(Metro.events.click, ".js-dialog-close", function(){
                    that.close();
                });
            }

            var closer = element.find("closer");
            if (closer.length === 0) {
                closer = $("<span>").addClass("button square closer js-dialog-close");
                closer.appendTo(element);
            }
            if (o.closeButton !== true) {
                closer.hide();
            }

            element.css({
                width: o.width,
                height: o.height,
                visibility: "hidden",
                top: '100%',
                left: ( $(window).width() - element.outerWidth() ) / 2
            });

            element.addClass(o.clsDialog);
            element.find(".dialog-title").addClass(o.clsTitle);
            element.find(".dialog-content").addClass(o.clsContent);
            element.find(".dialog-actions").addClass(o.clsAction);

            element.appendTo(body);

            if (o.show) {
                this.open();
            }

            $(window).on(Metro.events.resize, function(){
                that.setPosition();
            }, {ns: this.id});

            this._fireEvent("dialog-create", {
                element: element
            });
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        hide: function(callback){
            var element = this.element, o = this.options;
            var timeout = 0;
            if (o.onHide !== Metro.noop) {
                timeout = 500;

                this._fireEvent("hide");
            }
            setTimeout(function(){
                Utils.exec(callback, null, element[0]);
                element.css({
                    visibility: "hidden",
                    top: "100%"
                });
            }, timeout);
        },

        show: function(callback){
            var element = this.element;
            this.setPosition();
            element.css({
                visibility: "visible"
            });

            this._fireEvent("show");

            Utils.exec(callback, null, element[0]);
        },

        setPosition: function(){
            var element = this.element, o = this.options;
            var top, bottom;
            if (o.toTop !== true && o.toBottom !== true) {
                top = ( $(window).height() - element.outerHeight() ) / 2;
                if (top < 0) {
                    top = 0;
                }
                bottom = "auto";
            } else {
                if (o.toTop === true) {
                    top = 0;
                    bottom = "auto";
                }
                if (o.toTop !== true && o.toBottom === true) {
                    bottom = 0;
                    top = "auto";
                }
            }
            element.css({
                top: top,
                bottom: bottom,
                left: ( $(window).width() - element.outerWidth() ) / 2
            });
        },

        setContent: function(c){
            var element = this.element;
            var content = element.find(".dialog-content");
            if (content.length === 0) {
                content = $("<div>").addClass("dialog-content");
                content.appendTo(element);
            }

            if (!Utils.isQ(c) && Utils.isFunc(c)) {
                c = Utils.exec(c);
            }

            if (Utils.isQ(c)) {
                c.appendTo(content);
            } else {
                content.html(c);
            }
        },

        setTitle: function(t){
            var element = this.element;
            var title = element.find(".dialog-title");
            if (title.length === 0) {
                title = $("<div>").addClass("dialog-title");
                title.appendTo(element);
            }
            title.html(t);
        },

        close: function(){
            var that = this, element = this.element, o = this.options;

            if (!Utils.bool(o.leaveOverlayOnClose)) {
                $('body').find('.overlay').remove();
            }

            this.hide(function(){
                element.data("open", false);

                that._fireEvent("close")

                if (o.removeOnClose === true) {
                    element.remove();
                }
            });
        },

        open: function(){
            var that = this, element = this.element, o = this.options;

            if (o.overlay === true && $(".overlay").length === 0) {
                this.overlay.appendTo($("body"));
                if (o.overlayClickClose === true) {
                    this.overlay.on(Metro.events.click, function(){
                        that.close();
                    });
                }
            }

            this.show(function(){

                that._fireEvent("open");

                element.data("open", true);
                if (parseInt(o.autoHide) > 0) {
                    setTimeout(function(){
                        that.close();
                    }, parseInt(o.autoHide));
                }
            });
        },

        toggle: function(){
            var element = this.element;
            if (element.data('open')) {
                this.close();
            } else {
                this.open();
            }
        },

        isOpen: function(){
            return this.element.data('open') === true;
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".js-dialog-close");
            element.find(".button").off(Metro.events.click);
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });

    Metro.dialog = {
        isDialog: function(el){
            return Utils.isMetroObject(el, "dialog");
        },

        open: function(el, content, title){
            if (!this.isDialog(el)) {
                return false;
            }
            var dialog = Metro.getPlugin(el, "dialog");
            if (title !== undefined) {
                dialog.setTitle(title);
            }
            if (content !== undefined) {
                dialog.setContent(content);
            }
            dialog.open();
        },

        close: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").close();
        },

        toggle: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").toggle();
        },

        isOpen: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").isOpen();
        },

        remove: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            var dialog = Metro.getPlugin($(el)[0], "dialog");
            dialog.options.removeOnClose = true;
            dialog.close();
        },

        create: function(options){
            var dlg;

            dlg = $("<div>").appendTo($("body"));

            var dlg_options = $.extend({}, {
                show: true,
                closeAction: true,
                removeOnClose: true
            }, (options !== undefined ? options : {}));

            dlg_options._runtime = true;

            return Metro.makePlugin(dlg, "dialog", dlg_options);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DonutDefaultConfig = {
        donutDeferred: 0,
        size: 100,
        radius: 50,
        hole: .8,
        value: 0,
        background: "#ffffff",
        color: "",
        stroke: "#d1d8e7",
        fill: "#49649f",
        fontSize: 24,
        total: 100,
        cap: "%",
        showText: true,
        showValue: false,
        animate: 0,
        onChange: Metro.noop,
        onDonutCreate: Metro.noop
    };

    Metro.donutSetup = function (options) {
        DonutDefaultConfig = $.extend({}, DonutDefaultConfig, options);
    };

    if (typeof window["metroDonutSetup"] !== undefined) {
        Metro.donutSetup(window["metroDonutSetup"]);
    }

    Metro.Component('donut', {
        init: function( options, elem ) {
            this._super(elem, options, DonutDefaultConfig, {
                value: 0,
                animation_change_interval: null
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var html = "";
            var r = o.radius  * (1 - (1 - o.hole) / 2);
            var width = o.radius * (1 - o.hole);
            var transform = 'rotate(-90 ' + o.radius + ',' + o.radius + ')';
            var fontSize = r * o.hole * 0.6;

            element.addClass("donut");

            element.css({
                width: o.size,
                height: o.size,
                background: o.background
            });

            html += "<svg>";
            html += "   <circle class='donut-back' r='"+(r)+"px' cx='"+(o.radius)+"px' cy='"+(o.radius)+"px' transform='"+(transform)+"' fill='none' stroke='"+(o.stroke)+"' stroke-width='"+(width)+"'/>";
            html += "   <circle class='donut-fill' r='"+(r)+"px' cx='"+(o.radius)+"px' cy='"+(o.radius)+"px' transform='"+(transform)+"' fill='none' stroke='"+(o.fill)+"' stroke-width='"+(width)+"'/>";
            if (o.showText === true) html += "   <text   class='donut-title' x='"+(o.radius)+"px' y='"+(o.radius)+"px' dy='"+(fontSize/3)+"px' text-anchor='middle' fill='"+(o.color !== "" ? o.color: o.fill)+"' font-size='"+(fontSize)+"px'>0"+(o.cap)+"</text>";
            html += "</svg>";

            element.html(html);

            this.val(o.value);

            this._fireEvent("donut-create", {
                element: element
            });
        },

        _setValue: function(v){
            var element = this.element, o = this.options;

            var fill = element.find(".donut-fill");
            var title = element.find(".donut-title");
            var r = o.radius  * (1 - (1 - o.hole) / 2);
            var circumference = Math.round(2 * Math.PI * r);
            var title_value = (o.showValue ? v : Utils.percent(o.total, v, true))/*  + (o.cap)*/;
            var fill_value = Math.round(((+v * circumference) / o.total));// + ' ' + circumference;

            var sda = fill.attr("stroke-dasharray");
            if (typeof sda === "undefined") {
                sda = 0;
            } else {
                sda = +sda.split(" ")[0];
            }
            var delta = fill_value - sda;

            fill.animate({
                draw: function(t, p){
                    $(this).attr("stroke-dasharray", (sda + delta * p ) + ' ' + circumference);
                },
                dur: o.animate
            })
            title.animate({
                draw: {
                    innerHTML: title_value
                },
                dur: o.animate,
                onFrame: function(){
                    this.innerHTML += o.cap;
                }
            });
        },

        val: function(v){
            var o = this.options;

            if (v === undefined) {
                return this.value
            }

            if (parseInt(v) < 0 || parseInt(v) > o.total) {
                return false;
            }

            this._setValue(v);

            this.value = v;

            this._fireEvent("change", {
                value: this.value
            });
        },

        changeValue: function(){
            this.val(this.element.attr("data-value"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value": this.changeValue(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DoubleSliderDefaultConfig = {
        doublesliderDeferred: 0,
        roundValue: true,
        min: 0,
        max: 100,
        accuracy: 0,
        showMinMax: false,
        minMaxPosition: Metro.position.TOP,
        valueMin: null,
        valueMax: null,
        hint: false,
        hintAlways: false,
        hintPositionMin: Metro.position.TOP,
        hintPositionMax: Metro.position.TOP,
        hintMaskMin: "$1",
        hintMaskMax: "$1",
        target: null,
        size: 0,

        clsSlider: "",
        clsBackside: "",
        clsComplete: "",
        clsMarker: "",
        clsMarkerMin: "",
        clsMarkerMax: "",
        clsHint: "",
        clsHintMin: "",
        clsHintMax: "",
        clsMinMax: "",
        clsMin: "",
        clsMax: "",

        onStart: Metro.noop,
        onStop: Metro.noop,
        onMove: Metro.noop,
        onChange: Metro.noop,
        onChangeValue: Metro.noop,
        onFocus: Metro.noop,
        onBlur: Metro.noop,
        onDoubleSliderCreate: Metro.noop
    };

    Metro.doubleSliderSetup = function (options) {
        DoubleSliderDefaultConfig = $.extend({}, DoubleSliderDefaultConfig, options);
    };

    if (typeof window["metroDoubleSliderSetup"] !== undefined) {
        Metro.doubleSliderSetup(window["metroDoubleSliderSetup"]);
    }

    Metro.Component('double-slider', {
        init: function( options, elem ) {
            this._super(elem, options, DoubleSliderDefaultConfig, {
                slider: null,
                valueMin: null,
                valueMax: null,
                keyInterval: false,
                id: Utils.elementId("slider")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.valueMin = Utils.isValue(o.valueMin) ? +o.valueMin : +o.min;
            this.valueMax = Utils.isValue(o.valueMax) ? +o.valueMax : +o.max;

            this._createSlider();
            this._createEvents();

            this.val(this.valueMin, this.valueMax);

            this._fireEvent("double-slider-create", {
                element: element
            })
        },

        _createSlider: function(){
            var element = this.element, o = this.options;
            var slider_wrapper = $("<div>").addClass("slider-wrapper");
            var slider = $("<div>").addClass("slider").addClass(o.clsSlider).addClass(this.elem.className);
            var backside = $("<div>").addClass("backside").addClass(o.clsBackside);
            var complete = $("<div>").addClass("complete").addClass(o.clsComplete);
            var markerMin = $("<button>").attr("type", "button").addClass("marker marker-min").addClass(o.clsMarker).addClass(o.clsMarkerMin);
            var markerMax = $("<button>").attr("type", "button").addClass("marker marker-max").addClass(o.clsMarker).addClass(o.clsMarkerMax);
            var hintMin = $("<div>").addClass("hint hint-min").addClass(o.hintPositionMin + "-side").addClass(o.clsHint).addClass(o.clsHintMin);
            var hintMax = $("<div>").addClass("hint hint-max").addClass(o.hintPositionMax + "-side").addClass(o.clsHint).addClass(o.clsHintMax);
            var i;

            if (o.size > 0) {
                slider.outerWidth(o.size);
            }

            slider.insertBefore(element);
            element.appendTo(slider);
            slider_wrapper.insertBefore(slider);
            slider.appendTo(slider_wrapper);

            backside.appendTo(slider);
            complete.appendTo(slider);
            markerMin.appendTo(slider);
            markerMax.appendTo(slider);
            hintMin.appendTo(markerMin);
            hintMax.appendTo(markerMax);

            if (o.hintAlways === true) {
                $([hintMin, hintMax]).css({
                    display: "block"
                }).addClass("permanent-hint");
            }

            if (o.showMinMax === true) {
                var min_max_wrapper = $("<div>").addClass("slider-min-max").addClass(o.clsMinMax);
                $("<span>").addClass("slider-text-min").addClass(o.clsMin).html(o.min).appendTo(min_max_wrapper);
                $("<span>").addClass("slider-text-max").addClass(o.clsMax).html(o.max).appendTo(min_max_wrapper);
                if (o.minMaxPosition === Metro.position.TOP) {
                    min_max_wrapper.insertBefore(slider);
                } else {
                    min_max_wrapper.insertAfter(slider);
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    slider.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.slider = slider;
        },

        _createEvents: function(){
            var that = this, slider = this.slider, o = this.options;
            var marker = slider.find(".marker");

            marker.on(Metro.events.startAll, function(){
                var _marker = $(this);
                var hint = _marker.find(".hint");
                if (o.hint === true && o.hintAlways !== true) {
                    hint.fadeIn(300);
                }

                $(document).on(Metro.events.moveAll, function(e){
                    that._move(e);
                    that._fireEvent("move", {
                        min: that.valueMin,
                        max: that.valueMax
                    });

                }, {ns: that.id});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});

                    if (o.hintAlways !== true) {
                        hint.fadeOut(300);
                    }

                    that._fireEvent("stop", {
                        min: that.valueMin,
                        max: that.valueMax
                    });
                }, {ns: that.id});

                that._fireEvent("start", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            marker.on(Metro.events.focus, function(){
                that._fireEvent("focus", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            marker.on(Metro.events.blur, function(){
                that._fireEvent("blur", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            $(window).on(Metro.events.resize,function(){
                that.val(that.valueMin, that.valueMax);
            }, {ns: that.id});
        },

        _convert: function(v, how){
            var slider = this.slider, o = this.options;
            var length = slider.outerWidth() - slider.find(".marker").outerWidth();
            switch (how) {
                case "pix2prc": return ( v * 100 / length );
                case "pix2val": return ( this._convert(v, 'pix2prc') * ((o.max - o.min) / 100) + o.min );
                case "val2prc": return ( (v - o.min)/( (o.max - o.min) / 100 )  );
                case "prc2pix": return ( v / ( 100 / length ));
                case "val2pix": return ( this._convert(this._convert(v, 'val2prc'), 'prc2pix') );
            }

            return 0;
        },

        _correct: function(value){
            var res = value;
            var accuracy  = this.options.accuracy;
            var min = this.options.min, max = this.options.max;
            var _dec = function(v){
                return v % 1 === 0 ? 0 : v.toString().split(".")[1].length;
            };

            if (accuracy === 0 || isNaN(accuracy)) {
                return res;
            }

            res = Math.round(value/accuracy)*accuracy;

            if (res < min) {
                res = min;
            }

            if (res > max) {
                res = max;
            }

            return res.toFixed(_dec(accuracy));
        },

        _move: function(e){
            var target = $(e.target).closest(".marker");
            var isMin = target.hasClass("marker-min");
            var slider = this.slider;
            var offset = slider.offset(),
                marker_size = slider.find(".marker").outerWidth(),
                markerMin = slider.find(".marker-min"),
                markerMax = slider.find(".marker-max"),
                length = slider.outerWidth(),
                cPix, cStart, cStop;

            cPix = Utils.pageXY(e).x - offset.left - marker_size / 2;

            if (isMin) {
                cStart = 0;
                cStop = parseInt(markerMax.css("left")) - marker_size;
            } else {
                cStart = parseInt(markerMin.css("left")) + marker_size;
                cStop = length - marker_size;
            }

            if (cPix < cStart || cPix > cStop) {
                return ;
            }

            this[isMin ? "valueMin" : "valueMax"] = this._correct(this._convert(cPix, 'pix2val'));

            this._redraw();
        },

        _hint: function(){
            var that = this, o = this.options, slider = this.slider, hint = slider.find(".hint");

            hint.each(function(){
                var _hint = $(this);
                var isMin = _hint.hasClass("hint-min");
                var _mask = isMin ? o.hintMaskMin : o.hintMaskMax;
                var value = +(isMin ? that.valueMin : that.valueMax) || 0;
                _hint.text(_mask.replace("$1", value.toFixed(Utils.decCount(o.accuracy))))
            });
        },

        _value: function(){
            var element = this.element, o = this.options;
            var v1 = +this.valueMin || 0, v2 = +this.valueMax || 0;
            var value;

            if (o.roundValue) {
                v1 = v1.toFixed(Utils.decCount(o.accuracy));
                v2 = v2.toFixed(Utils.decCount(o.accuracy));
            }

            value = [v1, v2].join(", ");

            if (element[0].tagName === "INPUT") {
                element.val(value);
            }

            if (o.target !== null) {
                var target = $(o.target);
                if (target.length !== 0) {

                    $.each(target, function(){
                        var t = $(this);
                        if (this.tagName === "INPUT") {
                            t.val(value);
                        } else {
                            t.text(value);
                        }
                        t.trigger("change");
                    });
                }
            }

            this._fireEvent("change-value", {
                val: value
            });

            this._fireEvent("change", {
                val: value
            });
        },

        _marker: function(){
            var slider = this.slider;
            var markerMin = slider.find(".marker-min");
            var markerMax = slider.find(".marker-max");
            var complete = slider.find(".complete");
            var marker_size = parseInt(Utils.getStyleOne(markerMin, "width"));
            var slider_visible = Utils.isVisible(slider);

            if (slider_visible) {
                $([markerMin, markerMax]).css({
                    'margin-top': 0,
                    'margin-left': 0
                });
            }

            if (slider_visible) {
                markerMin.css('left', this._convert(this.valueMin, 'val2pix'));
                markerMax.css('left', this._convert(this.valueMax, 'val2pix'));
            } else {
                markerMin.css({
                    'left': (this._convert(this.valueMin, 'val2prc')) + "%",
                    'margin-top': this._convert(this.valueMin, 'val2prc') === 0 ? 0 : -1 * marker_size / 2
                });
                markerMax.css({
                    'left': (this._convert(this.valueMax, 'val2prc')) + "%",
                    'margin-top': this._convert(this.valueMax, 'val2prc') === 0 ? 0 : -1 * marker_size / 2
                });
            }

            complete.css({
                "left": this._convert(this.valueMin, 'val2pix'),
                "width": this._convert(this.valueMax, 'val2pix') - this._convert(this.valueMin, 'val2pix')
            });
        },

        _redraw: function(){
            this._marker();
            this._value();
            this._hint();
        },

        val: function(vMin, vMax){
            var o = this.options;

            if (!Utils.isValue(vMin) && !Utils.isValue(vMax)) {
                return [this.valueMin, this.valueMax];
            }

            if (vMin < o.min) vMin = o.min;
            if (vMax < o.min) vMax = o.min;

            if (vMin > o.max) vMin = o.max;
            if (vMax > o.max) vMax = o.max;

            this.valueMin = this._correct(vMin);
            this.valueMax = this._correct(vMax);

            this._redraw();
        },

        changeValue: function(){
            var element = this.element;
            var valMin = +element.attr("data-value-min");
            var valMax = +element.attr("data-value-max");
            this.val(valMin, valMax);
        },

        disable: function(){
            var element = this.element;
            element.data("disabled", true);
            element.parent().addClass("disabled");
        },

        enable: function(){
            var element = this.element;
            element.data("disabled", false);
            element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value-min": this.changeValue(); break;
                case "data-value-max": this.changeValue(); break;
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, slider = this.slider;
            var marker = slider.find(".marker");

            marker.off(Metro.events.startAll);
            marker.off(Metro.events.focus);
            marker.off(Metro.events.blur);
            marker.off(Metro.events.keydown);
            marker.off(Metro.events.keyup);
            slider.off(Metro.events.click);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DragItemsDefaultConfig = {
        dragitemsDeferred: 0,
        target: null,
        dragItem: "li",
        dragMarker: ".drag-item-marker",
        drawDragMarker: false,
        clsDragItemAvatar: "",
        clsDragItem: "",
        canDrag: true,
        onDragStartItem: Metro.noop,
        onDragMoveItem: Metro.noop,
        onDragDropItem: Metro.noop,
        onTarget: Metro.noop,
        onTargetIn: Metro.noop, //TODO
        onTargetOut: Metro.noop, //TODO
        onDragItemsCreate: Metro.noop
    };

    Metro.dragItemsSetup = function (options) {
        DragItemsDefaultConfig = $.extend({}, DragItemsDefaultConfig, options);
    };

    if (typeof window["metroDragItemsSetup"] !== undefined) {
        Metro.dragItemsSetup(window["metroDragItemsSetup"]);
    }

    Metro.Component('drag-items', {
        init: function( options, elem ) {
            this._super(elem, options, DragItemsDefaultConfig, {
                id: Utils.elementId("dragItems"),
                canDrag: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("drag-items-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.addClass("drag-items-target");

            if (o.drawDragMarker === true) {
                element.find(o.dragItem).each(function(){
                    $("<span>").addClass("drag-item-marker").appendTo(this);
                })
            }

            o.canDrag ? this.on() : this.off();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var doc = $.document(), body = $.body();
            var offset, shift = {top: 0, left: 0}, width, height;

            var move = function(e, avatar, dragItem){
                var x = Utils.pageXY(e).x, y = Utils.pageXY(e).y;
                var _top = y - shift.top;
                var _left = x - shift.left;

                avatar.css({
                    top: _top,
                    left: _left
                });

                var target = document.elementsFromPoint(x, y).filter(function(el){
                    return $(el).hasClass('drag-items-target');
                });

                if (target.length === 0) {
                    return;
                }

                that._fireEvent("target", {
                    target: target
                });

                var sibling = document.elementsFromPoint(x, y).filter(function(el){
                    var $el = $(el);
                    return $.matches(el, o.dragItem) && !$el.hasClass("dragged-item-avatar");
                })[0];

                if (!Utils.isValue(sibling)) {
                    dragItem.appendTo(target);
                } else {
                    var $sibling = $(sibling);
                    var $sibling_offset = $sibling.offset();
                    var offsetY = y - $sibling_offset.top;
                    var offsetX = x - $sibling_offset.left;
                    var side;
                    var dim = {w: $sibling.width(), h: $sibling.height()};

                    if (offsetX < dim.w / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
                        side = 'left';
                    } else if (offsetX > dim.w * 2 / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
                        side = 'right';
                    } else if (offsetX > dim.w / 3 && offsetX < dim.w * 2 / 3 && offsetY > dim.h / 2) {
                        side = 'bottom';
                    } else {
                        side = "top";
                    }

                    if (!$sibling.hasClass("dragged-item")) {
                        if (side === "top" || side === "left") {
                            dragItem.insertBefore($sibling);
                        } else {
                            dragItem.insertAfter($sibling);
                        }
                    }
                }
            };

            element.on(Metro.events.startAll, (o.drawDragMarker ? o.dragMarker : o.dragItem), function(e_start){
                var dragItem = $(e_start.target).closest(o.dragItem);
                var avatar;

                if (Utils.isRightMouse(e_start)) {
                    return ;
                }

                if (that.canDrag !== true) {
                    return ;
                }

                dragItem.addClass("dragged-item").addClass(o.clsDragItem);
                avatar = $("<div>").addClass("dragged-item-avatar").addClass(o.clsDragItemAvatar);
                offset = dragItem.offset();
                width = dragItem.width();
                height = dragItem.height();
                shift.top = Utils.pageXY(e_start).y - offset.top;
                shift.left = Utils.pageXY(e_start).x - offset.left;

                avatar.css({
                    top: offset.top,
                    left: offset.left,
                    width: width,
                    height: height
                }).appendTo(body);

                that._fireEvent("drag-start-item", {
                    dragItem: dragItem[0],
                    avatar: avatar[0]
                });

                doc.on(Metro.events.moveAll, function(e_move){

                    move(e_move, avatar, dragItem);

                    that._fireEvent("drag-move-item", {
                        dragItem: dragItem[0],
                        avatar: avatar[0]
                    });

                    e_move.preventDefault();

                }, {ns: that.id, passive: false});

                doc.on(Metro.events.stopAll, function(){

                    that._fireEvent("drag-drop-item", {
                        dragItem: dragItem[0],
                        avatar: avatar[0]
                    });

                    dragItem.removeClass("dragged-item").removeClass(o.clsDragItem);
                    avatar.remove();

                    doc.off(Metro.events.moveAll, {ns: that.id});
                    doc.off(Metro.events.stopAll, {ns: that.id});

                }, {ns: that.id});

                if (o.drawDragMarker) {
                    e_start.preventDefault();
                    e_start.stopPropagation();
                }
            });
        },

        on: function(){
            this.canDrag = true;
            this.element.find(".drag-item-marker").show();
        },

        off: function(){
            this.canDrag = false;
            this.element.find(".drag-item-marker").hide();
        },

        toggle: function(){
            this.canDrag = this.canDrag ? this.off() : this.on();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;
            var changeCanDrag = function(){
                o.canDtag = JSON.parse(element.attr("data-can-drag"));
                o.canDtag ? that.on() : that.off();
            };

            if (attributeName === "data-can-drag") {
                changeCanDrag();
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            element.off(Metro.events.startAll, (o.drawDragMarker ? o.dragMarker : o.dragItem));
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DraggableDefaultConfig = {
        dragContext: null,
        draggableDeferred: 0,
        dragElement: 'self',
        dragArea: "parent",
        timeout: 0,
        boundaryRestriction: true,
        onCanDrag: Metro.noop_true,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onDraggableCreate: Metro.noop
    };

    Metro.draggableSetup = function (options) {
        DraggableDefaultConfig = $.extend({}, DraggableDefaultConfig, options);
    };

    if (typeof window["metroDraggableSetup"] !== undefined) {
        Metro.draggableSetup(window["metroDraggableSetup"]);
    }

    Metro.Component('draggable', {
        init: function( options, elem ) {
            this._super(elem, options, DraggableDefaultConfig, {
                drag: false,
                move: false,
                backup: {
                    cursor: 'default',
                    zIndex: '0'
                },
                dragArea: null,
                dragElement: null,
                id: Utils.elementId("draggable")
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("draggable-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var offset = element.offset();
            var dragElement  = o.dragElement !== 'self' ? element.find(o.dragElement) : element;

            element.data("canDrag", true);

            this.dragElement = dragElement;

            dragElement[0].ondragstart = function(){return false;};

            element.css("position", "absolute");

            if (o.dragArea === 'document' || o.dragArea === 'window') {
                o.dragArea = "body";
            }

            setImmediate(function(){
                that.dragArea = o.dragArea === 'parent' ? element.parent() : $(o.dragArea);
                if (o.dragArea !== 'parent') {
                    element.appendTo(that.dragArea);
                    element.css({
                        top: offset.top,
                        left: offset.left
                    });
                }
            });

            if (!element.attr("id")) {
                element.attr("id", Utils.elementId("draggable"));
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var position = {
                x: 0,
                y: 0
            };

            this.dragElement.on(Metro.events.startAll, function(e){

                var coord = o.dragArea !== "parent" ? element.offset() : element.position(),
                    shiftX = Utils.pageXY(e).x - coord.left,
                    shiftY = Utils.pageXY(e).y - coord.top;

                var moveElement = function(e){
                    var top = Utils.pageXY(e).y - shiftY;
                    var left = Utils.pageXY(e).x - shiftX;

                    if (o.boundaryRestriction) {
                        if (top < 0) top = 0;
                        if (left < 0) left = 0;

                        if (top > that.dragArea.outerHeight() - element.outerHeight()) top = that.dragArea.outerHeight() - element.outerHeight();
                        if (left > that.dragArea.outerWidth() - element.outerWidth()) left = that.dragArea.outerWidth() - element.outerWidth();
                    }

                    position.y = top;
                    position.x = left;

                    element.css({
                        left: left,
                        top: top
                    });
                };


                if (element.data("canDrag") === false || Utils.exec(o.onCanDrag, [element]) !== true) {
                    return ;
                }

                if (Metro.isTouchable === false && e.which !== 1) {
                    return ;
                }

                that.drag = true;

                that.backup.cursor = element.css("cursor");
                that.backup.zIndex = element.css("z-index");

                element.addClass("draggable");

                moveElement(e);

                that._fireEvent("drag-start", {
                    position: position,
                    context: o.dragContext
                });

                $(document).on(Metro.events.moveAll, function(e){
                    e.preventDefault();
                    moveElement(e);

                    that._fireEvent("drag-move", {
                        position: position,
                        context: o.dragContext
                    });

                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    element.css({
                        cursor: that.backup.cursor,
                        zIndex: that.backup.zIndex
                    }).removeClass("draggable");

                    if (that.drag) {
                        $(document).off(Metro.events.moveAll, {ns: that.id});
                        $(document).off(Metro.events.stopAll, {ns: that.id});
                    }

                    that.drag = false;
                    that.move = false;

                    that._fireEvent("drag-stop", {
                        position: position,
                        context: o.dragContext
                    });

                }, {ns: that.id});
            });
        },

        off: function(){
            this.element.data("canDrag", false);
        },

        on: function(){
            this.element.data("canDrag", true);
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName, newValue){
        },

        destroy: function(){
            var element = this.element;
            this.dragElement.off(Metro.events.startAll);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DropdownDefaultConfig = {
        dropdownDeferred: 0,
        dropFilter: null,
        toggleElement: null,
        noClose: false,
        duration: 50,
        checkDropUp: false,
        dropUp: false,
        onDrop: Metro.noop,
        onUp: Metro.noop,
        onDropdownCreate: Metro.noop
    };

    Metro.dropdownSetup = function (options) {
        DropdownDefaultConfig = $.extend({}, DropdownDefaultConfig, options);
    };

    if (typeof window["metroDropdownSetup"] !== undefined) {
        Metro.dropdownSetup(window["metroDropdownSetup"]);
    }

    Metro.Component('dropdown', {
        init: function( options, elem ) {
            this._super(elem, options, DropdownDefaultConfig, {
                _toggle: null,
                displayOrigin: null,
                isOpen: false
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("dropdown-create", {
                element: element
            });

            if (element.hasClass("open")) {
                element.removeClass("open");
                setTimeout(function(){
                    that.open(true);
                },0);
            }
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var toggle;

            if (o.dropUp) {
                element.addClass("drop-up");
            }

            toggle = o.toggleElement !== null ? $(o.toggleElement) : element.siblings('.dropdown-toggle').length > 0 ? element.siblings('.dropdown-toggle') : element.prev();

            this.displayOrigin = Utils.getStyleOne(element, "display");

            if (element.hasClass("v-menu")) {
                element.addClass("for-dropdown");
            }

            element.css("display", "none");

            this._toggle = toggle;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var toggle = this._toggle, parent = element.parent();

            toggle.on(Metro.events.click, function(e){
                parent.siblings(parent[0].tagName).removeClass("active-container");
                $(".active-container").removeClass("active-container");

                if (element.css('display') !== 'none' && !element.hasClass('keep-open')) {
                    that._close(element);
                } else {
                    $('[data-role=dropdown]').each(function(i, el){
                        if (!element.parents('[data-role=dropdown]').is(el) && !$(el).hasClass('keep-open') && $(el).css('display') !== 'none') {
                            if (!Utils.isValue(o.dropFilter)) {
                                that._close(el);
                            } else {
                                if ($(el).closest(o.dropFilter).length > 0) {
                                    that._close(el);
                                }
                            }
                        }
                    });
                    if (element.hasClass('horizontal')) {
                        element.css({
                            'visibility': 'hidden',
                            'display': 'block'
                        });
                        var children_width = 0;
                        $.each(element.children('li'), function(){
                            children_width += $(this).outerWidth(true);
                        });

                        element.css({
                            'visibility': 'visible',
                            'display': 'none'
                        });
                        element.css('width', children_width);
                    }
                    that._open(element);
                    parent.addClass("active-container");
                }
                e.preventDefault();
                e.stopPropagation();
            });

            if (o.noClose === true) {
                element.addClass("keep-open").on(Metro.events.click, function (e) {
                    //e.preventDefault();
                    e.stopPropagation();
                });
            }

            $(element).find('li.disabled a').on(Metro.events.click, function(e){
                e.preventDefault();
            });
        },

        _close: function(el, immediate){
            el = $(el);

            var dropdown  = Metro.getPlugin(el, "dropdown");
            var toggle = dropdown._toggle;
            var options = dropdown.options;
            var func = "slideUp";

            toggle.removeClass('active-toggle').removeClass("active-control");
            dropdown.element.parent().removeClass("active-container");

            if (immediate) {
                func = 'hide'
            }

            el[func](immediate ? 0 : options.duration, function(){
                dropdown._fireEvent("close");
                dropdown._fireEvent("up");

                if (!options.dropUp && options.checkDropUp) {
                    dropdown.element.removeClass("drop-up");
                }
            });

            this.isOpen = false;
        },

        _open: function(el, immediate){
            el = $(el);

            var dropdown  = Metro.getPlugin(el, "dropdown");
            var toggle = dropdown._toggle;
            var options = dropdown.options;
            var func = "slideDown";

            toggle.addClass('active-toggle').addClass("active-control");

            el[func](immediate ? 0 : options.duration, function(){

                if (!options.dropUp && options.checkDropUp) {
                    // dropdown.element.removeClass("drop-up");
                    if (!Utils.inViewport(dropdown.element[0])) {
                        dropdown.element.addClass("drop-up");
                    }
                }

                dropdown._fireEvent("open");
                dropdown._fireEvent("drop");
            });

            // this._fireEvent("drop");

            this.isOpen = true;
        },

        close: function(immediate){
            this._close(this.element, immediate);
        },

        open: function(immediate){
            this._open(this.element, immediate);
        },

        toggle: function(){
            if (this.isOpen)
                this.close();
            else
                this.open();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(){
        },

        destroy: function(){
            this._toggle.off(Metro.events.click);
        }
    });

    $(document).on(Metro.events.click, function(){
        $('[data-role*=dropdown]').each(function(){
            var el = $(this);

            if (el.css('display')!=='none' && !el.hasClass('keep-open') && !el.hasClass('stay-open') && !el.hasClass('ignore-document-click')) {
                Metro.getPlugin(el, 'dropdown').close();
            }
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var FileDefaultConfig = {
        fileDeferred: 0,
        label: "",
        mode: "input",
        buttonTitle: "Choose file(s)",
        filesTitle: "file(s) selected",
        dropTitle: "<strong>Choose a file(s)</strong> or drop it here",
        dropIcon: "<span class='default-icon-upload'></span>",
        prepend: "",
        clsComponent: "",
        clsPrepend: "",
        clsButton: "",
        clsCaption: "",
        clsLabel: "",
        copyInlineStyles: false,
        onSelect: Metro.noop,
        onFileCreate: Metro.noop
    };

    Metro.fileSetup = function (options) {
        FileDefaultConfig = $.extend({}, FileDefaultConfig, options);
    };

    if (typeof window["metroFileSetup"] !== undefined) {
        Metro.fileSetup(window["metroFileSetup"]);
    }

    Metro.Component('file', {
        init: function( options, elem ) {
            this._super(elem, options, FileDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("file-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var container = $("<label>").addClass((o.mode === "input" ? " file " : o.mode === "button" ? " file-button " : " drop-zone ") + element[0].className).addClass(o.clsComponent);
            var caption = $("<span>").addClass("caption").addClass(o.clsCaption);
            var files = $("<span>").addClass("files").addClass(o.clsCaption);
            var icon, button;


            container.insertBefore(element);
            element.appendTo(container);

            if (o.mode === 'drop' || o.mode === 'dropzone') {
                icon = $(o.dropIcon).addClass("icon").appendTo(container);
                caption.html(o.dropTitle).insertAfter(icon);
                files.html("0" + " " + o.filesTitle).insertAfter(caption);
            } else if (o.mode === 'button') {

                button = $("<span>").addClass("button").attr("tabindex", -1).html(o.buttonTitle);
                button.appendTo(container);
                button.addClass(o.clsButton);

            } else {
                caption.insertBefore(element);

                button = $("<span>").addClass("button").attr("tabindex", -1).html(o.buttonTitle);
                button.appendTo(container);
                button.addClass(o.clsButton);

                if (element.attr('dir') === 'rtl' ) {
                    container.addClass("rtl");
                }

                if (o.prepend !== "") {
                    var prepend = $("<div>").html(o.prepend);
                    prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
                }
            }

            element[0].className = '';

            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest("label");
            var caption = container.find(".caption");
            var files = container.find(".files");
            var form = element.closest("form");

            if (form.length) {
                form.on("reset", function(){
                    that.clear();
                })
            }

            container.on(Metro.events.click, "button", function(){
                element[0].click();
            });

            element.on(Metro.events.change, function(){
                var fi = this;
                var file_names = [];
                var entry;

                // if (fi.files.length === 0) {
                //     return ;
                // }

                Array.from(fi.files).forEach(function(file){
                    file_names.push(file.name);
                });

                if (o.mode === "input") {

                    entry = file_names.join(", ");

                    caption.html(entry);
                    caption.attr('title', entry);
                } else {
                    files.html(element[0].files.length + " " +o.filesTitle);
                }

                that._fireEvent("select", {
                    files: fi.files
                });
            });

            element.on(Metro.events.focus, function(){container.addClass("focused");});
            element.on(Metro.events.blur, function(){container.removeClass("focused");});

            if (o.mode !== "input") {
                container.on('drag dragstart dragend dragover dragenter dragleave drop', function(e){
                    e.preventDefault();
                });

                container.on('dragenter dragover', function(){
                    container.addClass("drop-on");
                });

                container.on('dragleave', function(){
                    container.removeClass("drop-on");
                });

                container.on('drop', function(e){
                    element[0].files = e.dataTransfer.files;
                    files.html(element[0].files.length + " " +o.filesTitle);
                    container.removeClass("drop-on");
                    element.trigger("change");
                });
            }
        },

        clear: function(){
            var element = this.element, o = this.options;
            if (o.mode === "input") {
                element.siblings(".caption").html("");
            } else {
                element.siblings(".caption").html(o.dropTitle);
                element.siblings(".files").html("0" + " " + o.filesTitle);
            }

            element.val("");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggleDir: function(){
            if (this.element.attr("dir") === 'rtl') {
                this.element.parent().addClass("rtl");
            } else {
                this.element.parent().removeClass("rtl");
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'dir': this.toggleDir(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var parent = element.parent();
            element.off(Metro.events.change);
            parent.off(Metro.events.click, "button");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var GravatarDefaultConfig = {
        gravatarDeferred: 0,
        email: "",
        size: 80,
        default: "mp",
        onGravatarCreate: Metro.noop
    };

    Metro.gravatarSetup = function (options) {
        GravatarDefaultConfig = $.extend({}, GravatarDefaultConfig, options);
    };

    if (typeof window["metroGravatarSetup"] !== undefined) {
        Metro.gravatarSetup(window["metroGravatarSetup"]);
    }

    Metro.Component('gravatar', {
        init: function( options, elem ) {
            this._super(elem, options, GravatarDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this.get();

            this._fireEvent("gravatar-create", {
                element: element
            });
        },

        getImage: function(email, size, def, is_object){
            var image = $("<img>").attr('alt', email);

            image.attr("src", this.getImageSrc(email, size));

            return is_object === true ? image : image[0];
        },

        getImageSrc: function(email, size, def){
            if (email === undefined || email.trim() === '') {
                return "";
            }

            size = size || 80;
            def = Utils.encodeURI(def) || '404';

            return "//www.gravatar.com/avatar/" + Metro.md5((email.toLowerCase()).trim()) + '?size=' + size + '&d=' + def;
        },

        get: function(){
            var element = this.element, o = this.options;
            var img = element[0].tagName === 'IMG' ? element : element.find("img");

            if (img.length === 0) {
                return;
            }
            img.attr("src", this.getImageSrc(o.email, o.size, o.default));

            return this;
        },

        resize: function(new_size){
            this.options.size = new_size !== undefined ? new_size : this.element.attr("data-size");
            this.get();
        },

        email: function(new_email){
            this.options.email = new_email !== undefined ? new_email : this.element.attr("data-email");
            this.get();
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-size': this.resize(); break;
                case 'data-email': this.email(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var HintDefaultConfig = {
        hintDeferred: 0,
        hintHide: 5000,
        clsHint: "",
        hintText: "",
        hintPosition: Metro.position.TOP,
        hintOffset: 4,
        onHintShow: Metro.noop,
        onHintHide: Metro.noop,
        onHintCreate: Metro.noop
    };

    Metro.hintSetup = function (options) {
        HintDefaultConfig = $.extend({}, HintDefaultConfig, options);
    };

    if (typeof window["metroHintSetup"] !== undefined) {
        Metro.hintSetup(window["metroHintSetup"]);
    }

    Metro.Component('hint', {
        init: function( options, elem ) {
            this._super(elem, options, HintDefaultConfig, {
                hint: null,
                hint_size: {
                    width: 0,
                    height: 0
                },
                id: Utils.elementId("hint")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("hint-create", {
                element: this.element
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.enter, function(){
                that.createHint();
                if (+o.hintHide > 0) {
                    setTimeout(function(){
                        that.removeHint();
                    }, o.hintHide);
                }
            });

            element.on(Metro.events.leave, function(){
                that.removeHint();
            });

            $(window).on(Metro.events.scroll+" "+Metro.events.resize, function(){
                if (that.hint !== null) that.setPosition();
            }, {ns: this.id});
        },

        createHint: function(){
            var elem = this.elem, element = this.element, o = this.options;
            var hint = $("<div>").addClass("hint").addClass(o.clsHint).html(o.hintText);

            this.hint = hint;
            this.hint_size = Utils.hiddenElementSize(hint);

            $(".hint:not(.permanent-hint)").remove();

            if (elem.tagName === 'TD' || elem.tagName === 'TH') {
                var wrp = $("<div/>").css("display", "inline-block").html(element.html());
                element.html(wrp);
                element = wrp;
            }

            this.setPosition();

            hint.appendTo($('body'));

            this._fireEvent("hint-show", {
                hint: hint[0]
            })
        },

        setPosition: function(){
            var hint = this.hint, hint_size = this.hint_size, o = this.options, element = this.element;

            if (o.hintPosition === Metro.position.BOTTOM) {
                hint.addClass('bottom');
                hint.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight() + o.hintOffset,
                    left: element.offset().left + element.outerWidth()/2 - hint_size.width/2  - $(window).scrollLeft()
                });
            } else if (o.hintPosition === Metro.position.RIGHT) {
                hint.addClass('right');
                hint.css({
                    top: element.offset().top + element.outerHeight()/2 - hint_size.height/2 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() - $(window).scrollLeft() + o.hintOffset
                });
            } else if (o.hintPosition === Metro.position.LEFT) {
                hint.addClass('left');
                hint.css({
                    top: element.offset().top + element.outerHeight()/2 - hint_size.height/2 - $(window).scrollTop(),
                    left: element.offset().left - hint_size.width - $(window).scrollLeft() - o.hintOffset
                });
            } else {
                hint.addClass('top');
                hint.css({
                    top: element.offset().top - $(window).scrollTop() - hint_size.height - o.hintOffset,
                    left: element.offset().left - $(window).scrollLeft() + element.outerWidth()/2 - hint_size.width/2
                });
            }
        },

        removeHint: function(){
            var that = this;
            var hint = this.hint;
            var options = this.options;
            var timeout = options.onHintHide === Metro.noop ? 0 : 300;

            if (hint !== null) {

                this._fireEvent("hint-hide", {
                    hint: hint[0]
                });

                setTimeout(function(){
                    hint.hide(0, function(){
                        hint.remove();
                        that.hint = null;
                    });
                }, timeout);
            }
        },

        changeText: function(){
            this.options.hintText = this.element.attr("data-hint-text");
        },

        changeAttribute: function(attributeName){
            if (attributeName === "data-hint-text") {
                this.changeText();
            }
        },

        destroy: function(){
            var element = this.element;
            this.removeHint();
            element.off(Metro.events.enter + "-hint");
            element.off(Metro.events.leave + "-hint");
            $(window).off(Metro.events.scroll + "-hint");
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Hotkey = {
        specialKeys: {
            8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
            20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
            37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del",
            96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
            104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111 : "/",
            112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8",
            120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 188: ",", 190: ".",
            191: "/", 224: "meta" },

        shiftNums: {
            "~":"`", "!":"1", "@":"2", "#":"3", "$":"4", "%":"5", "^":"6", "&":"7",
            "*":"8", "(":"9", ")":"0", "_":"-", "+":"=", ":":";", "\"":"'", "<":",",
            ">":".",  "?":"/",   "|":"\\"
        },

        shiftNumsInverse: {
            "`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&",
            "8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<",
            ".": ">",  "/": "?",  "\\": "|"
        },

        textAcceptingInputTypes: [
            "text", "password", "number", "email", "url", "range", "date", "month", "week", "time", "datetime",
            "datetime-local", "search", "color", "tel"
        ],

        getKey: function(e){
            var key, k = e.keyCode, char = String.fromCharCode( k ).toLowerCase();
            if( e.shiftKey ){
                key = Hotkey.shiftNums[ char ] ? Hotkey.shiftNums[ char ] : char;
            }
            else {
                key = Hotkey.specialKeys[ k ] === undefined
                    ? char
                    : Hotkey.specialKeys[ k ];
            }

            return Hotkey.getModifier(e).length ? Hotkey.getModifier(e).join("+") + "+" + key : key;
        },

        getModifier: function(e){
            var m = [];
            if (e.altKey) {m.push("alt");}
            if (e.ctrlKey) {m.push("ctrl");}
            if (e.shiftKey) {m.push("shift");}
            return m;
        }
    };

    function bindKey(key, fn){
        return this.each(function(){
            $(this).on(Metro.events.keyup+".hotkey-method-"+key, function(e){
                var _key = Hotkey.getKey(e);
                var el = $(this);
                var href = ""+el.attr("href");

                if (key !== _key) {
                    return;
                }

                if (el.is("a")) {
                    if (href && href.trim() !== "#") {
                        window.location.href = href;
                    }
                }

                Utils.exec(fn, [e, _key, key], this);
            })
        })
    }

    $.fn.hotkey = bindKey;

    if (window.METRO_JQUERY && window.jquery_present) {
        jQuery.fn.hotkey = bindKey;
    }

    // TODO keyup or keydown ?
    $(document).on(Metro.events.keyup + ".hotkey-data", function(e){
        var el, fn, key, href;

        if (
            (METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS && /textarea|input|select/i.test(e.target.nodeName)) ||
            (METRO_HOTKEYS_FILTER_CONTENT_EDITABLE && $(e.target).attr('contenteditable')) ||
            (METRO_HOTKEYS_FILTER_TEXT_INPUTS && Hotkey.textAcceptingInputTypes.indexOf(e.target.type) > -1)
        )
        {
            return;
        }

        key = Hotkey.getKey(e);

        if (Utils.keyInObject(Metro.hotkeys, key)) {
            el = $(Metro.hotkeys[key][0]);
            fn = Metro.hotkeys[key][1];
            href = (""+el.attr("href")).trim();

            if (fn) {
                Utils.exec(fn);
            } else {
                if (el.is("a") && href && href.length > 0 && href.trim() !== "#") {
                    window.location.href = href;
                } else {
                    el.click();
                }
            }
        }
    });

    // TODO add destroy
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var HtmlContainerDefaultConfig = {
        htmlcontainerDeferred: 0,
        method: "get",
        htmlSource: null,
        requestData: null,
        requestOptions: null,
        insertMode: "default", // replace, append, prepend
        onHtmlLoad: Metro.noop,
        onHtmlLoadFail: Metro.noop,
        onHtmlLoadDone: Metro.noop,
        onHtmlContainerCreate: Metro.noop
    };

    Metro.htmlContainerSetup = function (options) {
        HtmlContainerDefaultConfig = $.extend({}, HtmlContainerDefaultConfig, options);
    };

    if (typeof window["metroHtmlContainerSetup"] !== undefined) {
        Metro.htmlContainerSetup(window["metroHtmlContainerSetup"]);
    }

    Metro.Component('html-container', {
        init: function( options, elem ) {
            this._super(elem, options, HtmlContainerDefaultConfig, {
                data: {},
                opt: {},
                htmlSource: ''
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (typeof o.requestData === 'string') {
                o.requestData = JSON.parse(o.requestData);
            }

            if (Utils.isObject(o.requestData)) {
                this.data = Utils.isObject(o.requestData);
            }

            if (typeof o.requestOptions === 'string') {
                o.requestOptions = JSON.parse(o.requestOptions);
            }

            if (Utils.isObject(o.requestOptions)) {
                this.opt = Utils.isObject(o.requestOptions);
            }

            o.method = o.method.toLowerCase();

            if (Utils.isValue(o.htmlSource)) {
                this.htmlSource = o.htmlSource;
                this._load();
            }

            this._fireEvent("html-container-create", {
                element: element
            });
        },

        _load: function(){
            var that = this, element = this.element, o = this.options;

            $[o.method](this.htmlSource, this.data, this.opt).then(function(data){
                var _data = $(data);

                if (_data.length === 0) {
                    _data = $("<div>").html(data);
                }

                switch (o.insertMode.toLowerCase()) {
                    case "prepend": element.prepend(_data); break;
                    case "append": element.append(_data); break;
                    case "replace": _data.insertBefore(element).script(); element.remove(); break;
                    default: {
                        element.html(_data);
                    }
                }
                that._fireEvent("html-load", {
                    data: data,
                    source: o.htmlSource,
                    requestData: that.data,
                    requestOptions: that.opt
                });
            }, function(xhr){
                that._fireEvent("html-load-fail", {
                    xhr: xhr
                });
            });
        },

        load: function(source, data, opt){
            if (source) {
                this.htmlSource = source;
            }

            if (data) {
                this.data = Utils.isObject(data);
            }

            if (opt) {
                this.opt = Utils.isObject(opt);
            }

            this._load();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeHTMLSource = function(){
                var html = element.attr("data-html-source");
                if (Utils.isNull(html)) {
                    return ;
                }
                if (html.trim() === "") {
                    element.html("");
                }
                o.htmlSource = html;
                that._load();
            };

            var changeInsertMode = function(){
                var attr = element.attr("data-insert-mode");
                if (Utils.isValue(attr)) {
                    o.insertMode = attr;
                }
            };

            var changeRequestData = function(){
                var data = element.attr("data-request-data");
                that.load(o.htmlSource, data);
            };

            switch (attributeName) {
                case "data-html-source": changeHTMLSource(); break;
                case "data-insert-mode": changeInsertMode(); break;
                case "data-request-data": changeRequestData(); break;
            }
        },

        destroy: function(){}
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var ImageBoxDefaultConfig = {
        image: null,
        size: "cover",
        repeat: false,
        color: "transparent",
        attachment: "scroll",
        origin: "border",
        onImageBoxCreate: Metro.noop
    };

    Metro.imageBoxSetup = function (options) {
        ImageBoxDefaultConfig = $.extend({}, ImageBoxDefaultConfig, options);
    };

    if (typeof window["metroImageBoxSetup"] !== undefined) {
        Metro.imageBoxSetup(window["metroImageBoxSetup"]);
    }

    Metro.Component('image-box', {
        init: function( options, elem ) {
            this._super(elem, options, ImageBoxDefaultConfig, {
                // define instance vars here
            });
            return this;
        },

        _create: function(){
            this._createStructure();

            this._fireEvent('image-box-create');
        },

        _createStructure: function(){
            var element = this.element;

            element.addClass("image-box");

            this._drawImage();
        },

        _drawImage: function(){
            var element = this.element, o = this.options;
            var image = new Image();
            var portrait;

            if (!element.attr("data-original"))
                element.attr("data-original", o.image);

            element.css({
                backgroundImage: "url("+o.image+")",
                backgroundSize: o.size,
                backgroundRepeat: o.repeat,
                backgroundColor: o.color,
                backgroundAttachment: o.attachment,
                backgroundOrigin: o.origin
            });

            image.src = o.image;
            image.onload = function(){
                portrait = this.height >= this.width;
                element
                    .removeClass("image-box__portrait image-box__landscape")
                    .addClass("image-box__" + (portrait ? "portrait" : "landscape"));
            }
        },

        changeAttribute: function(attr, newValue){
            var attrName = attr.replace("data-", "");

            if (["image", "size", "repeat", "color", "attachment", "origin"].indexOf(attrName) > -1) {
                this.options[attrName] = newValue;
                this._drawImage();
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var ImageGridDefaultConfig = {
        useBackground: false,
        backgroundSize: "cover",
        backgroundPosition: "top left",

        clsImageGrid: "",
        clsImageGridItem: "",
        clsImageGridImage: "",

        onItemClick: Metro.noop,
        onDrawItem: Metro.noop,
        onImageGridCreate: Metro.noop
    };

    Metro.imageGridSetup = function (options) {
        ImageGridDefaultConfig = $.extend({}, ImageGridDefaultConfig, options);
    };

    if (typeof window["metroImageGridSetup"] !== undefined) {
        Metro.imageGridSetup(window["metroImageGridSetup"]);
    }

    Metro.Component('image-grid', {
        init: function( options, elem ) {
            this._super(elem, options, ImageGridDefaultConfig, {
                // define instance vars here
                items: []
            });
            return this;
        },

        _create: function(){
            this.items = this.element.children("img");
            this._createStructure();
            this._createEvents();
            this._fireEvent('image-grid-create');
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.addClass("image-grid").addClass(o.clsImageGrid);

            this._createItems();
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".image-grid__item", function(){
                that._fireEvent("item-click", {
                    item: this
                });
            });
        },

        _createItems: function(){
            var that = this, element = this.element, o = this.options;
            var items = this.items;

            element.clear();

            items.each(function(){
                var el = $(this);
                var src = this.src;
                var wrapper = $("<div>").addClass("image-grid__item").addClass(o.clsImageGridItem).appendTo(element);
                var img = new Image();

                img.src = src;
                img.onload = function(){
                    var port = this.height >= this.width;
                    wrapper.addClass(port ? "image-grid__item-portrait" : "image-grid__item-landscape");
                    el.addClass(o.clsImageGridImage).appendTo(wrapper);

                    if (o.useBackground) {
                        wrapper
                            .css({
                                background: "url("+src+")",
                                backgroundRepeat: "no-repeat",
                                backgroundSize: o.backgroundSize,
                                backgroundPosition: o.backgroundPosition
                            })
                            .attr("data-original", el.attr("data-original") || src)
                            .attr("data-title", el.attr("alt") || el.attr("data-title") || "");
                        el.visible(false);
                    }

                    that._fireEvent("draw-item", {
                        item: wrapper[0],
                        image: el[0]
                    });
                }
            });
        },

        changeAttribute: function(attr, val){
            var o = this.options;

            if (attr === "data-use-background") {
                o.useBackground = Utils.bool(val);
                this._createItems();
            }

            if (attr === "data-background-size") {
                o.backgroundSize = val;
                this._createItems();
            }

            if (attr === "data-background-position") {
                o.backgroundPosition = val;
                this._createItems();
            }
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ImageMagnifierDefaultConfig = {
        imagemagnifierDeferred: 0,
        width: "100%",
        height: "auto",
        lensSize: 100,
        lensType: "square", // square, circle
        magnifierZoom: 2,
        magnifierMode: "glass", // glass, zoom
        magnifierZoomElement: null,

        clsMagnifier: "",
        clsLens: "",
        clsZoom: "",

        onMagnifierMove: Metro.noop,
        onImageMagnifierCreate: Metro.noop
    };

    Metro.imageMagnifierSetup = function (options) {
        ImageMagnifierDefaultConfig = $.extend({}, ImageMagnifierDefaultConfig, options);
    };

    if (typeof window["metroImageMagnifierSetup"] !== undefined) {
        Metro.imageMagnifierSetup(window["metroImageMagnifierSetup"]);
    }

    Metro.Component('image-magnifier', {
        init: function( options, elem ) {
            this._super(elem, options, ImageMagnifierDefaultConfig, {
                zoomElement: null,
                id: Utils.elementId("image-magnifier")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("image-magnifier-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var magnifier, element_width, element_height;
            var image = element.find("img");

            if (image.length === 0) {
                throw new Error("Image not defined");
            }

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("image-magnifier"));
            }

            element.addClass("image-magnifier").css({
                width: o.width
            }).addClass(o.clsMagnifier);

            element_width = element.width();

            switch (o.height) {
                case "16/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "21/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "4/3": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "auto": element_height = Utils.aspectRatioH(element_width, "16/9"); break;
                default: element_height = o.height;
            }

            element.css({
                height: element_height
            });

            var x = element_width / 2 - o.lensSize / 2;
            var y = element_height / 2 - o.lensSize / 2;

            if (o.magnifierMode === "glass") {

                magnifier = $("<div>").addClass("image-magnifier-glass").appendTo(element);
                magnifier.css({
                    width: o.lensSize,
                    height: o.lensSize,
                    borderRadius: o.lensType !== "circle" ? 0 : "50%",
                    top: y,
                    left: x,
                    backgroundImage: "url(" + image[0].src + ")",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "-" + ((x * o.magnifierZoom) - o.lensSize / 4 + 4) + "px -" + ((y * o.magnifierZoom) - o.lensSize / 4 + 4) + "px",
                    backgroundSize: (image[0].width * o.magnifierZoom) + "px " + (image[0].height * o.magnifierZoom) + "px"
                }).addClass(o.clsLens);

            } else {

                magnifier = $("<div>").addClass("image-magnifier-glass").appendTo(element);
                magnifier.css({
                    width: o.lensSize,
                    height: o.lensSize,
                    borderRadius: 0,
                    borderWidth: 1,
                    top: y,
                    left: x
                }).addClass(o.clsLens);

                if (!Utils.isValue(o.magnifierZoomElement) || $(o.magnifierZoomElement).length === 0) {
                    this.zoomElement = $("<div>").insertAfter(element);
                } else {
                    this.zoomElement = $(o.magnifierZoomElement);
                }

                var zoom_element_width = magnifier[0].offsetWidth * o.magnifierZoom;
                var zoom_element_height = magnifier[0].offsetHeight * o.magnifierZoom;
                var cx = zoom_element_width / o.lensSize;
                var cy = zoom_element_height / o.lensSize;

                this.zoomElement.css({
                    width: zoom_element_width,
                    height: zoom_element_height,
                    backgroundImage: "url(" + image[0].src + ")",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "-" + (x * cx) + "px -" + (y * cy) + "px",
                    backgroundSize: (image[0].width * cx) + "px " + (image[0].height * cy) + "px"
                }).addClass(o.clsZoom);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var glass = element.find(".image-magnifier-glass");
            var glass_size = glass[0].offsetWidth / 2;
            var image = element.find("img")[0];
            var zoomElement = this.zoomElement;
            var cx, cy;

            $(window).on(Metro.events.resize, function(){
                var x = element.width() / 2 - o.lensSize / 2;
                var y = element.height() / 2 - o.lensSize / 2;

                if (o.magnifierMode === "glass") {
                    glass.css({
                        backgroundPosition: "-" + ((x * o.magnifierZoom) - o.lensSize / 4 + 4) + "px -" + ((y * o.magnifierZoom) - o.lensSize / 4 + 4) + "px",
                        backgroundSize: (image.width * o.magnifierZoom) + "px " + (image.height * o.magnifierZoom) + "px"
                    });
                }
            }, {ns: this.id})

            if (o.magnifierMode !== "glass") {
                cx = zoomElement[0].offsetWidth / glass_size / 2;
                cy = zoomElement[0].offsetHeight / glass_size / 2;

                zoomElement.css({
                    backgroundSize: (image.width * cx) + "px " + (image.height * cy) + "px"
                });
            }

            var lens_move = function(pos){
                var x, y;
                var magic = 4, zoom = parseInt(o.magnifierZoom);

                if (o.magnifierMode === "glass") {

                    x = pos.x;
                    y = pos.y;

                    if (x > image.width - (glass_size / zoom)) {
                        x = image.width - (glass_size / zoom);
                    }
                    if (x < glass_size / zoom) {
                        x = glass_size / zoom;
                    }
                    if (y > image.height - (glass_size / zoom)) {
                        y = image.height - (glass_size / zoom);
                    }
                    if (y < glass_size / zoom) {
                        y = glass_size / zoom;
                    }

                    glass.css({
                        top: y - glass_size,
                        left: x - glass_size,
                        backgroundPosition: "-" + ((x * zoom) - glass_size + magic) + "px -" + ((y * zoom) - glass_size + magic) + "px"
                    });
                } else {

                    x = pos.x - (glass_size);
                    y = pos.y - (glass_size);

                    if (x > image.width - glass_size * 2) {x = image.width - glass_size * 2;}
                    if (x < 0) {x = 0;}
                    if (y > image.height - glass_size * 2) {y = image.height - glass_size * 2;}
                    if (y < 0) {y = 0;}

                    glass.css({
                        top: y,
                        left: x
                    });

                    zoomElement.css({
                        backgroundPosition: "-" + (x * cx) + "px -" + (y * cy) + "px"
                    });
                }
            };

            element.on(Metro.events.move, function(e){
                var pos = Utils.getCursorPosition(image, e);

                lens_move(pos);

                that._fireEvent("magnifier-move", {
                    pos: pos,
                    glass: glass[0],
                    zoomElement: zoomElement ? zoomElement[0] : undefined
                });

                e.preventDefault();
            });

            element.on(Metro.events.leave, function(){
                var x = element.width() / 2 - o.lensSize / 2;
                var y = element.height() / 2 - o.lensSize / 2;

                glass.animate({
                    draw: {
                        top: y,
                        left: x
                    }
                });

                lens_move({
                    x: x + o.lensSize / 2, y: y + o.lensSize / 2
                });
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.move);
            element.off(Metro.events.leave);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var InfoBoxDefaultConfig = {
        infoboxDeferred: 0,
        type: "",
        width: 480,
        height: "auto",
        overlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,
        autoHide: 0,
        removeOnClose: false,
        closeButton: true,
        clsBox: "",
        clsBoxContent: "",
        clsOverlay: "",
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onInfoBoxCreate: Metro.noop
    };

    Metro.infoBoxSetup = function (options) {
        InfoBoxDefaultConfig = $.extend({}, InfoBoxDefaultConfig, options);
    };

    if (typeof window["metroInfoBoxSetup"] !== undefined) {
        Metro.infoBoxSetup(window["metroInfoBoxSetup"]);
    }

    Metro.Component('info-box', {
        init: function( options, elem ) {
            this._super(elem, options, InfoBoxDefaultConfig, {
                overlay: null,
                id: Utils.elementId("info-box")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("info-box-create", {
                element: element
            });
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var closer, content;

            if (o.overlay === true) {
                this.overlay = this._overlay();
            }

            element.addClass("info-box").addClass(o.type).addClass(o.clsBox);

            closer = element.find("closer");
            if (closer.length === 0) {
                closer = $("<span>").addClass("button square closer");
                closer.appendTo(element);
            }

            if (o.closeButton !== true) {
                closer.hide();
            }

            content = element.find(".info-box-content");
            if (content.length > 0) {
                content.addClass(o.clsBoxContent);
            }

            element.css({
                width: o.width,
                height: o.height,
                visibility: "hidden",
                top: '100%',
                left: ( $(window).width() - element.outerWidth() ) / 2
            });

            element.appendTo($('body'));
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".closer", function(){
                that.close();
            });

            element.on(Metro.events.click, ".js-dialog-close", function(){
                that.close();
            });

            $(window).on(Metro.events.resize, function(){
                that.reposition();
            }, {ns: this.id});
        },

        _setPosition: function(){
            var element = this.element;
            element.css({
                top: ( $(window).height() - element.outerHeight() ) / 2,
                left: ( $(window).width() - element.outerWidth() ) / 2
            });
        },

        reposition: function(){
            this._setPosition();
        },

        setContent: function(c){
            var element = this.element;
            var content = element.find(".info-box-content");
            if (content.length === 0) {
                return ;
            }
            content.html(c);
            this.reposition();
        },

        setType: function(t){
            var element = this.element;
            element.removeClass("success info alert warning").addClass(t);
        },

        open: function(){
            var that = this, element = this.element, o = this.options;

            if (o.overlay === true) {
                this.overlay.appendTo($("body"));
            }

            this._setPosition();

            element.css({
                visibility: "visible"
            });

            this._fireEvent("open");

            element.data("open", true);

            if (parseInt(o.autoHide) > 0) {
                setTimeout(function(){
                    that.close();
                }, parseInt(o.autoHide));
            }
        },

        close: function(){
            var element = this.element, o = this.options;

            if (o.overlay === true) {
                $('body').find('.overlay').remove();
            }

            element.css({
                visibility: "hidden",
                top: "100%"
            });

            this._fireEvent("close");

            element.data("open", false);

            if (o.removeOnClose === true) {
                this.destroy();
                element.remove();
            }
        },

        isOpen: function(){
            return this.element.data("open") === true;
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off("all");
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });

    Metro['infobox'] = {
        isInfoBox: function(el){
            return Utils.isMetroObject(el, "infobox");
        },

        open: function(el, c, t){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            if (c !== undefined) {
                ib.setContent(c);
            }
            if (t !== undefined) {
                ib.setType(t);
            }
            ib.open();
        },

        close: function(el){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            ib.close();
        },

        setContent: function(el, c){
            if (!this.isInfoBox(el)) {
                return false;
            }

            if (c === undefined) {
                c = "";
            }

            var ib = Metro.getPlugin(el, "infobox");
            ib.setContent(c);
            ib.reposition();
        },

        setType: function(el, t){
            if (!this.isInfoBox(el)) {
                return false;
            }

            var ib = Metro.getPlugin(el, "infobox");
            ib.setType(t);
            ib.reposition();
        },

        isOpen: function(el){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            return ib.isOpen();
        },

        create: function(c, t, o, open){
            var $$ = Utils.$();
            var el, ib, box_type;

            box_type = t !== undefined ? t : "";

            el = $$("<div>").appendTo($$("body"));
            $$("<div>").addClass("info-box-content").appendTo(el);

            var ib_options = $$.extend({}, {
                removeOnClose: true,
                type: box_type
            }, (o !== undefined ? o : {}));

            ib_options._runtime = true;

            el.infobox(ib_options);

            ib = Metro.getPlugin(el, 'infobox');
            ib.setContent(c);
            if (open !== false) {
                ib.open();
            }

            return el;
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var InputMaskDefaultConfig = {
        maskPattern: ".",
        mask: null,
        maskPlaceholder: "_",
        maskEditableStart: 0,
        thresholdInterval: 300,
        onChar: Metro.noop,
        onInputMaskCreate: Metro.noop
    };

    Metro.inputMaskSetup = function (options) {
        InputMaskDefaultConfig = $.extend({}, InputMaskDefaultConfig, options);
    };

    if (typeof window["metroInputMaskSetup"] !== undefined) {
        Metro.inputMaskSetup(window["metroInputMaskSetup"]);
    }

    Metro.Component('input-mask', {
        init: function( options, elem ) {
            if ($.device) {
                if (elem.setAttribute) elem.setAttribute("placeholder", options.mask);
                console.warn("The component input-mask can't be initialized, because you run it on a mobile device!");
                return ;
            }
            this._super(elem, options, InputMaskDefaultConfig, {
                // define instance vars here
                pattern: null,
                mask: "",
                maskArray: [],
                placeholder: "",
                length: 0,
                thresholdTimer: null,
                id: Utils.elementId("input-mask")
            });
            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent('input-mask-create');
        },

        _createStructure: function(){
            var o = this.options;

            if (!o.mask) {
                throw new Error('You must provide a pattern for masked input.')
            }

            if (typeof o.maskPlaceholder !== 'string' || o.maskPlaceholder.length > 1) {
                throw new Error('Mask placeholder should be a single character or an empty string.')
            }

            this.placeholder = o.maskPlaceholder;
            this.mask = (""+o.mask);
            this.maskArray = this.mask.split("");
            this.pattern = new RegExp("^"+o.maskPattern+"+$");
            this.length = this.mask.length;

            this._showValue();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var editableStart = o.maskEditableStart;
            var id = this.id;

            var checkEditablePosition = function(pos){
                if (pos < editableStart) {
                    setPosition(editableStart);
                    return false;
                }
                return true;
            }

            var checkEditableChar = function(pos){
                return pos < that.mask.length && that.mask.charAt(pos) === that.placeholder;
            }

            var findNextEditablePosition = function (pos){
                var i, a = that.maskArray;

                for (i = pos; i <= a.length; i++) {
                    if (a[i] === that.placeholder) {
                        return i;
                    }
                }
                return pos;
            }

            var setPosition = function(pos){
                that.elem.setSelectionRange(pos, pos);
            }

            var clearThresholdInterval = function(){
                clearInterval(that.thresholdTimer);
                that.thresholdTimer = null;
            }

            element.on("change", function(){
                if (this.value === "") {
                    this.value = that.mask;
                    setPosition(editableStart);
                }
            }, {ns: id});

            element.on("focus click", function(){
                checkEditablePosition(this.selectionStart);
                setPosition(findNextEditablePosition(this.selectionStart));
            }, {ns: id});

            element.on("keydown", function(e){
                var pos = this.selectionStart;
                var val = this.value;
                var code = e.code, key = e.key;

                if (code === "ArrowRight" || code === "End") {
                    return true;
                } else {
                    if (pos >= that.length && (["Backspace", "Home", "ArrowLeft", "ArrowUp"].indexOf(code) === -1)) {
                        // Don't move over mask length
                        e.preventDefault();
                    } else if (code === "Home" || code === "ArrowUp") {
                        // Goto editable start position
                        e.preventDefault();
                        setPosition(editableStart);
                    } else if (code === "ArrowLeft") {
                        if (pos - 1 < editableStart) {
                            // Don't move behind a editable start position
                            e.preventDefault();
                        }
                    } else if (code === "Backspace") {
                        e.preventDefault();
                        if (pos - 1 >= editableStart) {
                            if (checkEditableChar(pos - 1)) {
                                if (this.value.charAt(pos - 1) !== that.placeholder) {
                                    // Replace char if it is not a mask placeholder
                                    this.value = val.substr(0, pos - 1) + that.placeholder + val.substr(pos);
                                }
                            }
                            // Move to prev char position
                            setPosition(pos - 1);
                        }
                    } else if (code === "Space") {
                        e.preventDefault();
                        setPosition(pos + 1);
                    } else if (!that.pattern.test(key)) {
                        e.preventDefault();
                    } else {
                        e.preventDefault();
                        if (checkEditableChar(pos)) {
                            this.value = val.substr(0, pos) + (o.onChar === Metro.noop ? key : Utils.exec(o.onChar, [key], this)) + val.substr(pos + 1);
                            setPosition(findNextEditablePosition(pos + 1));
                        }
                    }
                }
            }, {ns: id});

            element.on("keyup", function(){
                var el = this;

                clearThresholdInterval();

                that.thresholdTimer = setInterval(function(){
                    clearThresholdInterval();
                    setPosition(findNextEditablePosition(el.selectionStart));
                }, o.thresholdInterval)
            }, {ns: id});
        },

        _showValue: function(){
            var that = this, elem = this.elem;
            var a = new Array(this.length);
            var val;
            if (!elem.value) {
                elem.value = this.mask;
            } else {
                val = elem.value;
                $.each(this.maskArray, function(i, v){
                    if (val[i] !== v && !that.pattern.test(val[i])) {
                        a[i] = that.placeholder;
                    } else {
                        a[i] = val[i];
                    }
                });
                this.elem.value = a.join("");
            }
        },

        destroy: function(){
            var element = this.element, id = this.id;

            element.off("change", {ns: id});
            element.off("focus", {ns: id});
            element.off("click", {ns: id});
            element.off("keydown", {ns: id});
            element.off("keyup", {ns: id});

            return element;
        }
    });
}(Metro, m4q));


(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var InputDefaultConfig = {
        inputDeferred: 0,

        // mask: null,
        label: "",

        autocomplete: null,
        autocompleteDivider: ",",
        autocompleteListHeight: 200,

        history: false,
        historyPreset: "",
        historyDivider: "|",
        preventSubmit: false,
        defaultValue: "",
        size: "default",
        prepend: "",
        append: "",
        copyInlineStyles: false,
        searchButton: false,
        clearButton: true,
        revealButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        revealButtonIcon: "<span class='default-icon-eye'></span>",
        searchButtonIcon: "<span class='default-icon-search'></span>",
        customButtons: [],
        searchButtonClick: 'submit',

        clsComponent: "",
        clsInput: "",
        clsPrepend: "",
        clsAppend: "",
        clsClearButton: "",
        clsRevealButton: "",
        clsCustomButton: "",
        clsSearchButton: "",
        clsLabel: "",

        onAutocompleteSelect: Metro.noop,
        onHistoryChange: Metro.noop,
        onHistoryUp: Metro.noop,
        onHistoryDown: Metro.noop,
        onClearClick: Metro.noop,
        onRevealClick: Metro.noop,
        onSearchButtonClick: Metro.noop,
        onEnterClick: Metro.noop,
        onInputCreate: Metro.noop
    };

    Metro.inputSetup = function (options) {
        InputDefaultConfig = $.extend({}, InputDefaultConfig, options);
    };

    if (typeof window["metroInputSetup"] !== undefined) {
        Metro.inputSetup(window["metroInputSetup"]);
    }

    Metro.Component('input', {
        init: function( options, elem ) {
            this._super(elem, options, InputDefaultConfig, {
                history: [],
                historyIndex: -1,
                autocomplete: []
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("input-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container = $("<div>").addClass("input " + element[0].className);
            var buttons = $("<div>").addClass("button-group");
            var clearButton, revealButton, searchButton;

            if (Utils.isValue(o.historyPreset)) {
                $.each(o.historyPreset.toArray(o.historyDivider), function(){
                    that.history.push(this);
                });
                that.historyIndex = that.history.length - 1;
            }

            if (element.attr("type") === undefined) {
                element.attr("type", "text");
            }

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);

            if (!Utils.isValue(element.val().trim())) {
                element.val(o.defaultValue);
            }

            if (o.clearButton === true && !element[0].readOnly) {
                clearButton = $("<button>").addClass("button input-clear-button").addClass(o.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            }
            if (element.attr('type') === 'password' && o.revealButton === true) {
                revealButton = $("<button>").addClass("button input-reveal-button").addClass(o.clsRevealButton).attr("tabindex", -1).attr("type", "button").html(o.revealButtonIcon);
                revealButton.appendTo(buttons);
            }
            if (o.searchButton === true) {
                searchButton = $("<button>").addClass("button input-search-button").addClass(o.clsSearchButton).attr("tabindex", -1).attr("type", o.searchButtonClick === 'submit' ? "submit" : "button").html(o.searchButtonIcon);
                searchButton.appendTo(buttons);
            }

            if (Utils.isValue(o.prepend)) {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (Utils.isValue(o.append)) {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
            }

            if (typeof o.customButtons === "string") {
                o.customButtons = Utils.isObject(o.customButtons);
            }

            if (typeof o.customButtons === "object" && Utils.objectLength(o.customButtons) > 0) {
                $.each(o.customButtons, function(){
                    var item = this;
                    var customButton = $("<button>");

                    customButton
                        .addClass("button input-custom-button")
                        .addClass(o.clsCustomButton)
                        .addClass(item.cls)
                        .attr("tabindex", -1)
                        .attr("type", "button")
                        .html(item.html);

                    if (item.attr && typeof item.attr === 'object') {
                        $.each(item.attr, function(k, v){
                            customButton.attr($.dashedName(k), v);
                        });
                    }

                    customButton.data("action", item.onclick);

                    customButton.appendTo(buttons);
                });
            }

            if (Utils.isValue(element.attr('data-exclaim'))) {
                container.attr('data-exclaim', element.attr('data-exclaim'));
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsInput);

            if (o.size !== "default") {
                container.css({
                    width: o.size
                });
            }

            if (!Utils.isNull(o.autocomplete)) {

                var autocomplete_obj = Utils.isObject(o.autocomplete);

                if (autocomplete_obj !== false) {
                    this.autocomplete = autocomplete_obj;
                } else {
                    this.autocomplete = o.autocomplete.toArray(o.autocompleteDivider);
                }
                $("<div>").addClass("autocomplete-list").css({
                    maxHeight: o.autocompleteListHeight,
                    display: "none"
                }).appendTo(container);
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".input");
            var autocompleteList = container.find(".autocomplete-list");

            container.on(Metro.events.click, ".input-clear-button", function(){
                var curr = element.val();
                element.val(Utils.isValue(o.defaultValue) ? o.defaultValue : "").fire('clear').fire('change').fire('keyup').focus();
                if (autocompleteList.length > 0) {
                    autocompleteList.css({
                        display: "none"
                    })
                }

                that._fireEvent("clear-click", {
                    prev: curr,
                    val: element.val()
                });

            });

            container.on(Metro.events.click, ".input-reveal-button", function(){
                if (element.attr('type') === 'password') {
                    element.attr('type', 'text');
                } else {
                    element.attr('type', 'password');
                }

                that._fireEvent("reveal-click", {
                    val: element.val()
                });

            });

            container.on(Metro.events.click, ".input-search-button", function(){
                if (o.searchButtonClick !== 'submit') {

                    that._fireEvent("search-button-click", {
                        val: element.val(),
                        button: this
                    });

                } else {
                    this.form.submit();
                }
            });

            // container.on(Metro.events.stop, ".input-reveal-button", function(){
            //     element.attr('type', 'password').focus();
            // });

            container.on(Metro.events.click, ".input-custom-button", function(){
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [element.val(), button], this);
            });

            element.on(Metro.events.keyup, function(e){
                var val = element.val().trim();

                if (o.history && e.keyCode === Metro.keyCode.ENTER && val !== "") {
                    element.val("");
                    that.history.push(val);
                    that.historyIndex = that.history.length - 1;

                    that._fireEvent("history-change", {
                        val: val,
                        history: that.history,
                        historyIndex: that.historyIndex
                    })

                    if (o.preventSubmit === true) {
                        e.preventDefault();
                    }
                }

                if (o.history && e.keyCode === Metro.keyCode.UP_ARROW) {
                    that.historyIndex--;
                    if (that.historyIndex >= 0) {
                        element.val("");
                        element.val(that.history[that.historyIndex]);

                        that._fireEvent("history-down", {
                            val: element.val(),
                            history: that.history,
                            historyIndex: that.historyIndex
                        })
                    } else {
                        that.historyIndex = 0;
                    }
                    e.preventDefault();
                }

                if (o.history && e.keyCode === Metro.keyCode.DOWN_ARROW) {
                    that.historyIndex++;
                    if (that.historyIndex < that.history.length) {
                        element.val("");
                        element.val(that.history[that.historyIndex]);

                        that._fireEvent("history-up", {
                            val: element.val(),
                            history: that.history,
                            historyIndex: that.historyIndex
                        })
                    } else {
                        that.historyIndex = that.history.length - 1;
                    }
                    e.preventDefault();
                }
            });

            element.on(Metro.events.keydown, function(e){
                if (e.keyCode === Metro.keyCode.ENTER) {
                    that._fireEvent("enter-click", {
                        val: element.val()
                    });
                }
            });

            element.on(Metro.events.blur, function(){
                container.removeClass("focused");
            });

            element.on(Metro.events.focus, function(){
                container.addClass("focused");
            });

            element.on(Metro.events.input, function(){
                var val = this.value.toLowerCase();
                var items;

                if (autocompleteList.length === 0) {
                    return;
                }

                autocompleteList.html("");

                items = that.autocomplete.filter(function(item){
                    return item.toLowerCase().indexOf(val) > -1;
                });

                autocompleteList.css({
                    display: items.length > 0 ? "block" : "none"
                });

                $.each(items, function(i, v){
                    var index = v.toLowerCase().indexOf(val);
                    var item = $("<div>").addClass("item").attr("data-autocomplete-value", v);
                    var html;

                    if (index === 0) {
                        html = "<strong>"+v.substr(0, val.length)+"</strong>"+v.substr(val.length);
                    } else {
                        html = v.substr(0, index) + "<strong>"+v.substr(index, val.length)+"</strong>"+v.substr(index + val.length);
                    }
                    item.html(html).appendTo(autocompleteList);
                })
            });

            container.on(Metro.events.click, ".autocomplete-list .item", function(){
                var val = $(this).attr("data-autocomplete-value");
                element.val(val);
                autocompleteList.css({
                    display: "none"
                });
                element.trigger("change");
                that._fireEvent("autocomplete-select", {
                    value: val
                });
            });
        },

        getHistory: function(){
            return this.history;
        },

        getHistoryIndex: function(){
            return this.historyIndex;
        },

        setHistoryIndex: function(val){
            this.historyIndex = val >= this.history.length ? this.history.length - 1 : val;
        },

        setHistory: function(history, append) {
            var that = this, o = this.options;
            if (Utils.isNull(history)) return;
            if (!Array.isArray(history) && typeof history === 'string') {
                history = history.toArray(o.historyDivider);
            }
            if (append === true) {
                $.each(history, function () {
                    that.history.push(this);
                })
            } else{
                this.history = history;
            }
            this.historyIndex = this.history.length - 1;
        },

        clear: function(){
            this.element.val('');
        },

        toDefault: function(){
            this.element.val(Utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        setAutocompleteList: function(l){
            var autocomplete_list = Utils.isObject(l);
            if (autocomplete_list !== false) {
                this.autocomplete = autocomplete_list;
            } else if (typeof l === "string") {
                this.autocomplete = l.toArray(this.options.autocompleteDivider);
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var parent = element.parent();
            var clearBtn = parent.find(".input-clear-button");
            var revealBtn = parent.find(".input-reveal-button");
            var customBtn = parent.find(".input-custom-button");

            if (clearBtn.length > 0) {
                clearBtn.off(Metro.events.click);
            }
            if (revealBtn.length > 0) {
                revealBtn.off(Metro.events.start);
                revealBtn.off(Metro.events.stop);
            }
            if (customBtn.length > 0) {
                clearBtn.off(Metro.events.click);
            }

            element.off(Metro.events.blur);
            element.off(Metro.events.focus);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $('.input .autocomplete-list').hide();
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var LightboxDefaultConfig = {
        loop: true,
        source: "img",

        iconClose: "<span class='default-icon-cross'>",
        iconPrev: "<span class='default-icon-chevron-left'>",
        iconNext: "<span class='default-icon-chevron-right'>",

        clsNext: "",
        clsPrev: "",
        clsClose: "",
        clsImage: "",
        clsImageContainer: "",
        clsImageWrapper: "",
        clsLightbox: "",

        onDrawImage: Metro.noop,
        onLightboxCreate: Metro.noop
    };

    Metro.lightboxSetup = function (options) {
        LightboxDefaultConfig = $.extend({}, LightboxDefaultConfig, options);
    };

    if (typeof window["metroLightboxSetup"] !== undefined) {
        Metro.lightboxSetup(window["metroLightboxSetup"]);
    }

    Metro.Component('lightbox', {
        init: function( options, elem ) {
            this._super(elem, options, LightboxDefaultConfig, {
                // define instance vars here
                overlay: null,
                lightbox: null,
                current: null,
                items: []
            });
            return this;
        },

        _create: function(){
            var o = this.options;

            if (!o.source) {
                o.source = "img";
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent('lightbox-create');
        },

        _createStructure: function(){
            var o = this.options;
            var lightbox, overlay;

            overlay = $(".lightbox-overlay");

            if (overlay.length === 0) {
                overlay = $("<div>").addClass("lightbox-overlay").appendTo("body").hide();
            }

            lightbox = $("<div>").addClass("lightbox").addClass(o.clsLightbox).appendTo("body").hide();

            $("<span>").addClass("lightbox__prev").addClass(o.clsPrev).html(o.iconPrev).appendTo(lightbox);
            $("<span>").addClass("lightbox__next").addClass(o.clsNext).html(o.iconNext).appendTo(lightbox);
            $("<span>").addClass("lightbox__closer").addClass(o.clsClose).html(o.iconClose).appendTo(lightbox);
            $("<div>").addClass("lightbox__image").addClass(o.clsImageContainer).appendTo(lightbox);

            this.component = lightbox[0];
            this.lightbox = lightbox;
            this.overlay = overlay;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var lightbox = $(this.component);

            element.on(Metro.events.click, o.source, function(){
                that.open(this);
            });

            lightbox.on(Metro.events.click, ".lightbox__closer", function(){
                that.close();
            });

            lightbox.on(Metro.events.click, ".lightbox__prev", function(){
                that.prev();
            });

            lightbox.on(Metro.events.click, ".lightbox__next", function(){
                that.next();
            });
        },

        _setupItems: function(){
            var element = this.element, o = this.options;
            var items = element.find(o.source);

            if (items.length === 0) {
                return ;
            }

            this.items = items;
        },

        _goto: function(el){
            var that = this, o = this.options;
            var $el = $(el);
            var img = $("<img>"), src;
            var imageContainer, imageWrapper, activity;

            imageContainer = this.lightbox.find(".lightbox__image");

            imageContainer.find(".lightbox__image-wrapper").remove();
            imageWrapper = $("<div>")
                .addClass("lightbox__image-wrapper")
                .addClass(o.clsImageWrapper)
                .attr("data-title", ($el.attr("alt") || $el.attr("data-title") || ""))
                .appendTo(imageContainer);

            activity = $("<div>").appendTo(imageWrapper);

            Metro.makePlugin(activity, "activity", {
                type: "cycle",
                style: "color"
            });

            this.current = el;

            if (el.tagName === "IMG" || el.tagName === "DIV") {
                src = $el.attr("data-original") || $el.attr("src");
                img.attr("src", src);
                img[0].onload = function(){
                    var port = this.height > this.width;
                    img.addClass(port ? "lightbox__image-portrait" : "lightbox__image-landscape").addClass(o.clsImage);
                    img.attr("alt", $el.attr("alt"));
                    img.appendTo(imageWrapper);
                    activity.remove();
                    that._fireEvent("draw-image", {
                        image: img[0],
                        item: imageWrapper[0]
                    });
                }
            }
        },

        _index: function(el){
            var index = -1;

            this.items.each(function(i){
                if (this === el) {
                    index = i;
                }
            });

            return index;
        },

        next: function(){
            var index, current = this.current;

            index = this._index(current);

            if (index + 1 >= this.items.length) {
                if (this.options.loop) {
                    index = -1;
                } else {
                    return;
                }
            }

            this._goto(this.items[index + 1]);
        },

        prev: function(){
            var index, current = this.current;

            index = this._index(current);

            if (index - 1 < 0) {
                if (this.options.loop) {
                    index = this.items.length;
                } else {
                    return;
                }
            }

            this._goto(this.items[index - 1]);
        },

        open: function(el){
            this._setupItems();

            this._goto(el);

            this.overlay.show();
            this.lightbox.show();

            return this;
        },

        close: function(){
            this.overlay.hide();
            this.lightbox.hide();
        },

        changeAttribute: function(){
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ListDefaultConfig = {
        listDeferred: 0,
        templateBeginToken: "<%",
        templateEndToken: "%>",
        paginationDistance: 5,
        paginationShortMode: true,
        thousandSeparator: ",",
        decimalSeparator: ",",
        sortTarget: "li",
        sortClass: null,
        sortDir: "asc",
        sortInitial: true,
        filterClass: null,
        filter: null,
        filterString: "",
        filters: null,
        source: null,
        showItemsSteps: false,
        showSearch: false,
        showListInfo: false,
        showPagination: false,
        showActivity: true,
        muteList: true,
        items: -1,
        itemsSteps: "all, 10,25,50,100",
        itemsAllTitle: "Show all",
        listItemsCountTitle: "Show entries:",
        listSearchTitle: "Search:",
        listInfoTitle: "Showing $1 to $2 of $3 entries",
        paginationPrevTitle: "Prev",
        paginationNextTitle: "Next",
        activityType: "cycle",
        activityStyle: "color",
        activityTimeout: 100,
        searchWrapper: null,
        rowsWrapper: null,
        infoWrapper: null,
        paginationWrapper: null,
        clsComponent: "",
        clsList: "",
        clsListItem: "",
        clsListTop: "",
        clsItemsCount: "",
        clsSearch: "",
        clsListBottom: "",
        clsListInfo: "",
        clsListPagination: "",
        clsPagination: "",
        onDraw: Metro.noop,
        onDrawItem: Metro.noop,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSearch: Metro.noop,
        onRowsCountChange: Metro.noop,
        onDataLoad: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataLoadError: Metro.noop,
        onFilterItemAccepted: Metro.noop,
        onFilterItemDeclined: Metro.noop,
        onListCreate: Metro.noop
    };

    Metro.listSetup = function (options) {
        ListDefaultConfig = $.extend({}, ListDefaultConfig, options);
    };

    if (typeof window["metroListSetup"] !== undefined) {
        Metro.listSetup(window["metroListSetup"]);
    }

    Metro.Component('list', {
        init: function( options, elem ) {
            this._super(elem, options, ListDefaultConfig, {
                currentPage: 1,
                pagesCount: 1,
                filterString: "",
                data: null,
                activity: null,
                busy: false,
                filters: [],
                wrapperInfo: null,
                wrapperSearch: null,
                wrapperRows: null,
                wrapperPagination: null,
                filterIndex: null,
                filtersIndexes: [],
                itemTemplate: null,

                sort: {
                    dir: "asc",
                    colIndex: 0
                },

                header: null,
                items: []
            });

            return this;
        },

        _create: function(){
            var that = this, o = this.options;

            if (o.source) {
                that._fireEvent("data-load", {
                    source: o.source
                });

                $.json(o.source).then(function(data){
                    that._fireEvent("data-loaded", {
                        source: o.source,
                        data: data
                    });
                    that._build(data);
                }, function(xhr){
                    that._fireEvent("data-load-error", {
                        source: o.source,
                        xhr: xhr
                    });
                });
            } else {
                that._build();
            }
        },

        _build: function(data){
            if (Utils.isValue(data)) {
                this._createItemsFromJSON(data);
            } else {
                this._createItemsFromHTML()
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("list-create");
        },

        _createItemsFromHTML: function(){
            var that = this, element = this.element, o = this.options;

            this.items = [];

            $.each(element.children(o.sortTarget), function(){
                that.items.push(this);
            });
        },

        _createItemsFromJSON: function(source){
            var that = this, o = this.options;

            this.items = [];

            if (Utils.isValue(source.template)) {
                this.itemTemplate = source.template;
            }

            if (Utils.isValue(source.header)) {
                this.header = source.header;
            }

            if (Utils.isValue(source.data)) {
                $.each(source.data, function(){
                    var item, row = this;
                    var li = document.createElement("li");

                    if (!Utils.isValue(that.itemTemplate)) {
                        return ;
                    }

                    item = Metro.template(that.itemTemplate, row, {
                        beginToken: o.templateBeginToken,
                        endToken: o.templateEndToken
                    });

                    li.innerHTML = item;
                    that.items.push(li);
                });
            }
        },

        _createTopBlock: function (){
            var that = this, element = this.element, o = this.options;
            var top_block = $("<div>").addClass("list-top").addClass(o.clsListTop).insertBefore(element);
            var search_block, search_input, rows_block, rows_select;

            search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $("<div>").addClass("list-search-block").addClass(o.clsSearch).appendTo(top_block);

            search_input = $("<input>").attr("type", "text").appendTo(search_block);
            search_input.input({
                prepend: o.listSearchTitle
            });

            if (o.showSearch !== true) {
                search_block.hide();
            }

            rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $("<div>").addClass("list-rows-block").addClass(o.clsItemsCount).appendTo(top_block);

            rows_select = $("<select>").appendTo(rows_block);
            $.each(o.itemsSteps.toArray(), function () {
                var option = $("<option>").attr("value", this === "all" ? -1 : this).text(this === "all" ? o.itemsAllTitle : this).appendTo(rows_select);
                if (parseInt(this) === parseInt(o.items)) {
                    option.attr("selected", "selected");
                }
            });
            rows_select.select({
                filter: false,
                prepend: o.listItemsCountTitle,
                onChange: function (val) {
                    if (parseInt(val) === parseInt(o.items)) {
                        return;
                    }
                    o.items = parseInt(val);
                    that.currentPage = 1;
                    that._draw();

                    that._fireEvent("rows-count-change", {
                        val: val
                    });
                }
            });

            if (o.showItemsSteps !== true) {
                rows_block.hide();
            }

            return top_block;
        },

        _createBottomBlock: function (){
            var element = this.element, o = this.options;
            var bottom_block = $("<div>").addClass("list-bottom").addClass(o.clsListBottom).insertAfter(element);
            var info, pagination;

            info = $("<div>").addClass("list-info").addClass(o.clsListInfo).appendTo(bottom_block);
            if (o.showListInfo !== true) {
                info.hide();
            }

            pagination = $("<div>").addClass("list-pagination").addClass(o.clsListPagination).appendTo(bottom_block);
            if (o.showPagination !== true) {
                pagination.hide();
            }

            return bottom_block;
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var list_component;
            var w_search = $(o.searchWrapper),
                w_info = $(o.infoWrapper),
                w_rows = $(o.rowsWrapper),
                w_paging = $(o.paginationWrapper);

            if (w_search.length > 0) {this.wrapperSearch = w_search;}
            if (w_info.length > 0) {this.wrapperInfo = w_info;}
            if (w_rows.length > 0) {this.wrapperRows = w_rows;}
            if (w_paging.length > 0) {this.wrapperPagination = w_paging;}

            if (!element.parent().hasClass("list-component")) {
                list_component = $("<div>").addClass("list-component").insertBefore(element);
                element.appendTo(list_component);
            } else {
                list_component = element.parent();
            }

            list_component.addClass(o.clsComponent);

            this.activity =  $("<div>").addClass("list-progress").appendTo(list_component);
            $("<div>").activity({
                type: o.activityType,
                style: o.activityStyle
            }).appendTo(this.activity);

            if (o.showActivity !== true) {
                this.activity.css({
                    visibility: "hidden"
                })
            }

            // element.html("").addClass(o.clsList);
            element.addClass(o.clsList);

            this._createTopBlock();
            this._createBottomBlock();

            if (Utils.isValue(o.filterString)) {
                this.filterString = o.filterString;
            }

            var filter_func;

            if (Utils.isValue(o.filter)) {
                filter_func = Utils.isFunc(o.filter);
                if (filter_func === false) {
                    filter_func = Utils.func(o.filter);
                }
                that.filterIndex = that.addFilter(filter_func);
            }

            if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                $.each(o.filters.toArray(), function(){
                    filter_func = Utils.isFunc(this);
                    if (filter_func !== false) {
                        that.filtersIndexes.push(that.addFilter(filter_func));
                    }
                });
            }

            this.currentPage = 1;

            if (o.sortInitial !== false)
                this.sorting(o.sortClass, o.sortDir, true);
            else
                this.draw();
        },

        _createEvents: function(){
            var that = this, element = this.element;
            var component = element.parent();
            var search = component.find(".list-search-block input");
            var customSearch;

            search.on(Metro.events.inputchange, function(){
                that.filterString = this.value.trim().toLowerCase();
                if (that.filterString[that.filterString.length - 1] === ":") {
                    return ;
                }
                that.currentPage = 1;
                that._draw();
            });

            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.on(Metro.events.inputchange, function(){
                        that.filterString = this.value.trim().toLowerCase();
                        if (that.filterString[that.filterString.length - 1] === ":") {
                            return ;
                        }
                        that.currentPage = 1;
                        that._draw();
                    });
                }
            }

            function pageLinkClick(l){
                var link = $(l);
                var item = link.parent();

                if (item.hasClass("active")) {
                    return ;
                }

                if (item.hasClass("service")) {
                    if (link.data("page") === "prev") {
                        that.currentPage--;
                        if (that.currentPage === 0) {
                            that.currentPage = 1;
                        }
                    } else {
                        that.currentPage++;
                        if (that.currentPage > that.pagesCount) {
                            that.currentPage = that.pagesCount;
                        }
                    }
                } else {
                    that.currentPage = link.data("page");
                }

                that._draw();
            }

            component.on(Metro.events.click, ".pagination .page-link", function(){
                pageLinkClick(this)
            });

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.on(Metro.events.click, ".pagination .page-link", function(){
                    pageLinkClick(this)
                });
            }
        },

        _info: function(start, stop, length){
            var element = this.element, o = this.options;
            var component = element.parent();
            var info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".list-info");
            var text;

            if (info.length === 0) {
                return ;
            }

            if (stop > length) {
                stop = length;
            }

            if (this.items.length === 0) {
                start = stop = length = 0;
            }

            text = o.listInfoTitle;
            text = text.replace("$1", start);
            text = text.replace("$2", stop);
            text = text.replace("$3", length);
            info.html(text);
        },

        _paging: function(length){
            var element = this.element, o = this.options;
            var component = element.parent();
            this.pagesCount = Math.ceil(length / o.items); // Костыль
            Metro.pagination({
                length: length,
                rows: o.items,
                current: this.currentPage,
                target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".list-pagination"),
                claPagination: o.clsPagination,
                prevTitle: o.paginationPrevTitle,
                nextTitle: o.paginationNextTitle,
                distance: o.paginationShortMode === true ? o.paginationDistance : 0
            });
        },

        _filter: function(){
            var that = this,
                o = this.options,
                items, i, data, inset, c1, result;

            if (Utils.isValue(this.filterString) || this.filters.length > 0) {
                items = this.items.filter(function(item){
                    data = "";

                    if (Utils.isValue(o.filterClass)) {
                        inset = item.getElementsByClassName(o.filterClass);

                        if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                            data += inset[i].textContent;
                        }
                    } else {
                        data = item.textContent;
                    }

                    c1 = data.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim().toLowerCase();
                    result = Utils.isValue(that.filterString) ? c1.indexOf(that.filterString) > -1 : true;

                    if (result === true && that.filters.length > 0) {
                        for (i = 0; i < that.filters.length; i++) {
                            if (Utils.exec(that.filters[i], [item]) !== true) {
                                result = false;
                                break;
                            }
                        }
                    }

                    if (result) {

                        that._fireEvent("filter-item-accepted", {
                            item: item
                        });

                    } else {

                        that._fireEvent("filter-item-declined", {
                            item: item
                        });

                    }

                    return result;
                });

                that._fireEvent("search", {
                    search: that.filterString,
                    items: items
                });

            } else {
                items = this.items;
            }

            return items;
        },

        _draw: function(cb){
            var element = this.element, o = this.options;
            var i;
            var start = o.items === -1 ? 0 : o.items * (this.currentPage - 1),
                stop = o.items === -1 ? this.items.length - 1 : start + o.items - 1;
            var items;

            items = this._filter();

            element.children(o.sortTarget).remove();

            for (i = start; i <= stop; i++) {
                if (Utils.isValue(items[i])) {
                    $(items[i]).addClass(o.clsListItem).appendTo(element);
                }

                this._fireEvent("draw-item", {
                    item: items[i]
                });

            }

            this._info(start + 1, stop + 1, items.length);
            this._paging(items.length);

            this.activity.hide();

            this._fireEvent("draw");

            if (cb !== undefined) {
                Utils.exec(cb, [element], element[0])
            }
        },

        _getItemContent: function(item){
            var o = this.options, $item = $(item);
            var i, inset, data;
            var format, formatMask = Utils.isValue($item.data("formatMask")) ? $item.data("formatMask") : null;

            if (Utils.isValue(o.sortClass)) {
                data = "";
                inset = $(item).find("."+o.sortClass);

                if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                    data += inset[i].textContent;
                }
                format = inset.length > 0 ? inset[0].getAttribute("data-format") : "";
            } else {
                data = item.textContent;
                format = item.getAttribute("data-format");
            }

            data = (""+data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(format)) {

                if (['number', 'int', 'integer', 'float', 'money'].indexOf(format) !== -1 && (o.thousandSeparator !== "," || o.decimalSeparator !== "." )) {
                    data = Utils.parseNumber(data, o.thousandSeparator, o.decimalSeparator);
                }

                switch (format) {
                    case "date": data = Utils.isValue(formatMask) ? data.toDate(formatMask) : new Date(data); break;
                    case "number": data = Number(data); break;
                    case "int":
                    case "integer": data = parseInt(data); break;
                    case "float": data = parseFloat(data); break;
                    case "money": data = Utils.parseMoney(data); break;
                    case "card": data = Utils.parseCard(data); break;
                    case "phone": data = Utils.parsePhone(data); break;
                }
            }

            return data;
        },

        deleteItem: function(value){
            var i, deleteIndexes = [], item;
            var is_func = Utils.isFunc(value);

            for (i = 0; i < this.items.length; i++) {
                item = this.items[i];

                if (is_func) {
                    if (Utils.exec(value, [item])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (item.textContent.contains(value)) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        draw: function(){
            return this._draw();
        },

        sorting: function(source, dir, redraw){
            var that = this, o = this.options;

            if (Utils.isValue(source)) {
                o.sortClass = source;
            }
            if (Utils.isValue(dir) && ["asc", "desc"].indexOf(dir) > -1) {
                o.sortDir= dir;
            }

            this._fireEvent("sort-start", {
                items: this.items
            });

            this.items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2) {
                    result = o.sortDir === "asc" ? -1 : 1;
                }
                if (c1 > c2) {
                    result = o.sortDir === "asc" ? 1 : -1;
                }

                if (result !== 0) {

                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            this._fireEvent("sort-stop", {
                items: this.items
            })

            if (redraw === true) {
                this._draw();
            }

            return this;
        },

        filter: function(val){
            this.filterString = val.trim().toLowerCase();
            this.currentPage = 1;
            this._draw();
        },

        loadData: function(source){
            var that = this, element = this.element, o = this.options;

            if (Utils.isValue(source) !== true) {
                return ;
            }

            o.source = source;

            this._fireEvent("data-load", {
                source: o.source
            });

            $.json(o.source).then(function(data){

                that._fireEvent("data-loaded", {
                    source: o.source,
                    data: data
                });

                that._createItemsFromJSON(data);

                element.html("");

                if (Utils.isValue(o.filterString)) {
                    that.filterString = o.filterString;
                }

                var filter_func;

                if (Utils.isValue(o.filter)) {
                    filter_func = Utils.isFunc(o.filter);
                    if (filter_func === false) {
                        filter_func = Utils.func(o.filter);
                    }
                    that.filterIndex = that.addFilter(filter_func);
                }

                if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                    $.each(o.filters.toArray(), function(){
                        filter_func = Utils.isFunc(this);
                        if (filter_func !== false) {
                            that.filtersIndexes.push(that.addFilter(filter_func));
                        }
                    });
                }

                that.currentPage = 1;

                that.sorting(o.sortClass, o.sortDir, true);
            }, function(xhr){

                that._fireEvent("data-load-error", {
                    source: o.source,
                    xhr: xhr
                });

            });
        },

        next: function(){
            if (this.items.length === 0) return ;
            this.currentPage++;
            if (this.currentPage > this.pagesCount) {
                this.currentPage = this.pagesCount;
                return ;
            }
            this._draw();
        },

        prev: function(){
            if (this.items.length === 0) return ;
            this.currentPage--;
            if (this.currentPage === 0) {
                this.currentPage = 1;
                return ;
            }
            this._draw();
        },

        first: function(){
            if (this.items.length === 0) return ;
            this.currentPage = 1;
            this._draw();
        },

        last: function(){
            if (this.items.length === 0) return ;
            this.currentPage = this.pagesCount;
            this._draw();
        },

        page: function(num){
            if (num <= 0) {
                num = 1;
            }

            if (num > this.pagesCount) {
                num = this.pagesCount;
            }

            this.currentPage = num;
            this._draw();
        },

        addFilter: function(f, redraw){
            var func = Utils.isFunc(f);
            if (func === false) {
                return ;
            }
            this.filters.push(func);

            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }

            return this.filters.length - 1;
        },

        removeFilter: function(key, redraw){
            Utils.arrayDeleteByKey(this.filters, key);
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        removeFilters: function(redraw){
            this.filters = [];
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
        },

        getFilters: function(){
            return this.filters;
        },

        getFilterIndex: function(){
            return this.filterIndex;
        },

        getFiltersIndexes: function(){
            return this.filtersIndexes;
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeSortDir = function(){
                var dir = element.attr("data-sort-dir");
                if (!Utils.isValue(dir)) {
                    return ;
                }
                o.sortDir = dir;
                that.sorting(o.sortClass, o.sortDir, true);
            };

            var changeSortClass = function(){
                var target = element.attr("data-sort-source");
                if (!Utils.isValue(target)) {
                    return ;
                }
                o.sortClass = target;
                that.sorting(o.sortClass, o.sortDir, true);
            };

            var changeFilterString = function(){
                var filter = element.attr("data-filter-string");
                if (!Utils.isValue(filter)) {
                    return ;
                }
                o.filterString = filter;
                that.filter(o.filterString);
            };

            switch (attributeName) {
                case "data-sort-dir": changeSortDir(); break;
                case "data-sort-source": changeSortClass(); break;
                case "data-filter-string": changeFilterString(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var component = element.parent();
            var search = component.find(".list-search-block input");
            var customSearch;

            search.off(Metro.events.inputchange);
            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.off(Metro.events.inputchange);
                }
            }

            component.off(Metro.events.click, ".pagination .page-link");

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.off(Metro.events.click, ".pagination .page-link");
            }

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ListViewDefaultConfig = {
        listviewDeferred: 0,
        selectable: false,
        checkStyle: 1,
        duration: 100,
        view: Metro.listView.LIST,
        selectCurrent: true,
        structure: {},
        onNodeInsert: Metro.noop,
        onNodeDelete: Metro.noop,
        onNodeClean: Metro.noop,
        onCollapseNode: Metro.noop,
        onExpandNode: Metro.noop,
        onGroupNodeClick: Metro.noop,
        onNodeClick: Metro.noop,
        onNodeDblclick: Metro.noop,
        onListViewCreate: Metro.noop
    };

    Metro.listViewSetup = function (options) {
        ListViewDefaultConfig = $.extend({}, ListViewDefaultConfig, options);
    };

    if (typeof window["metroListViewSetup"] !== undefined) {
        Metro.listViewSetup(window["metroListViewSetup"]);
    }

    Metro.Component('listview', {
        init: function( options, elem ) {
            this._super(elem, options, ListViewDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createView();
            this._createEvents();

            this._fireEvent("listview-create", {
                element: element
            });
        },

        _createIcon: function(data){
            var icon, src;

            src = Utils.isTag(data) ? $(data) : $("<img>").attr("src", data);
            icon = $("<span>").addClass("icon");
            icon.html(src.outerHTML());

            return icon;
        },

        _createCaption: function(data){
            return $("<div>").addClass("caption").html(data);
        },

        _createContent: function(data){
            return $("<div>").addClass("content").html(data);
        },

        _createToggle: function(){
            return $("<span>").addClass("node-toggle");
        },

        _createNode: function(data){
            var that = this, o = this.options;
            var node;

            node = $("<li>");

            if (data.caption !== undefined || data.content !== undefined ) {
                var d = $("<div>").addClass("data");
                node.prepend(d);
                if (data.caption !== undefined) d.append(that._createCaption(data.caption));
                if (data.content !== undefined) d.append(that._createContent(data.content));
            }

            if (data.icon !== undefined) {
                node.prepend(this._createIcon(data.icon));
            }

            if (Utils.objectLength(o.structure) > 0) $.each(o.structure, function(key, val){
                if (data[key] !== undefined) {
                    $("<div>").addClass("node-data item-data-"+key).addClass(data[val]).html(data[key]).appendTo(node);
                }
            });

            return node;
        },

        _createView: function(){
            var that = this, element = this.element, o = this.options;
            var nodes = element.find("li");
            var struct_length = Utils.objectLength(o.structure);

            element.addClass("listview");
            element.find("ul").addClass("listview");

            $.each(nodes, function(){
                var node = $(this);

                if (node.data("caption") !== undefined || node.data("content") !== undefined) {
                    var data = $("<div>").addClass("data");
                    node.prepend(data);
                    if (node.data("caption") !== undefined) data.append(that._createCaption(node.data("caption")));
                    if (node.data("content") !== undefined) data.append(that._createContent(node.data("content")));
                }

                if (node.data('icon') !== undefined) {
                    node.prepend(that._createIcon(node.data('icon')));
                }

                if (node.children("ul").length > 0) {
                    node.addClass("node-group");
                    node.append(that._createToggle());
                    if (node.data("collapsed") !== true) node.addClass("expanded");
                } else {
                    node.addClass("node");
                }

                if (node.hasClass("node")) {
                    var cb = $("<input type='checkbox' data-role='checkbox' data-style='"+o.checkStyle+"'>");
                    cb.data("node", node);
                    node.prepend(cb);
                }

                if (struct_length > 0) $.each(o.structure, function(key){
                    if (node.data(key) !== undefined) {
                        $("<div>").addClass("node-data item-data-"+key).addClass(node.data(key)).html(node.data(key)).appendTo(node);
                    }
                });
            });

            this.toggleSelectable();

            this.view(o.view);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.dblclick, ".node", function(){
                var node = $(this);
                that._fireEvent("node-dblclick", {
                    node: node
                });
            });

            element.on(Metro.events.click, ".node", function(){
                var node = $(this);
                element.find(".node").removeClass("current");
                node.toggleClass("current");
                if (o.selectCurrent === true) {
                    element.find(".node").removeClass("current-select");
                    node.toggleClass("current-select");
                }
                that._fireEvent("node-click", {
                    node: node
                });
            });

            element.on(Metro.events.click, ".node-toggle", function(){
                var node = $(this).closest("li");
                that.toggleNode(node);
            });

            element.on(Metro.events.click, ".node-group > .data > .caption", function(){
                var node = $(this).closest("li");
                element.find(".node-group").removeClass("current-group");
                node.addClass("current-group");

                that._fireEvent("group-node-click", {
                    node: node
                });

            });

            element.on(Metro.events.dblclick, ".node-group > .data > .caption", function(){
                var node = $(this).closest("li");
                that.toggleNode(node);

                that._fireEvent("node-dbl-click", {
                    node: node
                });
            });
        },

        view: function(v){
            var element = this.element, o = this.options;

            if (v === undefined) {
                return o.view;
            }

            o.view = v;

            $.each(Metro.listView, function(i, v){
                element.removeClass("view-"+v);
                element.find("ul").removeClass("view-"+v);
            });

            element.addClass("view-" + o.view);
            element.find("ul").addClass("view-" + o.view);
        },

        toggleNode: function(node){
            var o = this.options;
            var func;

            node=$(node);

            if (!node.hasClass("node-group")) {
                return ;
            }

            node.toggleClass("expanded");

            func = node.hasClass("expanded") !== true ? "slideUp" : "slideDown";

            this._fireEvent("collapse-node", {
                node: node
            });

            node.children("ul")[func](o.duration);
        },

        toggleSelectable: function(){
            var element = this.element, o = this.options;
            var func = o.selectable === true ? "addClass" : "removeClass";
            element[func]("selectable");
            element.find("ul")[func]("selectable");
        },

        add: function(node, data){
            var element = this.element, o = this.options;
            var target;
            var new_node;
            var toggle;

            if (node === null) {
                target = element;
            } else {

                node=$(node);

                if (!node.hasClass("node-group")) {
                    return ;
                }

                target = node.children("ul");
                if (target.length === 0) {
                    target = $("<ul>").addClass("listview").addClass("view-"+o.view).appendTo(node);
                    toggle = this._createToggle();
                    toggle.appendTo(node);
                    node.addClass("expanded");
                }
            }

            new_node = this._createNode(data);

            new_node.addClass("node").appendTo(target);

            var cb = $("<input type='checkbox'>");
            cb.data("node", new_node);
            new_node.prepend(cb);
            Metro.makePlugin(cb, "checkbox", {});

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: node,
                list: target
            });

            return new_node;
        },

        addGroup: function(data){
            var element = this.element, o = this.options;
            var node;

            delete data['icon'];

            node = this._createNode(data);
            node.addClass("node-group").appendTo(element);
            node.append(this._createToggle());
            node.addClass("expanded");
            node.append($("<ul>").addClass("listview").addClass("view-"+o.view));

            this._fireEvent("node-insert", {
                newNode: node,
                parentNode: null,
                list: element
            })

            return node;
        },

        insertBefore: function(node, data){
            var new_node, parent_node, list;

            node=$(node);

            if (!node.length) {return;}

            new_node = this._createNode(data);
            new_node.addClass("node").insertBefore(node);
            parent_node = new_node.closest(".node");
            list = new_node.closest("ul");

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: parent_node,
                list: list
            });

            return new_node;
        },

        insertAfter: function(node, data){
            var new_node, parent_node, list;

            node=$(node);

            if (!node.length) {return;}

            new_node = this._createNode(data);
            new_node.addClass("node").insertAfter(node);
            parent_node = new_node.closest(".node");
            list = new_node.closest("ul");

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: parent_node,
                list: list
            });

            return new_node;
        },

        del: function(node){
            var element = this.element;

            node=$(node);

            if (!node.length) {return;}

            var parent_list = node.closest("ul");
            var parent_node = parent_list.closest("li");
            node.remove();
            if (parent_list.children().length === 0 && !parent_list.is(element)) {
                parent_list.remove();
                parent_node.removeClass("expanded");
                parent_node.children(".node-toggle").remove();
            }

            this._fireEvent("node-delete", {
                node: node
            });
        },

        clean: function(node){
            node=$(node);

            if (!node.length) {return;}

            node.children("ul").remove();
            node.removeClass("expanded");
            node.children(".node-toggle").remove();

            this._fireEvent("node-clean", {
                node: node
            });
        },

        getSelected: function(){
            var element = this.element;
            var nodes = [];

            $.each(element.find(":checked"), function(){
                var check = $(this);
                nodes.push(check.closest(".node")[0])
            });

            return nodes;
        },

        clearSelected: function(){
            this.element.find(":checked").prop("checked", false);
            this.element.trigger('change');
        },

        selectAll: function(mode){
            this.element.find(".node > .checkbox input").prop("checked", mode !== false);
            this.element.trigger('change');
        },

        selectByAttribute: function(attributeName, attributeValue, select) {
            if (select !== false) {
                select = true;
            }
            this.element.find('li[' + attributeName + '="' + attributeValue + '"]' + ' > .checkbox input').prop("checked", select);
            this.element.trigger('change');
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeView = function(){
                var new_view = "view-"+element.attr("data-view");
                that.view(new_view);
            };

            var changeSelectable = function(){
                o.selectable = JSON.parse(element.attr("data-selectable")) === true;
                that.toggleSelectable();
            };

            switch (attributeName) {
                case "data-view": changeView(); break;
                case "data-selectable": changeSelectable(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".node");
            element.off(Metro.events.click, ".node-toggle");
            element.off(Metro.events.click, ".node-group > .data > .caption");
            element.off(Metro.events.dblclick, ".node-group > .data > .caption");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var NavigationViewDefaultConfig = {
        navviewDeferred: 0,
        compact: "md",
        expand: "lg",
        toggle: null,
        activeState: false,
        onMenuItemClick: Metro.noop,
        onNavviewCreate: Metro.noop
    };

    Metro.navViewSetup = function (options) {
        NavigationViewDefaultConfig = $.extend({}, NavigationViewDefaultConfig, options);
    };

    if (typeof window["metroNavViewSetup"] !== undefined) {
        Metro.navViewSetup(window["metroNavViewSetup"]);
    }

    Metro.Component('nav-view', {
        init: function( options, elem ) {
            this._super(elem, options, NavigationViewDefaultConfig, {
                pane: null,
                content: null,
                paneToggle: null,
                id: Utils.elementId("navview"),
                menuScrollDistance: 0,
                menuScrollStep: 0
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("navview-create");
        },

        _calcMenuHeight: function(){
            var element = this.element, pane, menu_container;
            var elements_height = 0;

            pane = element.children(".navview-pane");
            if (pane.length === 0) {
                return;
            }

            menu_container = pane.children(".navview-menu-container");

            if (menu_container.length === 0) {
                return ;
            }

            $.each(menu_container.prevAll(), function(){
                elements_height += $(this).outerHeight(true);
            });

            $.each(menu_container.nextAll(), function(){
                elements_height += $(this).outerHeight(true);
            });

            menu_container.css({
                height: "calc(100% - "+(elements_height)+"px)"
            });

            this.menuScrollStep = 48;
            this.menuScrollDistance = Utils.nearest(menu_container[0].scrollHeight - menu_container.height(), 48);
        },

        _recalc: function(){
            var that = this, element = this.element;
            setTimeout(function(){
                if (that.pane.width() === 48) {
                    element.addClass("js-compact");
                } else {
                    element.removeClass("js-compact");
                }
                that._calcMenuHeight();
            }, 200);
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var pane, content, toggle, menu/*, menu_container, menu_h, menu_container_h*/;

            element
                .addClass("navview")
                .addClass(o.compact !== false ? "navview-compact-"+o.compact : "")
                .addClass(o.expand !== false ? "navview-expand-"+o.expand : "");

            pane = element.children(".navview-pane");
            content = element.children(".navview-content");
            toggle = $(o.toggle);
            menu = pane.children(".navview-menu");

            if (menu.length) {
                menu.prevAll().reverse().wrapAll($("<div>").addClass("navview-container"));
                menu.wrap($("<div>").addClass("navview-menu-container"));
            }

            this.pane = pane.length > 0 ? pane : null;
            this.content = content.length > 0 ? content : null;
            this.paneToggle = toggle.length > 0 ? toggle : null;

            this._recalc();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var menu_container = element.find(".navview-menu-container");
            var menu = menu_container.children(".navview-menu");

            menu_container.on("mousewheel", function(e){
                var pane_width = element.find(".navview-pane").width();
                var dir = e.deltaY > 0 ? -1 : 1;
                var step = that.menuScrollStep;
                var distance = that.menuScrollDistance;
                var top = parseInt(menu.css('top'));

                if (pane_width > 48 /*|| !element.hasClass("compacted") */) {
                    return false;
                }

                if(dir === -1 && Math.abs(top) <= distance) {
                    menu.css('top', parseInt(menu.css('top')) + step * dir);
                }

                if(dir === 1 && top <= -step) {
                    menu.css('top', parseInt(menu.css('top')) + step * dir);
                }
            });

            element.on(Metro.events.click, ".pull-button, .holder", function(){
                that.pullClick(this);
            });

            element.on(Metro.events.click, ".navview-menu li", function(){
                if (o.activeState === true) {
                    element.find(".navview-menu li").removeClass("active");
                    $(this).toggleClass("active");
                }
            });

            element.on(Metro.events.click, ".navview-menu li > a", function(){

                that._fireEvent("menu-item-click", {
                    item: this
                });

            });

            if (this.paneToggle !== null) {
                this.paneToggle.on(Metro.events.click, function(){
                    that.pane.toggleClass("open");
                })
            }

            $(window).on(Metro.events.resize, function(){
                var menu_h, menu_container_h,
                    menu_container = element.children(".navview-menu-container"),
                    menu;

                if (that.pane.hasClass("open")) {
                    that._recalc();
                    return ;
                }

                element.removeClass("expanded");
                that.pane.removeClass("open");

                if ($(this).width() <= Metro.media_sizes[(""+o.compact).toUpperCase()]) {
                    element.removeClass("compacted");
                }

                if (menu_container.length) {
                    menu = menu_container.children(".navview-menu");
                    setTimeout(function () {
                        menu_h = menu.height();
                        menu_container_h = menu_container.height();
                        that.menuScrollStep = menu.children(":not(.item-separator), :not(.item-header)")[0].clientHeight;
                        that.menuScrollDistance = menu_h > menu_container_h ? Utils.nearest(menu_h - menu_container_h, that.menuScrollStep) : 0;
                    }, 0);
                }

                that._recalc();

            }, {ns: this.id})
        },

        _togglePaneMode: function(){
            var element = this.element;
            var pane = this.pane;
            var pane_compact = pane.width() < 280;

            if ((pane_compact || element.hasClass("expanded")) && !element.hasClass("compacted")) {
                element.toggleClass("expanded");
            } else

            if (element.hasClass("compacted") || !pane_compact) {
                element.toggleClass("compacted");
            }

        },

        pullClick: function(el){
            var that = this;
            var input;

            var target = $(el);

            if (target && target.hasClass("holder")) {
                input = target.parent().find("input");
                setTimeout(function(){
                    input.focus();
                }, 200);
            }

            if (that.pane.hasClass("open")) {
                that.close();
            } else {
                this._togglePaneMode();
            }

            this._recalc();

            return true;
        },

        open: function(){
            this.pane.addClass("open");
        },

        close: function(){
            this.pane.removeClass("open");
        },

        toggle: function(){
            var pane = this.pane;
            pane.hasClass("open") ? pane.removeClass("open") : pane.addClass("open");
        },

        toggleMode: function(){
            this._togglePaneMode();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".pull-button, .holder");
            element.off(Metro.events.click, ".navview-menu li");
            element.off(Metro.events.click, ".navview-menu li > a");

            if (this.paneToggle !== null) {
                this.paneToggle.off(Metro.events.click);
            }

            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var NotifyDefaultConfig = {
        container: null,
        width: 220,
        timeout: METRO_TIMEOUT,
        duration: METRO_ANIMATION_DURATION,
        distance: "max",
        animation: "linear",
        onClick: Metro.noop,
        onClose: Metro.noop,
        onShow: Metro.noop,
        onAppend: Metro.noop,
        onNotifyCreate: Metro.noop

    };

    Metro.notifySetup = function(options){
        NotifyDefaultConfig = $.extend({}, NotifyDefaultConfig, options);
    };

    if (typeof window["metroNotifySetup"] !== undefined) {
        Metro.notifySetup(window["metroNotifySetup"]);
    }

    var Notify = {

        container: null,

        options: {
        },

        notifies: [],

        setup: function(options){
            this.options = $.extend({}, NotifyDefaultConfig, options);

            return this;
        },

        reset: function(){
            var reset_options = {
                width: 220,
                timeout: METRO_TIMEOUT,
                duration: METRO_ANIMATION_DURATION,
                distance: "max",
                animation: "linear"
            };
            this.options = $.extend({}, NotifyDefaultConfig, reset_options);
        },

        _createContainer: function(){

            var container = $("<div>").addClass("notify-container");
            $("body").prepend(container);

            return container;
        },

        create: function(message, title, options){
            var notify, that = this, o = this.options;
            var m, t, id = Utils.elementId("notify");

            if (Utils.isNull(options)) {
                options = {};
            }

            if (!Utils.isValue(message)) {
                return false;
            }

            notify = $("<div>").addClass("notify").attr("id", id);
            notify.css({
                width: o.width
            });

            if (title) {
                t = $("<div>").addClass("notify-title").html(title);
                notify.prepend(t);
            }
            m = $("<div>").addClass("notify-message").html(message);
            m.appendTo(notify);

            // Set options
            /*
            * keepOpen, cls, width, callback
            * */
            if (options !== undefined) {
                if (options.cls !== undefined) {
                    notify.addClass(options.cls);
                }
                if (options.width !== undefined) {
                    notify.css({
                        width: options.width
                    });
                }
            }

            notify.on(Metro.events.click, function(){
                Utils.exec(Utils.isValue(options.onClick) ? options.onClick : o.onClick, null, this);
                that.kill($(this).closest(".notify"), Utils.isValue(options.onClose) ? options.onClose : o.onClose);
            });

            // Show
            if (Notify.container === null) {
                Notify.container = Notify._createContainer();
            }
            notify.appendTo(Notify.container);

            notify.hide(function(){

                Utils.exec(Utils.isValue(options.onAppend) ? options.onAppend : o.onAppend, null, notify[0]);

                var duration = Utils.isValue(options.duration) ? options.duration : o.duration;
                var animation = Utils.isValue(options.animation) ? options.animation : o.animation;
                var distance = Utils.isValue(options.distance) ? options.distance : o.distance;

                if (distance === "max" || isNaN(distance)) {
                    distance = $(window).height();
                }

                notify
                    .show()
                    .animate({
                        draw: {
                            marginTop: [distance, 4],
                            opacity: [0, 1]
                        },
                        dur: duration,
                        ease: animation,
                        onDone: function(){
                            Utils.exec(o.onNotifyCreate, null, this);

                            if (options !== undefined && options.keepOpen === true) {
                                /* eslint-disable-next-line */

                            } else {
                                setTimeout(function(){
                                    that.kill(notify, Utils.isValue(options.onClose) ? options.onClose : o.onClose);
                                }, o.timeout);
                            }

                            Utils.exec(Utils.isValue(options.onShow) ? options.onShow : o.onShow, null, notify[0]);
                        }
                    });

            });
        },

        kill: function(notify, callback){
            var that = this, o = this.options;
            notify.off(Metro.events.click);
            notify.fadeOut(o.duration, 'linear', function(){
                Utils.exec(Utils.isValue(callback) ? callback : that.options.onClose, null, notify[0]);
                notify.remove();
            });
        },

        killAll: function(){
            var that = this;
            var notifies = $(".notify");
            $.each(notifies, function(){
                that.kill($(this));
            });
        }
    };

    Metro['notify'] = Notify.setup();
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    Metro.pagination = function(c){
        var defConf = {
            length: 0,
            rows: 0,
            current: 0,
            target: "body",
            clsPagination: "",
            prevTitle: "Prev",
            nextTitle: "Next",
            distance: 5
        }, conf;
        var pagination;
        var pagination_wrapper;
        var i, prev, next;
        var shortDistance;

        conf = $.extend( {}, defConf, c);

        shortDistance = parseInt(conf.distance);
        pagination_wrapper = $(conf.target);
        pagination_wrapper.html("");
        pagination = $("<ul>").addClass("pagination").addClass(conf.clsPagination).appendTo(pagination_wrapper);

        if (conf.length === 0) {
            return ;
        }

        if (conf.rows === -1) {
            return ;
        }

        conf.pages = Math.ceil(conf.length / conf.rows);

        var add_item = function(item_title, item_type, data){
            var li, a;

            li = $("<li>").addClass("page-item").addClass(item_type);
            a  = $("<a>").addClass("page-link").html(item_title);
            a.data("page", data);
            a.appendTo(li);

            return li;
        };

        prev = add_item(conf.prevTitle, "service prev-page", "prev");
        pagination.append(prev);

        pagination.append(add_item(1, conf.current === 1 ? "active" : "", 1));

        if (shortDistance === 0 || conf.pages <= 7) {
            for (i = 2; i < conf.pages; i++) {
                pagination.append(add_item(i, i === conf.current ? "active" : "", i));
            }
        } else {
            if (conf.current < shortDistance) {
                for (i = 2; i <= shortDistance; i++) {
                    pagination.append(add_item(i, i === conf.current ? "active" : "", i));
                }

                if (conf.pages > shortDistance) {
                    pagination.append(add_item("...", "no-link", null));
                }
            } else if (conf.current <= conf.pages && conf.current > conf.pages - shortDistance + 1) {
                if (conf.pages > shortDistance) {
                    pagination.append(add_item("...", "no-link", null));
                }

                for (i = conf.pages - shortDistance + 1; i < conf.pages; i++) {
                    pagination.append(add_item(i, i === conf.current ? "active" : "", i));
                }
            } else {
                pagination.append(add_item("...", "no-link", null));

                pagination.append(add_item(conf.current - 1, "", conf.current - 1));
                pagination.append(add_item(conf.current, "active", conf.current));
                pagination.append(add_item(conf.current + 1, "", conf.current + 1));

                pagination.append(add_item("...", "no-link", null));
            }
        }

        if (conf.pages > 1 || conf.current < conf.pages) pagination.append(add_item(conf.pages, conf.current === conf.pages ? "active" : "", conf.pages));

        next = add_item(conf.nextTitle, "service next-page", "next");
        pagination.append(next);

        if (conf.current === 1) {
            prev.addClass("disabled");
        }

        if (conf.current === conf.pages) {
            next.addClass("disabled");
        }

        if (conf.length === 0) {
            pagination.addClass("disabled");
            pagination.children().addClass("disabled");
        }

        return pagination;
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var PanelDefaultConfig = {
        panelDeferred: 0,
        id: null,
        titleCaption: "",
        titleIcon: "",
        collapsible: false,
        collapsed: false,
        collapseDuration: METRO_ANIMATION_DURATION,
        width: "auto",
        height: "auto",
        draggable: false,

        customButtons: null,
        clsCustomButton: "",

        clsPanel: "",
        clsTitle: "",
        clsTitleCaption: "",
        clsTitleIcon: "",
        clsContent: "",
        clsCollapseToggle: "",

        onCollapse: Metro.noop,
        onExpand: Metro.noop,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onPanelCreate: Metro.noop
    };

    Metro.panelSetup = function (options) {
        PanelDefaultConfig = $.extend({}, PanelDefaultConfig, options);
    };

    if (typeof window["metroPanelSetup"] !== undefined) {
        Metro.panelSetup(window["metroPanelSetup"]);
    }

    Metro.Component('panel', {
        init: function( options, elem ) {
            this._super(elem, options, PanelDefaultConfig);

            return this;
        },

        _addCustomButtons: function(buttons){
            var element = this.element, o = this.options;
            var title = element.closest(".panel").find(".panel-title");
            var buttonsContainer, customButtons = [];

            if (typeof buttons === "string" && buttons.indexOf("{") > -1) {
                customButtons = JSON.parse(buttons);
            } else if (typeof buttons === "string" && Utils.isObject(buttons)) {
                customButtons = Utils.isObject(buttons);
            } else if (typeof buttons === "object" && Utils.objectLength(buttons) > 0) {
                customButtons = buttons;
            } else {
                console.warn("Unknown format for custom buttons", buttons);
                return ;
            }

            if (title.length === 0) {
                console.warn("No place for custom buttons");
                return ;
            }

            buttonsContainer = title.find(".custom-buttons");

            if (buttonsContainer.length === 0) {
                buttonsContainer = $("<div>").addClass("custom-buttons").appendTo(title);
            } else {
                buttonsContainer.find(".btn-custom").off(Metro.events.click);
                buttonsContainer.html("");
            }

            $.each(customButtons, function(){
                var item = this;
                var customButton = $("<span>");

                customButton
                    .addClass("button btn-custom")
                    .addClass(o.clsCustomButton)
                    .addClass(item.cls)
                    .attr("tabindex", -1)
                    .html(item.html);

                if (item.attr && typeof item.attr === 'object') {
                    $.each(item.attr, function(k, v){
                        customButton.attr($.dashedName(k), v);
                    });
                }

                customButton.data("action", item.onclick);

                buttonsContainer.prepend(customButton);
            });

            title.on(Metro.events.click, ".btn-custom", function(e){
                if (Utils.isRightMouse(e)) return;
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [button], this);
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var panel = $("<div>").addClass("panel").addClass(o.clsPanel);
            var id = o.id ? o.id : Utils.elementId("panel");
            var original_classes = element[0].className;
            var title;

            panel.attr("id", id).addClass(original_classes);
            panel.insertBefore(element);
            element.appendTo(panel);

            element[0].className = '';
            element.addClass("panel-content").addClass(o.clsContent).appendTo(panel);

            if (o.titleCaption !== "" || o.titleIcon !== "" || o.collapsible === true) {
                title = $("<div>").addClass("panel-title").addClass(o.clsTitle);

                if (o.titleCaption !== "") {
                    $("<span>").addClass("caption").addClass(o.clsTitleCaption).html(o.titleCaption).appendTo(title)
                }

                if (o.titleIcon !== "") {
                    $(o.titleIcon).addClass("icon").addClass(o.clsTitleIcon).appendTo(title)
                }

                if (o.collapsible === true) {
                    var collapseToggle = $("<span>").addClass("dropdown-toggle marker-center active-toggle").addClass(o.clsCollapseToggle).appendTo(title);
                    Metro.makePlugin(element, "collapse", {
                        toggleElement: collapseToggle,
                        duration: o.collapseDuration,
                        onCollapse: o.onCollapse,
                        onExpand: o.onExpand
                    });

                    if (o.collapsed === true) {
                        this.collapse();
                    }
                }

                title.appendTo(panel);
            }

            if (title && Utils.isValue(o.customButtons)) {
                this._addCustomButtons(o.customButtons);
            }

            if (o.draggable === true) {
                var dragElement;

                if (title) {
                    dragElement = title.find(".caption, .icon");
                } else {
                    dragElement = panel;
                }

                Metro.makePlugin(panel, "draggable", {
                    dragContext: panel[0],
                    dragElement: dragElement,
                    onDragStart: o.onDragStart,
                    onDragStop: o.onDragStop,
                    onDragMove: o.onDragMove
                });
            }

            if (o.width !== "auto" && parseInt(o.width) >= 0) {
                panel.outerWidth(parseInt(o.width));
            }

            if (o.height !== "auto" && parseInt(o.height) >= 0) {
                panel.outerHeight(parseInt(o.height));
                element.css({overflow: "auto"});
            }

            this.panel = panel;

            this._fireEvent("panel-create", {
                element: element,
                panel: panel
            });
        },

        customButtons: function(buttons){
            return this._addCustomButtons(buttons);
        },

        collapse: function(){
            var element = this.element;
            if (Utils.isMetroObject(element, 'collapse') === false) {
                return ;
            }
            Metro.getPlugin(element, 'collapse').collapse();
        },

        open: function(){
            this.expand();
        },

        close: function(){
            this.collapse();
        },

        expand: function(){
            var element = this.element;
            if (Utils.isMetroObject(element, 'collapse') === false) {
                return ;
            }
            Metro.getPlugin(element, 'collapse').expand();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element, o = this.options;

            if (o.collapsible === true) {
                Metro.getPlugin(element, "collapse").destroy();
            }

            if (o.draggable === true) {
                Metro.getPlugin(element, "draggable").destroy();
            }

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var PopoverDefaultConfig = {
        popoverDeferred: 0,
        popoverText: "",
        popoverHide: 3000,
        popoverTimeout: 10,
        popoverOffset: 10,
        popoverTrigger: Metro.popoverEvents.HOVER,
        popoverPosition: Metro.position.TOP,
        hideOnLeave: false,
        closeButton: true,
        clsPopover: "",
        clsPopoverContent: "",
        onPopoverShow: Metro.noop,
        onPopoverHide: Metro.noop,
        onPopoverCreate: Metro.noop
    };

    Metro.popoverSetup = function (options) {
        PopoverDefaultConfig = $.extend({}, PopoverDefaultConfig, options);
    };

    if (typeof window["metroPopoverSetup"] !== undefined) {
        Metro.popoverSetup(window["metroPopoverSetup"]);
    }

    Metro.Component('popover', {
        init: function( options, elem ) {
            this._super(elem, options, PopoverDefaultConfig, {
                popover: null,
                popovered: false,
                size: {
                    width: 0,
                    height: 0
                },
                id: Utils.elementId("popover")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("popover-create", {
                element: this.element
            })
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            o.popoverOffset = (element.attr('data-offset') !== undefined && element.attr('data-offset') !== null) ?
              parseInt(element.attr('data-offset')) : o.popoverOffset;
            var event;

            switch (o.popoverTrigger) {
                case Metro.popoverEvents.CLICK: event = Metro.events.click; break;
                case Metro.popoverEvents.FOCUS: event = Metro.events.focus; break;
                default: event = Metro.events.enter;
            }

            element.on(event, function(){
                if (that.popover !== null || that.popovered === true) {
                    return ;
                }
                setTimeout(function(){
                    that.createPopover();

                    that._fireEvent("popover-show", {
                        popover: that.popover
                    });

                    if (o.popoverHide > 0) {
                        setTimeout(function(){
                            that.removePopover();
                        }, o.popoverHide);
                    }
                }, o.popoverTimeout);
            });

            if (o.hideOnLeave === true) {
                element.on(Metro.events.leave, function(){
                    that.removePopover();
                });
            }

            $(window).on(Metro.events.scroll, function(){
                if (that.popover !== null) that.setPosition();
            }, {ns: this.id});
        },

        setPosition: function(){
            var popover = this.popover, size = this.size, o = this.options, element = this.element;

            if (o.popoverPosition === Metro.position.BOTTOM) {
                popover.addClass('bottom');
                popover.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight() + o.popoverOffset,
                    left: element.offset().left + element.outerWidth()/2 - size.width/2  - $(window).scrollLeft()
                });
            } else if (o.popoverPosition === Metro.position.RIGHT) {
                popover.addClass('right');
                popover.css({
                    top: element.offset().top + element.outerHeight()/2 - size.height/2 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() - $(window).scrollLeft() + o.popoverOffset
                });
            } else if (o.popoverPosition === Metro.position.LEFT) {
                popover.addClass('left');
                popover.css({
                    top: element.offset().top + element.outerHeight()/2 - size.height/2 - $(window).scrollTop(),
                    left: element.offset().left - size.width - $(window).scrollLeft() - o.popoverOffset
                });
            } else {
                popover.addClass('top');
                popover.css({
                    top: element.offset().top - $(window).scrollTop() - size.height - o.popoverOffset,
                    left: element.offset().left + element.outerWidth()/2 - size.width/2  - $(window).scrollLeft()
                });
            }
        },

        createPopover: function(){
            var that = this, elem = this.elem, element = this.element, o = this.options;
            var popover;
            var neb_pos;
            var id = Utils.elementId("popover");
            var closeButton;
            var min_width = ($('[data-popover-width-fix="' + element.id() + '"]').length !== 0) ?
              $('[data-popover-width-fix="' + element.id() + '"]').width() : false;

            if (this.popovered) {
                return ;
            }

            popover = $("<div>").addClass("popover neb").addClass(o.clsPopover);
            popover.attr("id", id);

            if(min_width) {
              popover.css('min-width' , min_width);
            }
            
            $("<div>").addClass("popover-content").addClass(o.clsPopoverContent).html(o.popoverText).appendTo(popover);

            if (o.popoverHide === 0 && o.closeButton === true) {
                closeButton = $("<button>").addClass("button square small popover-close-button bg-white").html("&times;").appendTo(popover);
                closeButton.on(Metro.events.click, function(){
                    that.removePopover();
                });
            }

            switch (o.popoverPosition) {
                case Metro.position.TOP: neb_pos = "neb-s"; break;
                case Metro.position.BOTTOM: neb_pos = "neb-n"; break;
                case Metro.position.RIGHT: neb_pos = "neb-w"; break;
                case Metro.position.LEFT: neb_pos = "neb-e"; break;
            }

            popover.addClass(neb_pos);

            if (o.closeButton !== true) {
                popover.on(Metro.events.click, function(){
                    that.removePopover();
                });
            }

            this.popover = popover;
            this.size = Utils.hiddenElementSize(popover);

            if (elem.tagName === 'TD' || elem.tagName === 'TH') {
                var wrp = $("<div/>").css("display", "inline-block").html(element.html());
                element.html(wrp);
                element = wrp;
            }

            this.setPosition();

            popover.appendTo($('body'));

            this.popovered = true;

            this._fireEvent("popover-create", {
                popover: popover
            });
        },

        removePopover: function(){
            var that = this;
            var timeout = this.options.onPopoverHide === Metro.noop ? 0 : 300;
            var popover = this.popover;

            if (!this.popovered) {
                return ;
            }

            this._fireEvent("popover-hide", {
                popover: popover
            });

            setTimeout(function(){
                popover.hide(0, function(){
                    popover.remove();
                    that.popover = null;
                    that.popovered = false;
                });
            }, timeout);
        },

        show: function(){
            var that = this, o = this.options;

            if (this.popovered === true) {
                return ;
            }

            setTimeout(function(){
                that.createPopover();

                that._fireEvent("popover-show", {
                    popover: that.popover
                });

                if (o.popoverHide > 0) {
                    setTimeout(function(){
                        that.removePopover();
                    }, o.popoverHide);
                }
            }, o.popoverTimeout);
        },

        hide: function(){
            this.removePopover();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeText = function(){
                o.popoverText = element.attr("data-popover-text");
                if (that.popover) {
                    that.popover.find(".popover-content").html(o.popoverText);
                    that.setPosition();
                }
            };

            var changePosition = function(){
                o.popoverPosition = element.attr("data-popover-position");
                that.setPosition();
            };

            switch (attributeName) {
                case "data-popover-text": changeText(); break;
                case "data-popover-position": changePosition(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var event;

            switch (o.popoverTrigger) {
                case Metro.popoverEvents.CLICK: event = Metro.events.click; break;
                case Metro.popoverEvents.FOCUS: event = Metro.events.focus; break;
                default: event = Metro.events.enter;
            }

            element.off(event);

            if (o.hideOnLeave === true) {
                element.off(Metro.events.leave);
            }

            $(window).off(Metro.events.scroll,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ProgressDefaultConfig = {
        progressDeferred: 0,
        showValue: false,
        valuePosition: "free", // center, free
        showLabel: false,
        labelPosition: "before", // before, after
        labelTemplate: "",
        value: 0,
        buffer: 0,
        type: "bar",
        small: false,
        clsBack: "",
        clsBar: "",
        clsBuffer: "",
        clsValue: "",
        clsLabel: "",
        onValueChange: Metro.noop,
        onBufferChange: Metro.noop,
        onComplete: Metro.noop,
        onBuffered: Metro.noop,
        onProgressCreate: Metro.noop
    };

    Metro.progressSetup = function (options) {
        ProgressDefaultConfig = $.extend({}, ProgressDefaultConfig, options);
    };

    if (typeof window["metroProgressSetup"] !== undefined) {
        Metro.progressSetup(window["metroProgressSetup"]);
    }

    Metro.Component('progress', {
        init: function( options, elem ) {
            this._super(elem, options, ProgressDefaultConfig, {
                value: 0,
                buffer: 0
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var value;

            if (typeof o.type === "string") o.type = o.type.toLowerCase();

            element
                .html("")
                .addClass("progress");

            function _progress(){
                $("<div>").addClass("bar").appendTo(element);
            }

            function _buffer(){
                $("<div>").addClass("bar").appendTo(element);
                $("<div>").addClass("buffer").appendTo(element);
            }

            function _load(){
                element.addClass("with-load");
                $("<div>").addClass("bar").appendTo(element);
                $("<div>").addClass("buffer").appendTo(element);
                $("<div>").addClass("load").appendTo(element);
            }

            function _line(){
                element.addClass("line");
            }

            switch (o.type) {
                case "buffer": _buffer(); break;
                case "load": _load(); break;
                case "line": _line(); break;
                default: _progress();
            }

            if (o.type !== 'line') {
                value = $("<span>").addClass("value").addClass(o.clsValue).appendTo(element);
                if (o.valuePosition === "center") value.addClass("centered");
                if (o.showValue === false) value.hide();
            }

            if (o.small === true) element.addClass("small");

            element.addClass(o.clsBack);
            element.find(".bar").addClass(o.clsBar);
            element.find(".buffer").addClass(o.clsBuffer);

            if (o.showLabel === true) {
                var label = $("<span>").addClass("progress-label").addClass(o.clsLabel).html(o.labelTemplate === "" ? o.value+"%" : o.labelTemplate.replace("%VAL%", o.value));
                if (o.labelPosition === 'before') {
                    label.insertBefore(element);
                } else {
                    label.insertAfter(element);
                }
            }

            this.val(o.value);
            this.buff(o.buffer);

            this._fireEvent("progress-create", {
                element: element
            });
        },

        val: function(v){
            var that = this, element = this.element, o = this.options;
            var value = element.find(".value");

            if (v === undefined) {
                return that.value;
            }

            var bar  = element.find(".bar");

            if (bar.length === 0) {
                return false;
            }

            this.value = parseInt(v, 10);

            bar.css("width", this.value + "%");
            value.html(this.value+"%");

            var diff = element.width() - bar.width();
            var valuePosition = value.width() > diff ? {left: "auto", right: diff + 'px'} : {left: v + '%'};

            if (o.valuePosition === "free") value.css(valuePosition);

            if (o.showLabel === true) {
                var label = element[o.labelPosition === "before" ? "prev" : "next"](".progress-label");
                if (label.length) {
                    label.html(o.labelTemplate === "" ? o.value+"%" : o.labelTemplate.replace("%VAL%", o.value));
                }
            }

            this._fireEvent("value-change", {
                val: this.value
            });

            if (this.value === 100) {

                this._fireEvent("complete", {
                    val: this.value
                });

            }
        },

        buff: function(v){
            var that = this, element = this.element;

            if (v === undefined) {
                return that.buffer;
            }

            var bar  = element.find(".buffer");

            if (bar.length === 0) {
                return false;
            }

            this.buffer = parseInt(v, 10);

            bar.css("width", this.buffer + "%");

            this._fireEvent("buffer-change", {
                val: this.buffer
            });

            if (this.buffer === 100) {
                this._fireEvent("buffered", {
                    val: this.buffer
                });
            }
        },

        changeValue: function(){
            this.val(this.element.attr('data-value'));
        },

        changeBuffer: function(){
            this.buff(this.element.attr('data-buffer'));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-value': this.changeValue(); break;
                case 'data-buffer': this.changeBuffer(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RadioDefaultConfig = {
        radioDeferred: 0,
        transition: true,
        style: 1,
        caption: "",
        captionPosition: "right",
        clsRadio: "",
        clsCheck: "",
        clsCaption: "",
        onRadioCreate: Metro.noop
    };

    Metro.radioSetup = function (options) {
        RadioDefaultConfig = $.extend({}, RadioDefaultConfig, options);
    };

    if (typeof window["metroRadioSetup"] !== undefined) {
        Metro.radioSetup(window["metroRadioSetup"]);
    }

    Metro.Component('radio', {
        init: function( options, elem ) {
            this._super(elem, options, RadioDefaultConfig, {
                origin: {
                    className: ""
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("radio-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var radio = $("<label>").addClass("radio " + element[0].className).addClass(o.style === 2 ? "style2" : "");
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "radio");

            radio.insertBefore(element);
            element.appendTo(radio);
            check.appendTo(radio);
            caption.appendTo(radio);

            if (o.transition === true) {
                radio.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                radio.addClass("caption-left");
            }

            this.origin.className = element[0].className;
            element[0].className = '';

            radio.addClass(o.clsRadio);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var element = this.element, check = element.siblings(".check");

            element.on("focus", function(){
                check.addClass("focused");
            });

            element.on("blur", function(){
                check.removeClass("focused");
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var parent = element.parent();

            var changeStyle = function(){
                var new_style = parseInt(element.attr("data-style"));

                if (!Utils.isInt(new_style)) return;

                o.style = new_style;
                parent.removeClass("style1 style2").addClass("style"+new_style);
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-style': changeStyle(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ResizableDefaultConfig = {
        resizableDeferred: 0,
        canResize: true,
        resizeElement: ".resize-element",
        minWidth: 0,
        minHeight: 0,
        maxWidth: 0,
        maxHeight: 0,
        preserveRatio: false,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResize: Metro.noop,
        onResizableCreate: Metro.noop
    };

    Metro.resizableSetup = function (options) {
        ResizableDefaultConfig = $.extend({}, ResizableDefaultConfig, options);
    };

    if (typeof window["metroResizableSetup"] !== undefined) {
        Metro.resizableSetup(window["metroResizableSetup"]);
    }

    Metro.Component('resizable', {
        init: function( options, elem ) {
            this._super(elem, options, ResizableDefaultConfig, {
                resizer: null,
                id: Utils.elementId("resizable")
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("resizable-create");
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.data("canResize", true);
            element.addClass("resizable-element");

            if (Utils.isValue(o.resizeElement) && element.find(o.resizeElement).length > 0) {
                this.resizer = element.find(o.resizeElement);
            } else {
                this.resizer = $("<span>").addClass("resize-element").appendTo(element);
            }

            element.data("canResize", o.canResize);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            this.resizer.on(Metro.events.start, function(e){

                if (element.data('canResize') === false) {
                    return ;
                }

                var startXY = Utils.pageXY(e);
                var startWidth = parseInt(element.outerWidth());
                var startHeight = parseInt(element.outerHeight());
                var size = {width: startWidth, height: startHeight};

                element.addClass("stop-pointer");

                that._fireEvent("resize-start", {
                    size: size
                });

                $(document).on(Metro.events.move, function(e){
                    var moveXY = Utils.pageXY(e);
                    var size = {
                        width: startWidth + moveXY.x - startXY.x,
                        height: startHeight + moveXY.y - startXY.y
                    };

                    if (o.maxWidth > 0 && size.width > o.maxWidth) {return true;}
                    if (o.minWidth > 0 && size.width < o.minWidth) {return true;}

                    if (o.maxHeight > 0 && size.height > o.maxHeight) {return true;}
                    if (o.minHeight > 0 && size.height < o.minHeight) {return true;}

                    element.css(size);

                    that._fireEvent("resize", {
                        size: size
                    })

                }, {ns: that.id});

                $(document).on(Metro.events.stop, function(){
                    element.removeClass("stop-pointer");

                    $(document).off(Metro.events.move, {ns: that.id});
                    $(document).off(Metro.events.stop, {ns: that.id});

                    var size = {
                        width: parseInt(element.outerWidth()),
                        height: parseInt(element.outerHeight())
                    };

                    that._fireEvent("resize-stop", {
                        size: size
                    });

                }, {ns: that.id});

                e.preventDefault();
                e.stopPropagation();
            });

        },

        off: function(){
            this.element.data("canResize", false);
        },

        on: function(){
            this.element.data("canResize", true);
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;

            var canResize = function(){
                o.canResize = JSON.parse(element.attr('data-can-resize')) === true;
            };

            switch (attributeName) {
                case "data-can-resize": canResize(); break;
            }
        },

        destroy: function(){
            this.resizer.off(Metro.events.start);
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ResizerDefaultConfig = {
        resizerDeferred: 0,
        onMediaPoint: Metro.noop,
        onMediaPointEnter: Metro.noop,
        onMediaPointLeave: Metro.noop,
        onWindowResize: Metro.noop,
        onElementResize: Metro.noop,
        onResizerCreate: Metro.noop
    };

    Metro.resizerSetup = function (options) {
        ResizerDefaultConfig = $.extend({}, ResizerDefaultConfig, options);
    };

    if (typeof window["metroResizerSetup"] !== undefined) {
        Metro.resizerSetup(window["metroResizerSetup"]);
    }

    Metro.Component('resizer', {
        init: function( options, elem ) {
            this._super(elem, options, ResizerDefaultConfig, {
                size: {width: 0, height: 0},
                media: window.METRO_MEDIA,
                id: Utils.elementId("resizer")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this.size = {
                width: element.width(),
                height: element.height()
            };

            this._createStructure();
            this._createEvents();

            this._fireEvent("resizer-create", {
                element: element
            });
        },

        _createStructure: function(){
        },

        _createEvents: function(){
            var that = this, element = this.element;
            var win = $.window();

            win.on("resize", function(){
                var windowWidth = win.width(), windowHeight = win.height();
                var elementWidth = element.width(), elementHeight = element.height();
                var oldSize = that.size;
                var point;

                that._fireEvent("window-resize", {
                    width: windowWidth,
                    height: windowHeight,
                    media: window.METRO_MEDIA
                });

                if (that.size.width !== elementWidth || that.size.height !== elementHeight) {
                    that.size = {
                        width: elementWidth,
                        height: elementHeight
                    };

                    that._fireEvent("element-resize", {
                        width: elementWidth,
                        height: elementHeight,
                        oldSize: oldSize,
                        media: window.METRO_MEDIA
                    });

                }

                if (that.media.length !== window.METRO_MEDIA.length) {
                    if (that.media.length > window.METRO_MEDIA.length) {
                        point = that.media.filter(function(x){
                            return !window.METRO_MEDIA.contains(x);
                        });

                        that._fireEvent("media-point-leave", {
                            point: point,
                            media: window.METRO_MEDIA
                        });

                    } else {
                        point = window.METRO_MEDIA.filter(function(x){
                            return !that.media.contains(x);
                        });

                        that._fireEvent("media-point-enter", {
                            point: point,
                            media: window.METRO_MEDIA
                        });
                    }

                    that.media = window.METRO_MEDIA;

                    that._fireEvent("media-point", {
                        point: point,
                        media: window.METRO_MEDIA
                    });
                }
            }, {ns: this.id});
        },

        changeAttribute: function(){
        },

        destroy: function(){
            $(window).off("resize", {ns: this.id});
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RibbonMenuDefaultConfig = {
        ribbonmenuDeferred: 0,
        onStatic: Metro.noop,
        onBeforeTab: Metro.noop_true,
        onTab: Metro.noop,
        onRibbonMenuCreate: Metro.noop
    };

    Metro.ribbonMenuSetup = function (options) {
        RibbonMenuDefaultConfig = $.extend({}, RibbonMenuDefaultConfig, options);
    };

    if (typeof window["metroRibbonMenuSetup"] !== undefined) {
        Metro.ribbonMenuSetup(window["metroRibbonMenuSetup"]);
    }

    Metro.Component('ribbon-menu', {
        init: function( options, elem ) {
            this._super(elem, options, RibbonMenuDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("ribbon-menu-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element;

            element.addClass("ribbon-menu");

            var tabs = element.find(".tabs-holder li:not(.static)");
            var active_tab = element.find(".tabs-holder li.active");
            if (active_tab.length > 0) {
                this.open($(active_tab[0]));
            } else {
                if (tabs.length > 0) {
                    this.open($(tabs[0]));
                }
            }

            var fluentGroups = element.find(".ribbon-toggle-group");
            $.each(fluentGroups, function(){
                var g = $(this);
                g.buttongroup({
                    clsActive: "active"
                });

                var gw = 0;
                var btns = g.find(".ribbon-icon-button");
                $.each(btns, function(){
                    var b = $(this);
                    var w = b.outerWidth(true);
                    if (w > gw) gw = w;
                });

                g.css("width", gw * Math.ceil(btns.length / 3) + 4);
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".tabs-holder li a", function(e){
                var link = $(this);
                var tab = $(this).parent("li");

                if (tab.hasClass("static")) {
                    if (o.onStatic === Metro.noop && link.attr("href") !== undefined) {
                        document.location.href = link.attr("href");
                    } else {
                        that._fireEvent("static", {
                            tab: tab[0]
                        });
                    }
                } else {
                    if (Utils.exec(o.onBeforeTab, [tab[0]], element[0]) === true) {
                        that.open(tab[0]);
                    }
                }
                e.preventDefault();
            })
        },

        open: function(tab){
            var element = this.element;
            var $tab = $(tab);
            var tabs = element.find(".tabs-holder li");
            var sections = element.find(".content-holder .section");
            var target = $tab.children("a").attr("href");
            var target_section = target !== "#" ? element.find(target) : null;

            tabs.removeClass("active");
            $tab.addClass("active");

            sections.removeClass("active");
            if (target_section) target_section.addClass("active");

            this._fireEvent("tab", {
                tab: $tab[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".tabs-holder li a");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RippleDefaultConfig = {
        rippleDeferred: 0,
        rippleColor: "#fff",
        rippleAlpha: .4,
        rippleTarget: "default",
        onRippleCreate: Metro.noop
    };

    Metro.rippleSetup = function (options) {
        RippleDefaultConfig = $.extend({}, RippleDefaultConfig, options);
    };

    if (typeof window["metroRippleSetup"] !== undefined) {
        Metro.rippleSetup(window["metroRippleSetup"]);
    }

    var getRipple = function(target, color, alpha, event){
        var el = $(target);
        var rect = Utils.rect(el[0]);
        var x, y;

        if (el.length === 0) {
            return ;
        }

        if (!Utils.isValue(color)) {
            color = "#fff";
        }

        if (!Utils.isValue(alpha)) {
            alpha = .4;
        }

        if (el.css('position') === 'static') {
            el.css('position', 'relative');
        }

        el.css({
            overflow: 'hidden'
        });

        $(".ripple").remove();

        var size = Math.max(el.outerWidth(), el.outerHeight());

        // Add the element
        var ripple = $("<span class='ripple'></span>").css({
            width: size,
            height: size
        });

        el.prepend(ripple);

        if (event) {
            // Get touch point x, y
            x = event.pageX - el.offset().left - ripple.width()/2;
            y = event.pageY - el.offset().top - ripple.height()/2;
        } else {
            // Get the center of the element
            x = rect.width / 2 - ripple.width()/2;
            y = rect.height / 2 - ripple.height()/2;
        }

        ripple.css({
            background: Utils.hex2rgba(color, alpha),
            width: size,
            height: size,
            top: y + 'px',
            left: x + 'px'
        }).addClass("rippleEffect");

        setTimeout(function(){
            ripple.remove();
        }, 400);
    };

    Metro.Component('ripple', {
        init: function( options, elem ) {
            this._super(elem, options, RippleDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var target = o.rippleTarget === 'default' ? null : o.rippleTarget;

            element.on(Metro.events.click, target, function(e){
                getRipple(this, o.rippleColor, o.rippleAlpha, e);
            });

            this._fireEvent("riopple-create", {
                element: element
            });
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;

            function changeColor(){
                var color = element.attr("data-ripple-color");
                if (!Utils.isColor(color)) {
                    return;
                }
                o.rippleColor = color;
            }

            function changeAlpha(){
                var alpha = +element.attr("data-ripple-alpha");
                if (isNaN(alpha)) {
                    return;
                }
                o.rippleColor = alpha;
            }

            switch (attributeName) {
                case "data-ripple-color": changeColor(); break;
                case "data-ripple-alpha": changeAlpha(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var target = o.rippleTarget === 'default' ? null : o.rippleTarget;
            element.off(Metro.events.click, target);
        }
    });

    Metro.ripple = getRipple;
}(Metro, m4q));

/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.0
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 02.08.2020
 */

(function (global, factory) {
  'use strict';

  var Metro = global.Metro;
  var window = global.window;
  var Utils = Metro.utils;
  var scrollbarDefaultConfig = {
    settings: {
      
    }
  };

  factory(window, window.document, undefined);

  Metro.scrollbarSetup = function (options) {
    scrollbarDefaultConfig = $.extend({}, scrollbarDefaultConfig, options);
  };

  if (typeof window["metroScrollbarSetup"] !== undefined) {
      Metro.scrollbarSetup(window["metroScrollbarSetup"]);
  }

  Metro.Component('scrollbar', {
      init: function (options, elem) {
          this._super(elem, options, scrollbarDefaultConfig, {
              id: Utils.elementId('scrollbar')
          });

          return this;
      },

      _create: function () {
          var element = this.element;

          this._createStructure();
          this._createEvents();

          this._fireEvent("scrollbar-create", {
              element: element
          })
      },

      _createStructure: function () {
        var element = this.element , o = this.options;
        var settings = element.attr('data-scrollbar-settings');
        settings = (settings === undefined || settings === null) ? {} : JSON.parse(settings);
        settings = Object.assign(settings , o.settings);

        OverlayScrollbars($('[data-role="scrollbar"]') , settings);
      },

      _createEvents: function () {
          
      }
  });
}({'Metro':Metro , 'm4q':m4q , 'window':window} ,
  function (window, document, undefined) {
      'use strict';
      var PLUGINNAME = 'OverlayScrollbars';
      var TYPES = {
          o: 'object',
          f: 'function',
          a: 'array',
          s: 'string',
          b: 'boolean',
          n: 'number',
          u: 'undefined',
          z: 'null'
          //d : 'date',
          //e : 'error',
          //r : 'regexp',
          //y : 'symbol'
      };
      var LEXICON = {
          c: 'class',
          s: 'style',
          i: 'id',
          l: 'length',
          p: 'prototype',
          ti: 'tabindex',
          oH: 'offsetHeight',
          cH: 'clientHeight',
          sH: 'scrollHeight',
          oW: 'offsetWidth',
          cW: 'clientWidth',
          sW: 'scrollWidth',
          hOP: 'hasOwnProperty',
          bCR: 'getBoundingClientRect'
      };
      var VENDORS = (function () {
          //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
          var jsCache = {};
          var cssCache = {};
          var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];
          var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];
          function firstLetterToUpper(str) {
              return str.charAt(0).toUpperCase() + str.slice(1);
          }

          return {
              _cssPrefixes: cssPrefixes,
              _jsPrefixes: jsPrefixes,
              _cssProperty: function (name) {
                  var result = cssCache[name];

                  if (cssCache[LEXICON.hOP](name))
                      return result;

                  var uppercasedName = firstLetterToUpper(name);
                  var elmStyle = document.createElement('div')[LEXICON.s];
                  var resultPossibilities;
                  var i = 0;
                  var v;
                  var currVendorWithoutDashes;

                  for (; i < cssPrefixes.length; i++) {
                      currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');
                      resultPossibilities = [
                          name, //transition
                          cssPrefixes[i] + name, //-webkit-transition
                          currVendorWithoutDashes + uppercasedName, //webkitTransition
                          firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition
                      ];
                      for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                          if (elmStyle[resultPossibilities[v]] !== undefined) {
                              result = resultPossibilities[v];
                              break;
                          }
                      }
                  }

                  cssCache[name] = result;
                  return result;
              },
              _cssPropertyValue: function (property, values, suffix) {
                  var name = property + ' ' + values;
                  var result = cssCache[name];

                  if (cssCache[LEXICON.hOP](name))
                      return result;

                  var dummyStyle = document.createElement('div')[LEXICON.s];
                  var possbleValues = values.split(' ');
                  var preparedSuffix = suffix || '';
                  var i = 0;
                  var v = -1;
                  var prop;

                  for (; i < possbleValues[LEXICON.l]; i++) {
                      for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
                          prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
                          dummyStyle.cssText = property + ':' + prop + preparedSuffix;
                          if (dummyStyle[LEXICON.l]) {
                              result = prop;
                              break;
                          }
                      }
                  }

                  cssCache[name] = result;
                  return result;
              },
              _jsAPI: function (name, isInterface, fallback) {
                  var i = 0;
                  var result = jsCache[name];

                  if (!jsCache[LEXICON.hOP](name)) {
                      result = window[name];
                      for (; i < jsPrefixes[LEXICON.l]; i++)
                          result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                      jsCache[name] = result;
                  }
                  return result || fallback;
              }
          }
      })();
      var COMPATIBILITY = (function () {
          function windowSize(x) {
              return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
          }
          function bind(func, thisObj) {
              if (typeof func != TYPES.f) {
                  throw "Can't bind function!";
                  // closest thing possible to the ECMAScript 5
                  // internal IsCallable function
                  //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
              }
              var proto = LEXICON.p;
              var aArgs = Array[proto].slice.call(arguments, 2);
              var fNOP = function () { };
              var fBound = function () { return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments))); };

              if (func[proto])
                  fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property
              fBound[proto] = new fNOP();

              return fBound;
          }

          return {
              /**
               * Gets the current window width.
               * @returns {Number|number} The current window width in pixel.
               */
              wW: bind(windowSize, 0, true),

              /**
               * Gets the current window height.
               * @returns {Number|number} The current window height in pixel.
               */
              wH: bind(windowSize, 0),

              /**
               * Gets the MutationObserver Object or undefined if not supported.
               * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
               */
              mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),

              /**
               * Gets the ResizeObserver Object or undefined if not supported.
               * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
               */
              rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),

              /**
               * Gets the RequestAnimationFrame method or it's corresponding polyfill.
               * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
               */
              rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) { return window.setTimeout(func, 1000 / 60); }),

              /**
               * Gets the CancelAnimationFrame method or it's corresponding polyfill.
               * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
               */
              cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),

              /**
               * Gets the current time.
               * @returns {number} The current time.
               */
              now: function () {
                  return Date.now && Date.now() || new Date().getTime();
              },

              /**
               * Stops the propagation of the given event.
               * @param event The event of which the propagation shall be stoped.
               */
              stpP: function (event) {
                  if (event.stopPropagation)
                      event.stopPropagation();
                  else
                      event.cancelBubble = true;
              },

              /**
               * Prevents the default action of the given event.
               * @param event The event of which the default action shall be prevented.
               */
              prvD: function (event) {
                  if (event.preventDefault && event.cancelable)
                      event.preventDefault();
                  else
                      event.returnValue = false;
              },

              /**
               * Gets the pageX and pageY values of the given mouse event.
               * @param event The mouse event of which the pageX and pageX shall be got.
               * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
               */
              page: function (event) {
                  event = event.originalEvent || event;

                  var strPage = 'page';
                  var strClient = 'client';
                  var strX = 'X';
                  var strY = 'Y';
                  var target = event.target || event.srcElement || document;
                  var eventDoc = target.ownerDocument || document;
                  var doc = eventDoc.documentElement;
                  var body = eventDoc.body;

                  //if touch event return return pageX/Y of it
                  if (event.touches !== undefined) {
                      var touch = event.touches[0];
                      return {
                          x: touch[strPage + strX],
                          y: touch[strPage + strY]
                      }
                  }

                  // Calculate pageX/Y if not native supported
                  if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {

                      return {
                          x: event[strClient + strX] +
                              (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                              (doc && doc.clientLeft || body && body.clientLeft || 0),
                          y: event[strClient + strY] +
                              (doc && doc.scrollTop || body && body.scrollTop || 0) -
                              (doc && doc.clientTop || body && body.clientTop || 0)
                      }
                  }
                  return {
                      x: event[strPage + strX],
                      y: event[strPage + strY]
                  };
              },

              /**
               * Gets the clicked mouse button of the given mouse event.
               * @param event The mouse event of which the clicked button shal be got.
               * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
               */
              mBtn: function (event) {
                  var button = event.button;
                  if (!event.which && button !== undefined)
                      return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                  else
                      return event.which;
              },

              /**
               * Checks whether a item is in the given array and returns its index.
               * @param item The item of which the position in the array shall be determined.
               * @param arr The array.
               * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
               */
              inA: function (item, arr) {
                  for (var i = 0; i < arr[LEXICON.l]; i++)
                      //Sometiems in IE a "SCRIPT70" Permission denied error occurs if HTML elements in a iFrame are compared
                      try {
                          if (arr[i] === item)
                              return i;
                      }
                      catch (e) { }
                  return -1;
              },

              /**
               * Returns true if the given value is a array.
               * @param arr The potential array.
               * @returns {boolean} True if the given value is a array, false otherwise.
               */
              isA: function (arr) {
                  var def = Array.isArray;
                  return def ? def(arr) : this.type(arr) == TYPES.a;
              },

              /**
               * Determine the internal JavaScript [[Class]] of the given object.
               * @param obj The object of which the type shall be determined.
               * @returns {string} The type of the given object.
               */
              type: function (obj) {
                  if (obj === undefined)
                      return obj + '';
                  if (obj === null)
                      return obj + '';
                  return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
              },


              bind: bind

              /**
               * Gets the vendor-prefixed CSS property by the given name.
               * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
               * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
               * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
               * @param propName The unprefixed CSS property name.
               * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.

              cssProp: function(propName) {
                  return VENDORS._cssProperty(propName);
              }
              */
          }
      })();


      var MATH = Math;
      var JQUERY = window.jQuery;
      var EASING = (function () {
          var _easingsMath = {
              p: MATH.PI,
              c: MATH.cos,
              s: MATH.sin,
              w: MATH.pow,
              t: MATH.sqrt,
              n: MATH.asin,
              a: MATH.abs,
              o: 1.70158
          };

          /*
           x : current percent (0 - 1),
           t : current time (duration * percent),
           b : start value (from),
           c : end value (to),
           d : duration

           easingName : function(x, t, b, c, d) { return easedValue; }
           */

          return {
              swing: function (x, t, b, c, d) {
                  return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
              },
              linear: function (x, t, b, c, d) {
                  return x;
              },
              easeInQuad: function (x, t, b, c, d) {
                  return c * (t /= d) * t + b;
              },
              easeOutQuad: function (x, t, b, c, d) {
                  return -c * (t /= d) * (t - 2) + b;
              },
              easeInOutQuad: function (x, t, b, c, d) {
                  return ((t /= d / 2) < 1) ? c / 2 * t * t + b : -c / 2 * ((--t) * (t - 2) - 1) + b;
              },
              easeInCubic: function (x, t, b, c, d) {
                  return c * (t /= d) * t * t + b;
              },
              easeOutCubic: function (x, t, b, c, d) {
                  return c * ((t = t / d - 1) * t * t + 1) + b;
              },
              easeInOutCubic: function (x, t, b, c, d) {
                  return ((t /= d / 2) < 1) ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
              },
              easeInQuart: function (x, t, b, c, d) {
                  return c * (t /= d) * t * t * t + b;
              },
              easeOutQuart: function (x, t, b, c, d) {
                  return -c * ((t = t / d - 1) * t * t * t - 1) + b;
              },
              easeInOutQuart: function (x, t, b, c, d) {
                  return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
              },
              easeInQuint: function (x, t, b, c, d) {
                  return c * (t /= d) * t * t * t * t + b;
              },
              easeOutQuint: function (x, t, b, c, d) {
                  return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
              },
              easeInOutQuint: function (x, t, b, c, d) {
                  return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
              },
              easeInSine: function (x, t, b, c, d) {
                  return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
              },
              easeOutSine: function (x, t, b, c, d) {
                  return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
              },
              easeInOutSine: function (x, t, b, c, d) {
                  return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
              },
              easeInExpo: function (x, t, b, c, d) {
                  return (t == 0) ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
              },
              easeOutExpo: function (x, t, b, c, d) {
                  return (t == d) ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
              },
              easeInOutExpo: function (x, t, b, c, d) {
                  if (t == 0) return b;
                  if (t == d) return b + c;
                  if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;
                  return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
              },
              easeInCirc: function (x, t, b, c, d) {
                  return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
              },
              easeOutCirc: function (x, t, b, c, d) {
                  return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
              },
              easeInOutCirc: function (x, t, b, c, d) {
                  return ((t /= d / 2) < 1) ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
              },
              easeInElastic: function (x, t, b, c, d) {
                  var s = _easingsMath.o; var p = 0; var a = c;
                  if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3;
                  if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                  else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                  return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
              },
              easeOutElastic: function (x, t, b, c, d) {
                  var s = _easingsMath.o; var p = 0; var a = c;
                  if (t == 0) return b;
                  if ((t /= d) == 1) return b + c;
                  if (!p) p = d * .3;
                  if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                  else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                  return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;
              },
              easeInOutElastic: function (x, t, b, c, d) {
                  var s = _easingsMath.o; var p = 0; var a = c;
                  if (t == 0) return b;
                  if ((t /= d / 2) == 2) return b + c;
                  if (!p) p = d * (.3 * 1.5);
                  if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                  else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                  if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
                  return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;
              },
              easeInBack: function (x, t, b, c, d, s) {
                  s = s || _easingsMath.o;
                  return c * (t /= d) * t * ((s + 1) * t - s) + b;
              },
              easeOutBack: function (x, t, b, c, d, s) {
                  s = s || _easingsMath.o;
                  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
              },
              easeInOutBack: function (x, t, b, c, d, s) {
                  s = s || _easingsMath.o;
                  return ((t /= d / 2) < 1) ? c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
              },
              easeInBounce: function (x, t, b, c, d) {
                  return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
              },
              easeOutBounce: function (x, t, b, c, d) {
                  var o = 7.5625;
                  if ((t /= d) < (1 / 2.75)) {
                      return c * (o * t * t) + b;
                  } else if (t < (2 / 2.75)) {
                      return c * (o * (t -= (1.5 / 2.75)) * t + .75) + b;
                  } else if (t < (2.5 / 2.75)) {
                      return c * (o * (t -= (2.25 / 2.75)) * t + .9375) + b;
                  } else {
                      return c * (o * (t -= (2.625 / 2.75)) * t + .984375) + b;
                  }
              },
              easeInOutBounce: function (x, t, b, c, d) {
                  return (t < d / 2) ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;
              }
          };
          /*
           *
           * TERMS OF USE - EASING EQUATIONS
           * 
           * Open source under the BSD License. 
           * 
           * Copyright Â© 2001 Robert Penner
           * All rights reserved.
           * 
           * Redistribution and use in source and binary forms, with or without modification, 
           * are permitted provided that the following conditions are met:
           * 
           * Redistributions of source code must retain the above copyright notice, this list of 
           * conditions and the following disclaimer.
           * Redistributions in binary form must reproduce the above copyright notice, this list 
           * of conditions and the following disclaimer in the documentation and/or other materials 
           * provided with the distribution.
           * 
           * Neither the name of the author nor the names of contributors may be used to endorse 
           * or promote products derived from this software without specific prior written permission.
           * 
           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
           * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
           *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
           *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
           *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
           * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
           *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
           * OF THE POSSIBILITY OF SUCH DAMAGE. 
           *
           */
      })();
      var FRAMEWORK = (function () {
          var _rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
          var _strSpace = ' ';
          var _strEmpty = '';
          var _strScrollLeft = 'scrollLeft';
          var _strScrollTop = 'scrollTop';
          var _animations = [];
          var _type = COMPATIBILITY.type;
          var _cssNumber = {
              animationIterationCount: true,
              columnCount: true,
              fillOpacity: true,
              flexGrow: true,
              flexShrink: true,
              fontWeight: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              widows: true,
              zIndex: true,
              zoom: true
          };

          function extend() {
              var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},
                  i = 1,
                  length = arguments[LEXICON.l],
                  deep = false;

              // Handle a deep copy situation
              if (_type(target) == TYPES.b) {
                  deep = target;
                  target = arguments[1] || {};
                  // skip the boolean and the target
                  i = 2;
              }

              // Handle case when target is a string or something (possible in deep copy)
              if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {
                  target = {};
              }

              // extend jQuery itself if only one argument is passed
              if (length === i) {
                  target = FakejQuery;
                  --i;
              }

              for (; i < length; i++) {
                  // Only deal with non-null/undefined values
                  if ((options = arguments[i]) != null) {
                      // Extend the base object
                      for (name in options) {
                          src = target[name];
                          copy = options[name];

                          // Prevent never-ending loop
                          if (target === copy) {
                              continue;
                          }

                          // Recurse if we're merging plain objects or arrays
                          if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
                              if (copyIsArray) {
                                  copyIsArray = false;
                                  clone = src && COMPATIBILITY.isA(src) ? src : [];

                              } else {
                                  clone = src && isPlainObject(src) ? src : {};
                              }

                              // Never move original objects, clone them
                              target[name] = extend(deep, clone, copy);

                              // Don't bring in undefined values
                          } else if (copy !== undefined) {
                              target[name] = copy;
                          }
                      }
                  }
              }

              // Return the modified object
              return target;
          };

          function inArray(item, arr, fromIndex) {
              for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)
                  if (arr[i] === item)
                      return i;
              return -1;
          }

          function isFunction(obj) {
              return _type(obj) == TYPES.f;
          };

          function isEmptyObject(obj) {
              for (var name in obj)
                  return false;
              return true;
          };

          function isPlainObject(obj) {
              if (!obj || _type(obj) != TYPES.o)
                  return false;

              var key;
              var proto = LEXICON.p;
              var hasOwnProperty = Object[proto].hasOwnProperty;
              var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');
              var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');

              if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                  return false;
              }


              for (key in obj) { /**/ }

              return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
          };

          function each(obj, callback) {
              var i = 0;

              if (isArrayLike(obj)) {
                  for (; i < obj[LEXICON.l]; i++) {
                      if (callback.call(obj[i], i, obj[i]) === false)
                          break;
                  }
              }
              else {
                  for (i in obj) {
                      if (callback.call(obj[i], i, obj[i]) === false)
                          break;
                  }
              }

              return obj;
          };

          function isArrayLike(obj) {
              var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];
              var t = _type(obj);
              return isFunction(t) ? false : (t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && (length - 1) in obj);
          }

          function stripAndCollapse(value) {
              var tokens = value.match(_rnothtmlwhite) || [];
              return tokens.join(_strSpace);
          }

          function matches(elem, selector) {
              var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];
              var i = nodeList[LEXICON.l];

              while (i--)
                  if (nodeList[i] == elem)
                      return true;

              return false;
          }

          function insertAdjacentElement(el, strategy, child) {
              if (COMPATIBILITY.isA(child)) {
                  for (var i = 0; i < child[LEXICON.l]; i++)
                      insertAdjacentElement(el, strategy, child[i]);
              }
              else if (_type(child) == TYPES.s)
                  el.insertAdjacentHTML(strategy, child);
              else
                  el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
          }

          function setCSSVal(el, prop, val) {
              try {
                  if (el[LEXICON.s][prop] !== undefined)
                      el[LEXICON.s][prop] = parseCSSVal(prop, val);
              } catch (e) { }
          }

          function parseCSSVal(prop, val) {
              if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)
                  val += 'px';
              return val;
          }

          function startNextAnimationInQ(animObj, removeFromQ) {
              var index;
              var nextAnim;
              if (removeFromQ !== false)
                  animObj.q.splice(0, 1);
              if (animObj.q[LEXICON.l] > 0) {
                  nextAnim = animObj.q[0];
                  animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
              }
              else {
                  index = inArray(animObj, _animations);
                  if (index > -1)
                      _animations.splice(index, 1);
              }
          }

          function setAnimationValue(el, prop, value) {
              if (prop === _strScrollLeft || prop === _strScrollTop)
                  el[prop] = value;
              else
                  setCSSVal(el, prop, value);
          }

          function animate(el, props, options, easing, complete, guaranteedNext) {
              var hasOptions = isPlainObject(options);
              var from = {};
              var to = {};
              var i = 0;
              var key;
              var animObj;
              var start;
              var progress;
              var step;
              var specialEasing;
              var duration;
              if (hasOptions) {
                  easing = options.easing;
                  start = options.start;
                  progress = options.progress;
                  step = options.step;
                  specialEasing = options.specialEasing;
                  complete = options.complete;
                  duration = options.duration;
              }
              else
                  duration = options;
              specialEasing = specialEasing || {};
              duration = duration || 400;
              easing = easing || 'swing';
              guaranteedNext = guaranteedNext || false;

              for (; i < _animations[LEXICON.l]; i++) {
                  if (_animations[i].el === el) {
                      animObj = _animations[i];
                      break;
                  }
              }

              if (!animObj) {
                  animObj = {
                      el: el,
                      q: []
                  };
                  _animations.push(animObj);
              }

              for (key in props) {
                  if (key === _strScrollLeft || key === _strScrollTop)
                      from[key] = el[key];
                  else
                      from[key] = FakejQuery(el).css(key);
              }

              for (key in from) {
                  if (from[key] !== props[key] && props[key] !== undefined)
                      to[key] = props[key];
              }

              if (!isEmptyObject(to)) {
                  var timeNow;
                  var end;
                  var percent;
                  var fromVal;
                  var toVal;
                  var easedVal;
                  var timeStart;
                  var frame;
                  var elapsed;
                  var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
                  var qObj = {
                      props: to,
                      duration: hasOptions ? options : duration,
                      easing: easing,
                      complete: complete
                  };
                  if (qPos === -1) {
                      qPos = animObj.q[LEXICON.l];
                      animObj.q.push(qObj);
                  }

                  if (qPos === 0) {
                      if (duration > 0) {
                          timeStart = COMPATIBILITY.now();
                          frame = function () {
                              timeNow = COMPATIBILITY.now();
                              elapsed = (timeNow - timeStart);
                              end = qObj.stop || elapsed >= duration;
                              percent = 1 - ((MATH.max(0, timeStart + duration - timeNow) / duration) || 0);

                              for (key in to) {
                                  fromVal = parseFloat(from[key]);
                                  toVal = parseFloat(to[key]);
                                  easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;
                                  setAnimationValue(el, key, easedVal);
                                  if (isFunction(step)) {
                                      step(easedVal, {
                                          elem: el,
                                          prop: key,
                                          start: fromVal,
                                          now: easedVal,
                                          end: toVal,
                                          pos: percent,
                                          options: {
                                              easing: easing,
                                              speacialEasing: specialEasing,
                                              duration: duration,
                                              complete: complete,
                                              step: step
                                          },
                                          startTime: timeStart
                                      });
                                  }
                              }

                              if (isFunction(progress))
                                  progress({}, percent, MATH.max(0, duration - elapsed));

                              if (end) {
                                  startNextAnimationInQ(animObj);
                                  if (isFunction(complete))
                                      complete();
                              }
                              else
                                  qObj.frame = COMPATIBILITY.rAF()(frame);
                          };
                          qObj.frame = COMPATIBILITY.rAF()(frame);
                      }
                      else {
                          for (key in to)
                              setAnimationValue(el, key, to[key]);
                          startNextAnimationInQ(animObj);
                      }
                  }
              }
              else if (guaranteedNext)
                  startNextAnimationInQ(animObj);
          }

          function stop(el, clearQ, jumpToEnd) {
              var animObj;
              var qObj;
              var key;
              var i = 0;
              for (; i < _animations[LEXICON.l]; i++) {
                  animObj = _animations[i];
                  if (animObj.el === el) {
                      if (animObj.q[LEXICON.l] > 0) {
                          qObj = animObj.q[0];
                          qObj.stop = true;
                          COMPATIBILITY.cAF()(qObj.frame);
                          animObj.q.splice(0, 1);

                          if (jumpToEnd)
                              for (key in qObj.props)
                                  setAnimationValue(el, key, qObj.props[key]);

                          if (clearQ)
                              animObj.q = [];
                          else
                              startNextAnimationInQ(animObj, false);
                      }
                      break;
                  }
              }
          }

          function elementIsVisible(el) {
              return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
          }

          function FakejQuery(selector) {
              if (arguments[LEXICON.l] === 0)
                  return this;

              var base = new FakejQuery();
              var elements = selector;
              var i = 0;
              var elms;
              var el;

              if (_type(selector) == TYPES.s) {
                  elements = [];
                  if (selector.charAt(0) === '<') {
                      el = document.createElement('div');
                      el.innerHTML = selector;
                      elms = el.children;
                  }
                  else {
                      elms = document.querySelectorAll(selector);
                  }

                  for (; i < elms[LEXICON.l]; i++)
                      elements.push(elms[i]);
              }

              if (elements) {
                  if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self))
                      elements = [elements];

                  for (i = 0; i < elements[LEXICON.l]; i++)
                      base[i] = elements[i];

                  base[LEXICON.l] = elements[LEXICON.l];
              }

              return base;
          };

          FakejQuery[LEXICON.p] = {

              //EVENTS:

              on: function (eventName, handler) {
                  eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                  var eventNameLength = eventName[LEXICON.l];
                  var i = 0;
                  var el;
                  return this.each(function () {
                      el = this;
                      try {
                          if (el.addEventListener) {
                              for (; i < eventNameLength; i++)
                                  el.addEventListener(eventName[i], handler);
                          }
                          else if (el.detachEvent) {
                              for (; i < eventNameLength; i++)
                                  el.attachEvent('on' + eventName[i], handler);
                          }
                      } catch (e) { }
                  });
              },

              off: function (eventName, handler) {
                  eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                  var eventNameLength = eventName[LEXICON.l];
                  var i = 0;
                  var el;
                  return this.each(function () {
                      el = this;
                      try {
                          if (el.removeEventListener) {
                              for (; i < eventNameLength; i++)
                                  el.removeEventListener(eventName[i], handler);
                          }
                          else if (el.detachEvent) {
                              for (; i < eventNameLength; i++)
                                  el.detachEvent('on' + eventName[i], handler);
                          }
                      } catch (e) { }
                  });
              },

              one: function (eventName, handler) {
                  eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
                  return this.each(function () {
                      var el = FakejQuery(this);
                      FakejQuery.each(eventName, function (i, oneEventName) {
                          var oneHandler = function (e) {
                              handler.call(this, e);
                              el.off(oneEventName, oneHandler);
                          };
                          el.on(oneEventName, oneHandler);
                      });
                  });
              },

              trigger: function (eventName) {
                  var el;
                  var event;
                  return this.each(function () {
                      el = this;
                      if (document.createEvent) {
                          event = document.createEvent('HTMLEvents');
                          event.initEvent(eventName, true, false);
                          el.dispatchEvent(event);
                      }
                      else {
                          el.fireEvent('on' + eventName);
                      }
                  });
              },

              //DOM NODE INSERTING / REMOVING:

              append: function (child) {
                  return this.each(function () { insertAdjacentElement(this, 'beforeend', child); });
              },

              prepend: function (child) {
                  return this.each(function () { insertAdjacentElement(this, 'afterbegin', child); });
              },

              before: function (child) {
                  return this.each(function () { insertAdjacentElement(this, 'beforebegin', child); });
              },

              after: function (child) {
                  return this.each(function () { insertAdjacentElement(this, 'afterend', child); });
              },

              remove: function () {
                  return this.each(function () {
                      var el = this;
                      var parentNode = el.parentNode;
                      if (parentNode != null)
                          parentNode.removeChild(el);
                  });
              },

              unwrap: function () {
                  var parents = [];
                  var i;
                  var el;
                  var parent;

                  this.each(function () {
                      parent = this.parentNode;
                      if (inArray(parent, parents) === - 1)
                          parents.push(parent);
                  });

                  for (i = 0; i < parents[LEXICON.l]; i++) {
                      el = parents[i];
                      parent = el.parentNode;
                      while (el.firstChild)
                          parent.insertBefore(el.firstChild, el);
                      parent.removeChild(el);
                  }

                  return this;
              },

              wrapAll: function (wrapperHTML) {
                  var i;
                  var nodes = this;
                  var wrapper = FakejQuery(wrapperHTML)[0];
                  var deepest = wrapper;
                  var parent = nodes[0].parentNode;
                  var previousSibling = nodes[0].previousSibling;
                  while (deepest.childNodes[LEXICON.l] > 0)
                      deepest = deepest.childNodes[0];

                  for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)
                      deepest.appendChild(nodes[i]);

                  var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
                  parent.insertBefore(wrapper, nextSibling);

                  return this;
              },

              wrapInner: function (wrapperHTML) {
                  return this.each(function () {
                      var el = FakejQuery(this);
                      var contents = el.contents();

                      if (contents[LEXICON.l])
                          contents.wrapAll(wrapperHTML);
                      else
                          el.append(wrapperHTML);
                  });
              },

              wrap: function (wrapperHTML) {
                  return this.each(function () { FakejQuery(this).wrapAll(wrapperHTML); });
              },


              //DOM NODE MANIPULATION / INFORMATION:

              css: function (styles, val) {
                  var el;
                  var key;
                  var cptStyle;
                  var getCptStyle = window.getComputedStyle;
                  if (_type(styles) == TYPES.s) {
                      if (val === undefined) {
                          el = this[0];
                          cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];

                          //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)
                          return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;
                      }
                      else {
                          return this.each(function () {
                              setCSSVal(this, styles, val);
                          });
                      }
                  }
                  else {
                      return this.each(function () {
                          for (key in styles)
                              setCSSVal(this, key, styles[key]);
                      });
                  }
              },

              hasClass: function (className) {
                  var elem, i = 0;
                  var classNamePrepared = _strSpace + className + _strSpace;
                  var classList;

                  while ((elem = this[i++])) {
                      classList = elem.classList;
                      if (classList && classList.contains(className))
                          return true;
                      else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
                          return true;
                  }

                  return false;
              },

              addClass: function (className) {
                  var classes;
                  var elem;
                  var cur;
                  var curValue;
                  var clazz;
                  var finalValue;
                  var supportClassList;
                  var elmClassList;
                  var i = 0;
                  var v = 0;

                  if (className) {
                      classes = className.match(_rnothtmlwhite) || [];

                      while ((elem = this[i++])) {
                          elmClassList = elem.classList;
                          if (supportClassList === undefined)
                              supportClassList = elmClassList !== undefined;

                          if (supportClassList) {
                              while ((clazz = classes[v++]))
                                  elmClassList.add(clazz);
                          }
                          else {
                              curValue = elem.className + _strEmpty;
                              cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                              if (cur) {
                                  while ((clazz = classes[v++]))
                                      if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)
                                          cur += clazz + _strSpace;

                                  finalValue = stripAndCollapse(cur);
                                  if (curValue !== finalValue)
                                      elem.className = finalValue;
                              }
                          }
                      }
                  }

                  return this;
              },

              removeClass: function (className) {
                  var classes;
                  var elem;
                  var cur;
                  var curValue;
                  var clazz;
                  var finalValue;
                  var supportClassList;
                  var elmClassList;
                  var i = 0;
                  var v = 0;

                  if (className) {
                      classes = className.match(_rnothtmlwhite) || [];

                      while ((elem = this[i++])) {
                          elmClassList = elem.classList;
                          if (supportClassList === undefined)
                              supportClassList = elmClassList !== undefined;

                          if (supportClassList) {
                              while ((clazz = classes[v++]))
                                  elmClassList.remove(clazz);
                          }
                          else {
                              curValue = elem.className + _strEmpty;
                              cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                              if (cur) {
                                  while ((clazz = classes[v++]))
                                      while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)
                                          cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);

                                  finalValue = stripAndCollapse(cur);
                                  if (curValue !== finalValue)
                                      elem.className = finalValue;
                              }
                          }
                      }
                  }

                  return this;
              },

              hide: function () {
                  return this.each(function () { this[LEXICON.s].display = 'none'; });
              },

              show: function () {
                  return this.each(function () { this[LEXICON.s].display = 'block'; });
              },

              attr: function (attrName, value) {
                  var i = 0;
                  var el;
                  while (el = this[i++]) {
                      if (value === undefined)
                          return el.getAttribute(attrName);
                      el.setAttribute(attrName, value);
                  }
                  return this;
              },

              removeAttr: function (attrName) {
                  return this.each(function () { this.removeAttribute(attrName); });
              },

              offset: function () {
                  var el = this[0];
                  var rect = el[LEXICON.bCR]();
                  var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];
                  var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];
                  return {
                      top: rect.top + scrollTop,
                      left: rect.left + scrollLeft
                  };
              },

              position: function () {
                  var el = this[0];
                  return {
                      top: el.offsetTop,
                      left: el.offsetLeft
                  };
              },

              scrollLeft: function (value) {
                  var i = 0;
                  var el;
                  while (el = this[i++]) {
                      if (value === undefined)
                          return el[_strScrollLeft];
                      el[_strScrollLeft] = value;
                  }
                  return this;
              },

              scrollTop: function (value) {
                  var i = 0;
                  var el;
                  while (el = this[i++]) {
                      if (value === undefined)
                          return el[_strScrollTop];
                      el[_strScrollTop] = value;
                  }
                  return this;
              },

              val: function (value) {
                  var el = this[0];
                  if (!value)
                      return el.value;
                  el.value = value;
                  return this;
              },


              //DOM TRAVERSAL / FILTERING:

              first: function () {
                  return this.eq(0);
              },

              last: function () {
                  return this.eq(-1);
              },

              eq: function (index) {
                  return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);
              },

              find: function (selector) {
                  var children = [];
                  var i;
                  this.each(function () {
                      var el = this;
                      var ch = el.querySelectorAll(selector);
                      for (i = 0; i < ch[LEXICON.l]; i++)
                          children.push(ch[i]);
                  });
                  return FakejQuery(children);
              },

              children: function (selector) {
                  var children = [];
                  var el;
                  var ch;
                  var i;

                  this.each(function () {
                      ch = this.children;
                      for (i = 0; i < ch[LEXICON.l]; i++) {
                          el = ch[i];
                          if (selector) {
                              if ((el.matches && el.matches(selector)) || matches(el, selector))
                                  children.push(el);
                          }
                          else
                              children.push(el);
                      }
                  });
                  return FakejQuery(children);
              },

              parent: function (selector) {
                  var parents = [];
                  var parent;
                  this.each(function () {
                      parent = this.parentNode;
                      if (selector ? FakejQuery(parent).is(selector) : true)
                          parents.push(parent);
                  });
                  return FakejQuery(parents);
              },

              is: function (selector) {

                  var el;
                  var i;
                  for (i = 0; i < this[LEXICON.l]; i++) {
                      el = this[i];
                      if (selector === ':visible')
                          return elementIsVisible(el);
                      if (selector === ':hidden')
                          return !elementIsVisible(el);
                      if ((el.matches && el.matches(selector)) || matches(el, selector))
                          return true;
                  }
                  return false;
              },

              contents: function () {
                  var contents = [];
                  var childs;
                  var i;

                  this.each(function () {
                      childs = this.childNodes;
                      for (i = 0; i < childs[LEXICON.l]; i++)
                          contents.push(childs[i]);
                  });

                  return FakejQuery(contents);
              },

              each: function (callback) {
                  return each(this, callback);
              },


              //ANIMATION:

              animate: function (props, duration, easing, complete) {
                  return this.each(function () { animate(this, props, duration, easing, complete); });
              },

              stop: function (clearQ, jump) {
                  return this.each(function () { stop(this, clearQ, jump); });
              }
          };

          extend(FakejQuery, {
              extend: extend,
              inArray: inArray,
              isEmptyObject: isEmptyObject,
              isPlainObject: isPlainObject,
              each: each
          });

          return FakejQuery;
      })();
      var INSTANCES = (function () {
          var _targets = [];
          var _instancePropertyString = '__overlayScrollbars__';

          /**
           * Register, unregister or get a certain (or all) instances.
           * Register: Pass the target and the instance.
           * Unregister: Pass the target and null.
           * Get Instance: Pass the target from which the instance shall be got.
           * Get Targets: Pass no arguments.
           * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got
           * @param instance The instance.
           * @returns {*|void} Returns the instance from the given target.
           */
          return function (target, instance) {
              var argLen = arguments[LEXICON.l];
              if (argLen < 1) {
                  //return all targets
                  return _targets;
              }
              else {
                  if (instance) {
                      //register instance
                      target[_instancePropertyString] = instance;
                      _targets.push(target);
                  }
                  else {
                      var index = COMPATIBILITY.inA(target, _targets);
                      if (index > -1) {
                          if (argLen > 1) {
                              //unregister instance
                              delete target[_instancePropertyString];
                              _targets.splice(index, 1);
                          }
                          else {
                              //get instance from target
                              return _targets[index][_instancePropertyString];
                          }
                      }
                  }
              }
          }
      })();
      var PLUGIN = (function () {
          var _plugin;
          var _pluginsGlobals;
          var _pluginsAutoUpdateLoop;
          var _pluginsExtensions = [];
          var _pluginsOptions = (function () {
              var type = COMPATIBILITY.type;
              var possibleTemplateTypes = [
                  TYPES.b, //boolean
                  TYPES.n, //number
                  TYPES.s, //string
                  TYPES.a, //array
                  TYPES.o, //object
                  TYPES.f, //function
                  TYPES.z  //null
              ];
              var restrictedStringsSplit = ' ';
              var restrictedStringsPossibilitiesSplit = ':';
              var classNameAllowedValues = [TYPES.z, TYPES.s];
              var numberAllowedValues = TYPES.n;
              var booleanNullAllowedValues = [TYPES.z, TYPES.b];
              var booleanTrueTemplate = [true, TYPES.b];
              var booleanFalseTemplate = [false, TYPES.b];
              var callbackTemplate = [null, [TYPES.z, TYPES.f]];
              var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];
              var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];
              var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';
              var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';
              var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';
              var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';
              var optionsDefaultsAndTemplate = {
                  className: ['os-theme-dark', classNameAllowedValues],                //null || string
                  resize: ['none', resizeAllowedValues],                               //none || both  || horizontal || vertical || n || b || h || v
                  sizeAutoCapable: booleanTrueTemplate,                                //true || false
                  clipAlways: booleanTrueTemplate,                                     //true || false
                  normalizeRTL: booleanTrueTemplate,                                   //true || false
                  paddingAbsolute: booleanFalseTemplate,                               //true || false
                  autoUpdate: [null, booleanNullAllowedValues],                        //true || false || null
                  autoUpdateInterval: [33, numberAllowedValues],                       //number
                  updateOnLoad: updateOnLoadTemplate,                                  //string || array || null
                  nativeScrollbarsOverlaid: {
                      showNativeScrollbars: booleanFalseTemplate,                      //true || false
                      initialize: booleanTrueTemplate                                  //true || false
                  },
                  overflowBehavior: {
                      x: ['scroll', overflowBehaviorAllowedValues],                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                      y: ['scroll', overflowBehaviorAllowedValues]                     //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                  },
                  scrollbars: {
                      visibility: ['auto', scrollbarsVisibilityAllowedValues],         //visible || hidden || auto || v || h || a
                      autoHide: ['never', scrollbarsAutoHideAllowedValues],            //never || scroll || leave || move || n || s || l || m
                      autoHideDelay: [800, numberAllowedValues],                       //number
                      dragScrolling: booleanTrueTemplate,                              //true || false
                      clickScrolling: booleanFalseTemplate,                            //true || false
                      touchSupport: booleanTrueTemplate,                               //true || false
                      snapHandle: booleanFalseTemplate                                 //true || false
                  },
                  textarea: {
                      dynWidth: booleanFalseTemplate,                                  //true || false
                      dynHeight: booleanFalseTemplate,                                 //true || false
                      inheritedAttrs: inheritedAttrsTemplate                           //string || array || null
                  },
                  callbacks: {
                      onInitialized: callbackTemplate,                                 //null || function
                      onInitializationWithdrawn: callbackTemplate,                     //null || function
                      onDestroyed: callbackTemplate,                                   //null || function
                      onScrollStart: callbackTemplate,                                 //null || function
                      onScroll: callbackTemplate,                                      //null || function
                      onScrollStop: callbackTemplate,                                  //null || function
                      onOverflowChanged: callbackTemplate,                             //null || function
                      onOverflowAmountChanged: callbackTemplate,                       //null || function
                      onDirectionChanged: callbackTemplate,                            //null || function
                      onContentSizeChanged: callbackTemplate,                          //null || function
                      onHostSizeChanged: callbackTemplate,                             //null || function
                      onUpdated: callbackTemplate                                      //null || function
                  }
              };
              var convert = function (template) {
                  var recursive = function (obj) {
                      var key;
                      var val;
                      var valType;
                      for (key in obj) {
                          if (!obj[LEXICON.hOP](key))
                              continue;
                          val = obj[key];
                          valType = type(val);
                          if (valType == TYPES.a)
                              obj[key] = val[template ? 1 : 0];
                          else if (valType == TYPES.o)
                              obj[key] = recursive(val);
                      }
                      return obj;
                  };
                  return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
              };

              return {
                  _defaults: convert(),

                  _template: convert(true),

                  /**
                   * Validates the passed object by the passed template.
                   * @param obj The object which shall be validated.
                   * @param template The template which defines the allowed values and types.
                   * @param writeErrors True if errors shall be logged to the console.
                   * @param diffObj If a object is passed then only valid differences to this object will be returned.
                   * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
                   */
                  _validate: function (obj, template, writeErrors, diffObj) {
                      var validatedOptions = {};
                      var validatedOptionsPrepared = {};
                      var objectCopy = FRAMEWORK.extend(true, {}, obj);
                      var inArray = FRAMEWORK.inArray;
                      var isEmptyObj = FRAMEWORK.isEmptyObject;
                      var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {
                          for (var prop in template) {
                              if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                                  var isValid = false;
                                  var isDiff = false;
                                  var templateValue = template[prop];
                                  var templateValueType = type(templateValue);
                                  var templateIsComplex = templateValueType == TYPES.o;
                                  var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                                  var dataDiffValue = diffData[prop];
                                  var dataValue = data[prop];
                                  var dataValueType = type(dataValue);
                                  var propPrefix = prevPropName ? prevPropName + '.' : '';
                                  var error = "The option \"" + propPrefix + prop + "\" wasn't set, because";
                                  var errorPossibleTypes = [];
                                  var errorRestrictedStrings = [];
                                  var restrictedStringValuesSplit;
                                  var restrictedStringValuesPossibilitiesSplit;
                                  var isRestrictedValue;
                                  var mainPossibility;
                                  var currType;
                                  var i;
                                  var v;
                                  var j;

                                  dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue;

                                  //if the template has a object as value, it means that the options are complex (verschachtelt)
                                  if (templateIsComplex && dataValueType == TYPES.o) {
                                      validatedOptions[prop] = {};
                                      validatedOptionsPrepared[prop] = {};
                                      checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);
                                      FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {
                                          if (isEmptyObj(value[prop])) {
                                              delete value[prop];
                                          }
                                      });
                                  }
                                  else if (!templateIsComplex) {
                                      for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                                          currType = templateTypes[i];
                                          templateValueType = type(currType);
                                          //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix
                                          isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                                          if (isRestrictedValue) {
                                              errorPossibleTypes.push(TYPES.s);

                                              //split it into a array which contains all possible values for example: ["y:yes", "n:no", "m:maybe"]
                                              restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                                              errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                                              for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                                                  //split the possible values into their possibiliteis for example: ["y", "yes"] -> the first is always the mainPossibility
                                                  restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                                                  mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                                                  for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                                      //if any possibility matches with the dataValue, its valid
                                                      if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                                          isValid = true;
                                                          break;
                                                      }
                                                  }
                                                  if (isValid)
                                                      break;
                                              }
                                          }
                                          else {
                                              errorPossibleTypes.push(currType);

                                              if (dataValueType === currType) {
                                                  isValid = true;
                                                  break;
                                              }
                                          }
                                      }

                                      if (isValid) {
                                          isDiff = dataValue !== dataDiffValue;

                                          if (isDiff)
                                              validatedOptions[prop] = dataValue;

                                          if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                                              validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;
                                      }
                                      else if (writeErrors) {
                                          console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + " ] with the value of \"" + dataValue + "\".\r\n" +
                                              "Accepted types are: [ " + errorPossibleTypes.join(', ').toUpperCase() + " ]." +
                                              (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + " ]." : ''));
                                      }
                                      delete data[prop];
                                  }
                              }
                          }
                      };
                      checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);

                      //add values which aren't specified in the template to the finished validated object to prevent them from being discarded
                      /*
                      if(keepForeignProps) {
                          FRAMEWORK.extend(true, validatedOptions, objectCopy);
                          FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);
                      }
                      */

                      if (!isEmptyObj(objectCopy) && writeErrors)
                          console.warn('The following options are discarded due to invalidity:\r\n' + window.JSON.stringify(objectCopy, null, 2));

                      return {
                          _default: validatedOptions,
                          _prepared: validatedOptionsPrepared
                      };
                  }
              }
          }());

          /**
           * Initializes the object which contains global information about the plugin and each instance of it.
           */
          function initOverlayScrollbarsStatics() {
              if (!_pluginsGlobals)
                  _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
              if (!_pluginsAutoUpdateLoop)
                  _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
          }

          /**
           * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
           * @param defaultOptions
           * @constructor
           */
          function OverlayScrollbarsGlobals(defaultOptions) {
              var _base = this;
              var strOverflow = 'overflow';
              var strHidden = 'hidden';
              var strScroll = 'scroll';
              var bodyElement = FRAMEWORK('body');
              var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
              var scrollbarDummyElement0 = scrollbarDummyElement[0];
              var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));

              bodyElement.append(scrollbarDummyElement);
              scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)

              var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
              var nativeScrollbarIsOverlaid = {
                  x: nativeScrollbarSize.x === 0,
                  y: nativeScrollbarSize.y === 0
              };
              var msie = (function () {
                  var ua = window.navigator.userAgent;
                  var strIndexOf = 'indexOf';
                  var strSubString = 'substring';
                  var msie = ua[strIndexOf]('MSIE ');
                  var trident = ua[strIndexOf]('Trident/');
                  var edge = ua[strIndexOf]('Edge/');
                  var rv = ua[strIndexOf]('rv:');
                  var result;
                  var parseIntFunc = parseInt;

                  // IE 10 or older => return version number
                  if (msie > 0)
                      result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);

                  // IE 11 => return version number
                  else if (trident > 0)
                      result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);

                  // Edge (IE 12+) => return version number
                  else if (edge > 0)
                      result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10);

                  // other browser
                  return result;
              })();

              FRAMEWORK.extend(_base, {
                  defaultOptions: defaultOptions,
                  msie: msie,
                  autoUpdateLoop: false,
                  autoUpdateRecommended: !COMPATIBILITY.mO(),
                  nativeScrollbarSize: nativeScrollbarSize,
                  nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,
                  nativeScrollbarStyling: (function () {
                      var result = false;
                      scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');
                      try {
                          result = (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';
                      } catch (ex) { }

                      //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.
                      //and set overflow to scroll
                      //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();
                      //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;

                      return result;
                  })(),
                  overlayScrollbarDummySize: { x: 30, y: 30 },
                  cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,
                  restrictedMeasuring: (function () {
                      //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305
                      //since 1.11.0 always false -> fixed via CSS (hopefully)
                      scrollbarDummyElement.css(strOverflow, strHidden);
                      var scrollSize = {
                          w: scrollbarDummyElement0[LEXICON.sW],
                          h: scrollbarDummyElement0[LEXICON.sH]
                      };
                      scrollbarDummyElement.css(strOverflow, 'visible');
                      var scrollSize2 = {
                          w: scrollbarDummyElement0[LEXICON.sW],
                          h: scrollbarDummyElement0[LEXICON.sH]
                      };
                      return (scrollSize.w - scrollSize2.w) !== 0 || (scrollSize.h - scrollSize2.h) !== 0;
                  })(),
                  rtlScrollBehavior: (function () {
                      scrollbarDummyElement.css({ 'overflow-y': strHidden, 'overflow-x': strScroll, 'direction': 'rtl' }).scrollLeft(0);
                      var dummyContainerOffset = scrollbarDummyElement.offset();
                      var dummyContainerChildOffset = dummyContainerChild.offset();
                      //https://github.com/KingSora/OverlayScrollbars/issues/187
                      scrollbarDummyElement.scrollLeft(-999);
                      var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
                      return {
                          //origin direction = determines if the zero scroll position is on the left or right side
                          //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                          //true = on the left side
                          //false = on the right side
                          i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                          //negative = determines if the maximum scroll is positive or negative
                          //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                          //true = negative
                          //false = positive
                          n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
                      };
                  })(),
                  supportTransform: !!VENDORS._cssProperty('transform'),
                  supportTransition: !!VENDORS._cssProperty('transition'),
                  supportPassiveEvents: (function () {
                      var supportsPassive = false;
                      try {
                          window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
                              get: function () {
                                  supportsPassive = true;
                              }
                          }));
                      } catch (e) { }
                      return supportsPassive;
                  })(),
                  supportResizeObserver: !!COMPATIBILITY.rO(),
                  supportMutationObserver: !!COMPATIBILITY.mO()
              });

              scrollbarDummyElement.removeAttr(LEXICON.s).remove();

              //Catch zoom event:
              (function () {
                  if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                      return;

                  var abs = MATH.abs;
                  var windowWidth = COMPATIBILITY.wW();
                  var windowHeight = COMPATIBILITY.wH();
                  var windowDpr = getWindowDPR();
                  var onResize = function () {
                      if (INSTANCES().length > 0) {
                          var newW = COMPATIBILITY.wW();
                          var newH = COMPATIBILITY.wH();
                          var deltaW = newW - windowWidth;
                          var deltaH = newH - windowHeight;

                          if (deltaW === 0 && deltaH === 0)
                              return;

                          var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));
                          var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));
                          var absDeltaW = abs(deltaW);
                          var absDeltaH = abs(deltaH);
                          var absDeltaWRatio = abs(deltaWRatio);
                          var absDeltaHRatio = abs(deltaHRatio);
                          var newDPR = getWindowDPR();

                          var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                          var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                          var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                          var isZoom = deltaIsBigger && difference && dprChanged;
                          var oldScrollbarSize = _base.nativeScrollbarSize;
                          var newScrollbarSize;

                          if (isZoom) {
                              bodyElement.append(scrollbarDummyElement);
                              newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                              scrollbarDummyElement.remove();
                              if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                                  FRAMEWORK.each(INSTANCES(), function () {
                                      if (INSTANCES(this))
                                          INSTANCES(this).update('zoom');
                                  });
                              }
                          }

                          windowWidth = newW;
                          windowHeight = newH;
                          windowDpr = newDPR;
                      }
                  };

                  function differenceIsBiggerThanOne(valOne, valTwo) {
                      var absValOne = abs(valOne);
                      var absValTwo = abs(valTwo);
                      return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
                  }

                  function getWindowDPR() {
                      var dDPI = window.screen.deviceXDPI || 0;
                      var sDPI = window.screen.logicalXDPI || 1;
                      return window.devicePixelRatio || (dDPI / sDPI);
                  }

                  FRAMEWORK(window).on('resize', onResize);
              })();

              function calcNativeScrollbarSize(measureElement) {
                  return {
                      x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                      y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
                  };
              }
          }

          /**
           * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
           * @constructor
           */
          function OverlayScrollbarsAutoUpdateLoop(globals) {
              var _base = this;
              var _inArray = FRAMEWORK.inArray;
              var _getNow = COMPATIBILITY.now;
              var _strAutoUpdate = 'autoUpdate';
              var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';
              var _strLength = LEXICON.l;
              var _loopingInstances = [];
              var _loopingInstancesIntervalCache = [];
              var _loopIsActive = false;
              var _loopIntervalDefault = 33;
              var _loopInterval = _loopIntervalDefault;
              var _loopTimeOld = _getNow();
              var _loopID;


              /**
               * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.
               */
              var loop = function () {
                  if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                      _loopID = COMPATIBILITY.rAF()(function () {
                          loop();
                      });
                      var timeNew = _getNow();
                      var timeDelta = timeNew - _loopTimeOld;
                      var lowestInterval;
                      var instance;
                      var instanceOptions;
                      var instanceAutoUpdateAllowed;
                      var instanceAutoUpdateInterval;
                      var now;

                      if (timeDelta > _loopInterval) {
                          _loopTimeOld = timeNew - (timeDelta % _loopInterval);
                          lowestInterval = _loopIntervalDefault;
                          for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                              instance = _loopingInstances[i];
                              if (instance !== undefined) {
                                  instanceOptions = instance.options();
                                  instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                                  instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                                  now = _getNow();

                                  if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && (now - _loopingInstancesIntervalCache[i]) > instanceAutoUpdateInterval) {
                                      instance.update('auto');
                                      _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                                  }

                                  lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                              }
                          }
                          _loopInterval = lowestInterval;
                      }
                  } else {
                      _loopInterval = _loopIntervalDefault;
                  }
              };

              /**
               * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.
               * @param instance The instance which shall be updated in a loop automatically.
               */
              _base.add = function (instance) {
                  if (_inArray(instance, _loopingInstances) === -1) {
                      _loopingInstances.push(instance);
                      _loopingInstancesIntervalCache.push(_getNow());
                      if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                          _loopIsActive = true;
                          globals.autoUpdateLoop = _loopIsActive;
                          loop();
                      }
                  }
              };

              /**
               * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.
               * @param instance The instance which shall be updated in a loop automatically.
               */
              _base.remove = function (instance) {
                  var index = _inArray(instance, _loopingInstances);
                  if (index > -1) {
                      //remove from loopingInstances list
                      _loopingInstancesIntervalCache.splice(index, 1);
                      _loopingInstances.splice(index, 1);

                      //correct update loop behavior
                      if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                          _loopIsActive = false;
                          globals.autoUpdateLoop = _loopIsActive;
                          if (_loopID !== undefined) {
                              COMPATIBILITY.cAF()(_loopID);
                              _loopID = -1;
                          }
                      }
                  }
              };
          }

          /**
           * A object which manages the scrollbars visibility of the target element.
           * @param pluginTargetElement The element from which the scrollbars shall be hidden.
           * @param options The custom options.
           * @param extensions The custom extensions.
           * @param globals
           * @param autoUpdateLoop
           * @returns {*}
           * @constructor
           */
          function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
              //shortcuts
              var type = COMPATIBILITY.type;
              var inArray = FRAMEWORK.inArray;
              var each = FRAMEWORK.each;

              //make correct instanceof
              var _base = new _plugin();
              var _frameworkProto = FRAMEWORK[LEXICON.p];

              //if passed element is no HTML element: skip and return
              if (!isHTMLElement(pluginTargetElement))
                  return;

              //if passed element is already initialized: set passed options if there are any and return its instance
              if (INSTANCES(pluginTargetElement)) {
                  var inst = INSTANCES(pluginTargetElement);
                  inst.options(options);
                  return inst;
              }

              //globals:
              var _nativeScrollbarIsOverlaid;
              var _overlayScrollbarDummySize;
              var _rtlScrollBehavior;
              var _autoUpdateRecommended;
              var _msieVersion;
              var _nativeScrollbarStyling;
              var _cssCalc;
              var _nativeScrollbarSize;
              var _supportTransition;
              var _supportTransform;
              var _supportPassiveEvents;
              var _supportResizeObserver;
              var _supportMutationObserver;
              var _restrictedMeasuring;

              //general readonly:
              var _initialized;
              var _destroyed;
              var _isTextarea;
              var _isBody;
              var _documentMixed;
              var _domExists;

              //general:
              var _isBorderBox;
              var _sizeAutoObserverAdded;
              var _paddingX;
              var _paddingY;
              var _borderX;
              var _borderY;
              var _marginX;
              var _marginY;
              var _isRTL;
              var _sleeping;
              var _contentBorderSize = {};
              var _scrollHorizontalInfo = {};
              var _scrollVerticalInfo = {};
              var _viewportSize = {};
              var _nativeScrollbarMinSize = {};

              //naming:	
              var _strMinusHidden = '-hidden';
              var _strMarginMinus = 'margin-';
              var _strPaddingMinus = 'padding-';
              var _strBorderMinus = 'border-';
              var _strTop = 'top';
              var _strRight = 'right';
              var _strBottom = 'bottom';
              var _strLeft = 'left';
              var _strMinMinus = 'min-';
              var _strMaxMinus = 'max-';
              var _strWidth = 'width';
              var _strHeight = 'height';
              var _strFloat = 'float';
              var _strEmpty = '';
              var _strAuto = 'auto';
              var _strSync = 'sync';
              var _strScroll = 'scroll';
              var _strHundredPercent = '100%';
              var _strX = 'x';
              var _strY = 'y';
              var _strDot = '.';
              var _strSpace = ' ';
              var _strScrollbar = 'scrollbar';
              var _strMinusHorizontal = '-horizontal';
              var _strMinusVertical = '-vertical';
              var _strScrollLeft = _strScroll + 'Left';
              var _strScrollTop = _strScroll + 'Top';
              var _strMouseTouchDownEvent = 'mousedown touchstart';
              var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';
              var _strMouseTouchMoveEvent = 'mousemove touchmove';
              var _strMouseEnter = 'mouseenter';
              var _strMouseLeave = 'mouseleave';
              var _strKeyDownEvent = 'keydown';
              var _strKeyUpEvent = 'keyup';
              var _strSelectStartEvent = 'selectstart';
              var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';
              var _strResizeObserverProperty = '__overlayScrollbarsRO__';

              //class names:	
              var _cassNamesPrefix = 'os-';
              var _classNameHTMLElement = _cassNamesPrefix + 'html';
              var _classNameHostElement = _cassNamesPrefix + 'host';
              var _classNameHostElementForeign = _classNameHostElement + '-foreign';
              var _classNameHostTextareaElement = _classNameHostElement + '-textarea';
              var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
              var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;
              var _classNameHostTransition = _classNameHostElement + '-transition';
              var _classNameHostRTL = _classNameHostElement + '-rtl';
              var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';
              var _classNameHostScrolling = _classNameHostElement + '-scrolling';
              var _classNameHostOverflow = _classNameHostElement + '-overflow';
              var _classNameHostOverflow = _classNameHostElement + '-overflow';
              var _classNameHostOverflowX = _classNameHostOverflow + '-x';
              var _classNameHostOverflowY = _classNameHostOverflow + '-y';
              var _classNameTextareaElement = _cassNamesPrefix + 'textarea';
              var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';
              var _classNamePaddingElement = _cassNamesPrefix + 'padding';
              var _classNameViewportElement = _cassNamesPrefix + 'viewport';
              var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';
              var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';
              var _classNameContentElement = _cassNamesPrefix + 'content';
              var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';
              var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';
              var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';
              var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';
              var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';
              var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';
              var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';
              var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
              var _classNameScrollbarTrack = _classNameScrollbar + '-track';
              var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';
              var _classNameScrollbarHandle = _classNameScrollbar + '-handle';
              var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';
              var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';
              var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;
              var _classNameScrollbarCorner = _classNameScrollbar + '-corner';
              var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';
              var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';
              var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
              var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
              var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
              var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
              var _classNameDragging = _cassNamesPrefix + 'dragging';
              var _classNameThemeNone = _cassNamesPrefix + 'theme-none';
              var _classNamesDynamicDestroy = [
                  _classNameViewportNativeScrollbarsInvisible,
                  _classNameViewportNativeScrollbarsOverlaid,
                  _classNameScrollbarTrackOff,
                  _classNameScrollbarHandleOff,
                  _classNameScrollbarUnusable,
                  _classNameScrollbarAutoHidden,
                  _classNameScrollbarCornerResize,
                  _classNameScrollbarCornerResizeB,
                  _classNameScrollbarCornerResizeH,
                  _classNameScrollbarCornerResizeV,
                  _classNameDragging].join(_strSpace);

              //callbacks:	
              var _callbacksInitQeueue = [];

              //attrs viewport shall inherit from target	
              var _viewportAttrsFromTarget = [LEXICON.ti];

              //options:	
              var _defaultOptions;
              var _currentOptions;
              var _currentPreparedOptions;

              //extensions:	
              var _extensions = {};
              var _extensionsPrivateMethods = 'added removed on contract';

              //update	
              var _lastUpdateTime;
              var _swallowedUpdateHints = {};
              var _swallowedUpdateTimeout;
              var _swallowUpdateLag = 42;
              var _updateOnLoadEventName = 'load';
              var _updateOnLoadElms = [];

              //DOM elements:	
              var _windowElement;
              var _documentElement;
              var _htmlElement;
              var _bodyElement;
              var _targetElement;                     //the target element of this OverlayScrollbars object	
              var _hostElement;                       //the host element of this OverlayScrollbars object -> may be the same as targetElement	
              var _sizeAutoObserverElement;           //observes size auto changes	
              var _sizeObserverElement;               //observes size and padding changes	
              var _paddingElement;                    //manages the padding	
              var _viewportElement;                   //is the viewport of our scrollbar model	
              var _contentElement;                    //the element which holds the content	
              var _contentArrangeElement;             //is needed for correct sizing of the content element (only if native scrollbars are overlays)	
              var _contentGlueElement;                //has always the size of the content element	
              var _textareaCoverElement;              //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling	
              var _scrollbarCornerElement;
              var _scrollbarHorizontalElement;
              var _scrollbarHorizontalTrackElement;
              var _scrollbarHorizontalHandleElement;
              var _scrollbarVerticalElement;
              var _scrollbarVerticalTrackElement;
              var _scrollbarVerticalHandleElement;
              var _windowElementNative;
              var _documentElementNative;
              var _targetElementNative;
              var _hostElementNative;
              var _sizeAutoObserverElementNative;
              var _sizeObserverElementNative;
              var _paddingElementNative;
              var _viewportElementNative;
              var _contentElementNative;

              //Cache:	
              var _hostSizeCache;
              var _contentScrollSizeCache;
              var _arrangeContentSizeCache;
              var _hasOverflowCache;
              var _hideOverflowCache;
              var _widthAutoCache;
              var _heightAutoCache;
              var _cssBoxSizingCache;
              var _cssPaddingCache;
              var _cssBorderCache;
              var _cssMarginCache;
              var _cssDirectionCache;
              var _cssDirectionDetectedCache;
              var _paddingAbsoluteCache;
              var _clipAlwaysCache;
              var _contentGlueSizeCache;
              var _overflowBehaviorCache;
              var _overflowAmountCache;
              var _ignoreOverlayScrollbarHidingCache;
              var _autoUpdateCache;
              var _sizeAutoCapableCache;
              var _contentElementScrollSizeChangeDetectedCache;
              var _hostElementSizeChangeDetectedCache;
              var _scrollbarsVisibilityCache;
              var _scrollbarsAutoHideCache;
              var _scrollbarsClickScrollingCache;
              var _scrollbarsDragScrollingCache;
              var _resizeCache;
              var _normalizeRTLCache;
              var _classNameCache;
              var _oldClassName;
              var _textareaAutoWrappingCache;
              var _textareaInfoCache;
              var _textareaSizeCache;
              var _textareaDynHeightCache;
              var _textareaDynWidthCache;
              var _bodyMinSizeCache;
              var _updateAutoCache = {};

              //MutationObserver:	
              var _mutationObserverHost;
              var _mutationObserverContent;
              var _mutationObserverHostCallback;
              var _mutationObserverContentCallback;
              var _mutationObserversConnected;
              var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];
              var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget);

              //events:	
              var _destroyEvents = [];

              //textarea:	
              var _textareaHasFocus;

              //scrollbars:	
              var _scrollbarsAutoHideTimeoutId;
              var _scrollbarsAutoHideMoveTimeoutId;
              var _scrollbarsAutoHideDelay;
              var _scrollbarsAutoHideNever;
              var _scrollbarsAutoHideScroll;
              var _scrollbarsAutoHideMove;
              var _scrollbarsAutoHideLeave;
              var _scrollbarsHandleHovered;
              var _scrollbarsHandlesDefineScrollPos;

              //resize	
              var _resizeNone;
              var _resizeBoth;
              var _resizeHorizontal;
              var _resizeVertical;


              //==== Event Listener ====//	

              /**	
               * Adds or removes a event listener from the given element. 	
               * @param element The element to which the event listener shall be applied or removed.	
               * @param eventNames The name(s) of the events.	
               * @param listener The method which shall be called.	
               * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.	
               * @param passiveOrOptions The options for the event.
               */
              function setupResponsiveEventListener(element, eventNames, listener, remove, passiveOrOptions) {
                  var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
                  var method = remove ? 'removeEventListener' : 'addEventListener';
                  var onOff = remove ? 'off' : 'on';
                  var events = collected ? false : eventNames.split(_strSpace)
                  var i = 0;

                  var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
                  var passive = _supportPassiveEvents && (passiveOrOptionsIsObj ? (passiveOrOptions._passive || false) : passiveOrOptions);
                  var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
                  var useNative = capture || passive;
                  var nativeParam = passive ? {
                      passive: passive,
                      capture: capture,
                  } : capture;

                  if (collected) {
                      for (; i < eventNames[LEXICON.l]; i++)
                          setupResponsiveEventListener(element, eventNames[i], listener[i], remove, passiveOrOptions);
                  }
                  else {
                      for (; i < events[LEXICON.l]; i++) {
                          if(useNative) {
                              element[0][method](events[i], listener, nativeParam);
                          }
                          else {
                              element[onOff](events[i], listener);
                          }     
                      }
                  }
              }


              function addDestroyEventListener(element, eventNames, listener, passive) {
                  setupResponsiveEventListener(element, eventNames, listener, false, passive);
                  _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
              }

              //==== Resize Observer ====//

              /**
               * Adds or removes a resize observer from the given element.
               * @param targetElement The element to which the resize observer shall be added or removed.
               * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.
               */
              function setupResizeObserver(targetElement, onElementResizedCallback) {
                  if (targetElement) {
                      var resizeObserver = COMPATIBILITY.rO();
                      var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';
                      var strChildNodes = 'childNodes';
                      var constScroll = 3333333;
                      var callback = function () {
                          targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
                          onElementResizedCallback();
                      };
                      //add resize observer:
                      if (onElementResizedCallback) {
                          if (_supportResizeObserver) {
                              var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                              var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                              observer.observe(element);
                          }
                          else {
                              if (_msieVersion > 9 || !_autoUpdateRecommended) {
                                  targetElement.prepend(
                                      generateDiv(_classNameResizeObserverElement,
                                          generateDiv({ c: _classNameResizeObserverItemElement, dir: 'ltr' },
                                              generateDiv(_classNameResizeObserverItemElement,
                                                  generateDiv(_classNameResizeObserverItemFinalElement)
                                              ) +
                                              generateDiv(_classNameResizeObserverItemElement,
                                                  generateDiv({ c: _classNameResizeObserverItemFinalElement, style: 'width: 200%; height: 200%' })
                                              )
                                          )
                                      )
                                  );

                                  var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                                  var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                                  var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                                  var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                                  var widthCache = observerElement[LEXICON.oW];
                                  var heightCache = observerElement[LEXICON.oH];
                                  var isDirty;
                                  var rAFId;
                                  var currWidth;
                                  var currHeight;
                                  var factor = 2;
                                  var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!
                                  var reset = function () {
                                      /*
                                       var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                       var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                       var expandChildCSS = {};
                                       expandChildCSS[_strWidth] = sizeResetWidth;
                                       expandChildCSS[_strHeight] = sizeResetHeight;
                                       expandElementChild.css(expandChildCSS);


                                       expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                       shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                       */
                                      expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                      shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                  };
                                  var onResized = function () {
                                      rAFId = 0;
                                      if (!isDirty)
                                          return;

                                      widthCache = currWidth;
                                      heightCache = currHeight;
                                      callback();
                                  };
                                  var onScroll = function (event) {
                                      currWidth = observerElement[LEXICON.oW];
                                      currHeight = observerElement[LEXICON.oH];
                                      isDirty = currWidth != widthCache || currHeight != heightCache;

                                      if (event && isDirty && !rAFId) {
                                          COMPATIBILITY.cAF()(rAFId);
                                          rAFId = COMPATIBILITY.rAF()(onResized);
                                      }
                                      else if (!event)
                                          onResized();

                                      reset();
                                      if (event) {
                                          COMPATIBILITY.prvD(event);
                                          COMPATIBILITY.stpP(event);
                                      }
                                      return false;
                                  };
                                  var expandChildCSS = {};
                                  var observerElementCSS = {};

                                  setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                                      -((nativeScrollbarSize.y + 1) * factor),
                                      nativeScrollbarSize.x * -factor,
                                      nativeScrollbarSize.y * -factor,
                                      -((nativeScrollbarSize.x + 1) * factor)
                                  ]);

                                  FRAMEWORK(observerElement).css(observerElementCSS);
                                  expandElement.on(_strScroll, onScroll);
                                  shrinkElement.on(_strScroll, onScroll);
                                  targetElement.on(strAnimationStartEvent, function () {
                                      onScroll(false);
                                  });
                                  //lets assume that the divs will never be that large and a constant value is enough
                                  expandChildCSS[_strWidth] = constScroll;
                                  expandChildCSS[_strHeight] = constScroll;
                                  expandElementChild.css(expandChildCSS);

                                  reset();
                              }
                              else {
                                  var attachEvent = _documentElementNative.attachEvent;
                                  var isIE = _msieVersion !== undefined;
                                  if (attachEvent) {
                                      targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                                      findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);
                                  }
                                  else {
                                      var obj = _documentElementNative.createElement(TYPES.o);
                                      obj.setAttribute(LEXICON.ti, '-1');
                                      obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                                      obj.onload = function () {
                                          var wnd = this.contentDocument.defaultView;
                                          wnd.addEventListener('resize', callback);
                                          wnd.document.documentElement.style.display = 'none';
                                      };
                                      obj.type = 'text/html';
                                      if (isIE)
                                          targetElement.prepend(obj);
                                      obj.data = 'about:blank';
                                      if (!isIE)
                                          targetElement.prepend(obj);
                                      targetElement.on(strAnimationStartEvent, callback);
                                  }
                              }
                          }

                          if (targetElement[0] === _sizeObserverElementNative) {
                              var directionChanged = function () {
                                  var dir = _hostElement.css('direction');
                                  var css = {};
                                  var scrollLeftValue = 0;
                                  var result = false;
                                  if (dir !== _cssDirectionDetectedCache) {
                                      if (dir === 'ltr') {
                                          css[_strLeft] = 0;
                                          css[_strRight] = _strAuto;
                                          scrollLeftValue = constScroll;
                                      }
                                      else {
                                          css[_strLeft] = _strAuto;
                                          css[_strRight] = 0;
                                          scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                                      }
                                      //execution order is important for IE!!!
                                      _sizeObserverElement.children().eq(0).css(css);
                                      _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                                      _cssDirectionDetectedCache = dir;
                                      result = true;
                                  }
                                  return result;
                              };
                              directionChanged();
                              addDestroyEventListener(targetElement, _strScroll, function (event) {
                                  if (directionChanged())
                                      update();
                                  COMPATIBILITY.prvD(event);
                                  COMPATIBILITY.stpP(event);
                                  return false;
                              });
                          }
                      }
                      //remove resize observer:
                      else {
                          if (_supportResizeObserver) {
                              var element = targetElement.contents()[0];
                              var resizeObserverObj = element[_strResizeObserverProperty];
                              if (resizeObserverObj) {
                                  resizeObserverObj.disconnect();
                                  delete element[_strResizeObserverProperty];
                              }
                          }
                          else {
                              remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                          }
                      }
                  }
              }

              /**
               * Freezes or unfreezes the given resize observer.
               * @param targetElement The element to which the target resize observer is applied.
               * @param freeze True if the resize observer shall be frozen, false otherwise.
               
              function freezeResizeObserver(targetElement, freeze) {
                  if (targetElement !== undefined) {
                      if(freeze) {
                          if (_supportResizeObserver) {
                              var element = targetElement.contents()[0];
                              element[_strResizeObserverProperty].unobserve(element);
                          }
                          else {
                              targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);
                              var w = targetElement.css(_strWidth);
                              var h = targetElement.css(_strHeight);
                              var css = {};
                              css[_strWidth] = w;
                              css[_strHeight] = h;
                              targetElement.css(css);
                          }
                      }
                      else {
                          if (_supportResizeObserver) {
                              var element = targetElement.contents()[0];
                              element[_strResizeObserverProperty].observe(element);
                          }
                          else {
                              var css = { };
                              css[_strHeight] = _strEmpty;
                              css[_strWidth] = _strEmpty;
                              targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);
                          }
                      }
                  }
              }
              */


              //==== Mutation Observers ====//

              /**
               * Creates MutationObservers for the host and content Element if they are supported.
               */
              function createMutationObservers() {
                  if (_supportMutationObserver) {
                      var mutationObserverContentLag = 11;
                      var mutationObserver = COMPATIBILITY.mO();
                      var contentLastUpdate = COMPATIBILITY.now();
                      var mutationTarget;
                      var mutationAttrName;
                      var mutationIsClass;
                      var oldMutationVal;
                      var newClassVal;
                      var hostClassNameRegex;
                      var contentTimeout;
                      var now;
                      var sizeAuto;
                      var action;

                      _mutationObserverHostCallback = function (mutations) {

                          var doUpdate = false;
                          var doUpdateForce = false;
                          var mutation;
                          var mutatedAttrs = [];

                          if (_initialized && !_sleeping) {
                              each(mutations, function () {
                                  mutation = this;
                                  mutationTarget = mutation.target;
                                  mutationAttrName = mutation.attributeName;
                                  mutationIsClass = mutationAttrName === LEXICON.c;
                                  oldMutationVal = mutation.oldValue;
                                  newClassVal = mutationTarget.className;

                                  if (_domExists && mutationIsClass && !doUpdateForce) {
                                      // if old class value contains _classNameHostElementForeign and new class value doesn't
                                      if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                                          hostClassNameRegex = createHostClassNameRegExp(true);
                                          _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {
                                              return name.match(hostClassNameRegex);
                                          })).join(_strSpace);
                                          doUpdate = doUpdateForce = true;
                                      }
                                  }

                                  if (!doUpdate) {
                                      doUpdate = mutationIsClass
                                          ? hostClassNamesChanged(oldMutationVal, newClassVal)
                                          : mutationAttrName === LEXICON.s
                                              ? oldMutationVal !== mutationTarget[LEXICON.s].cssText
                                              : true;
                                  }

                                  mutatedAttrs.push(mutationAttrName);
                              });

                              updateViewportAttrsFromTarget(mutatedAttrs);

                              if (doUpdate)
                                  _base.update(doUpdateForce || _strAuto);
                          }
                          return doUpdate;
                      };
                      _mutationObserverContentCallback = function (mutations) {
                          var doUpdate = false;
                          var mutation;

                          if (_initialized && !_sleeping) {
                              each(mutations, function () {
                                  mutation = this;
                                  doUpdate = isUnknownMutation(mutation);
                                  return !doUpdate;
                              });

                              if (doUpdate) {
                                  now = COMPATIBILITY.now();
                                  sizeAuto = (_heightAutoCache || _widthAutoCache);
                                  action = function () {
                                      if (!_destroyed) {
                                          contentLastUpdate = now;

                                          //if cols, rows or wrap attr was changed
                                          if (_isTextarea)
                                              textareaUpdate();

                                          if (sizeAuto)
                                              update();
                                          else
                                              _base.update(_strAuto);
                                      }
                                  };
                                  clearTimeout(contentTimeout);
                                  if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                                      action();
                                  else
                                      contentTimeout = setTimeout(action, mutationObserverContentLag);
                              }
                          }
                          return doUpdate;
                      }

                      _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                      _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
                  }
              }

              /**
               * Connects the MutationObservers if they are supported.
               */
              function connectMutationObservers() {
                  if (_supportMutationObserver && !_mutationObserversConnected) {
                      _mutationObserverHost.observe(_hostElementNative, {
                          attributes: true,
                          attributeOldValue: true,
                          attributeFilter: _mutationObserverAttrsHost
                      });

                      _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                          attributes: true,
                          attributeOldValue: true,
                          subtree: !_isTextarea,
                          childList: !_isTextarea,
                          characterData: !_isTextarea,
                          attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                      });

                      _mutationObserversConnected = true;
                  }
              }

              /**
               * Disconnects the MutationObservers if they are supported.
               */
              function disconnectMutationObservers() {
                  if (_supportMutationObserver && _mutationObserversConnected) {
                      _mutationObserverHost.disconnect();
                      _mutationObserverContent.disconnect();

                      _mutationObserversConnected = false;
                  }
              }


              //==== Events of elements ====//

              /**
               * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!
               * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.
               * If there are any size changes, the update method gets called.
               */
              function hostOnResized() {
                  if (!_sleeping) {
                      var changed;
                      var hostSize = {
                          w: _sizeObserverElementNative[LEXICON.sW],
                          h: _sizeObserverElementNative[LEXICON.sH]
                      };

                      changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                      _hostElementSizeChangeDetectedCache = hostSize;
                      if (changed)
                          update({ _hostSizeChanged: true });
                  }
              }

              /**
               * The mouse enter event of the host element. This event is only needed for the autoHide feature.
               */
              function hostOnMouseEnter() {
                  if (_scrollbarsAutoHideLeave)
                      refreshScrollbarsAutoHide(true);
              }

              /**
               * The mouse leave event of the host element. This event is only needed for the autoHide feature.
               */
              function hostOnMouseLeave() {
                  if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
                      refreshScrollbarsAutoHide(false);
              }

              /**
               * The mouse move event of the host element. This event is only needed for the autoHide "move" feature.
               */
              function hostOnMouseMove() {
                  if (_scrollbarsAutoHideMove) {
                      refreshScrollbarsAutoHide(true);
                      clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                      _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {
                          if (_scrollbarsAutoHideMove && !_destroyed)
                              refreshScrollbarsAutoHide(false);
                      }, 100);
                  }
              }

              /**
               * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.
               * @param event The select start event.
               */
              function documentOnSelectStart(event) {
                  COMPATIBILITY.prvD(event);
                  return false;
              }

              /**	
               * A callback which will be called after a element has loaded.	
               */
              function updateOnLoadCallback(event) {
                  var elm = FRAMEWORK(event.target);

                  eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                      if (elm.is(updateOnLoadSelector)) {
                          update({ _contentSizeChanged: true });
                      }
                  });
              }

              /**
              * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)
              * @param destroy Indicates whether the events shall be added or removed.
              */
              function setupHostMouseTouchEvents(destroy) {
                  if (!destroy)
                      setupHostMouseTouchEvents(true);

                  setupResponsiveEventListener(_hostElement,
                      _strMouseTouchMoveEvent.split(_strSpace)[0],
                      hostOnMouseMove,
                      (!_scrollbarsAutoHideMove || destroy), true);
                  setupResponsiveEventListener(_hostElement,
                      [_strMouseEnter, _strMouseLeave],
                      [hostOnMouseEnter, hostOnMouseLeave],
                      (!_scrollbarsAutoHideLeave || destroy), true);

                  //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible
                  if (!_initialized && !destroy)
                      _hostElement.one('mouseover', hostOnMouseEnter);
              }


              //==== Update Detection ====//

              /**
               * Measures the min width and min height of the body element and refreshes the related cache.
               * @returns {boolean} True if the min width or min height has changed, false otherwise.
               */
              function bodyMinSizeChanged() {
                  var bodyMinSize = {};
                  if (_isBody && _contentArrangeElement) {
                      bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                      bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                      bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                      bodyMinSize.f = true; //flag for "measured at least once"
                  }
                  _bodyMinSizeCache = bodyMinSize;
                  return !!bodyMinSize.c;
              }

              /**
               * Returns true if the class names really changed (new class without plugin host prefix)
               * @param oldClassNames The old ClassName string or array.
               * @param newClassNames The new ClassName string or array.
               * @returns {boolean} True if the class names has really changed, false otherwise.
               */
              function hostClassNamesChanged(oldClassNames, newClassNames) {
                  var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
                  var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
                  var diff = getArrayDifferences(oldClasses, currClasses);

                  // remove none theme from diff list to prevent update
                  var idx = inArray(_classNameThemeNone, diff);
                  var i;
                  var regex;

                  if (idx > -1)
                      diff.splice(idx, 1);

                  if (diff[LEXICON.l] > 0) {
                      regex = createHostClassNameRegExp(true, true);
                      for (i = 0; i < diff.length; i++) {
                          if (!diff[i].match(regex)) {
                              return true;
                          }
                      }
                  }
                  return false;
              }

              /**
               * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.
               * @param mutation The mutation which shall be checked.
               * @returns {boolean} True if the mutation is from a unknown element, false otherwise.
               */
              function isUnknownMutation(mutation) {
                  var attributeName = mutation.attributeName;
                  var mutationTarget = mutation.target;
                  var mutationType = mutation.type;
                  var strClosest = 'closest';

                  if (mutationTarget === _contentElementNative)
                      return attributeName === null;
                  if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                      //ignore className changes by the plugin	
                      if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                          return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);

                      //only do it of browser support it natively	
                      if (typeof mutationTarget[strClosest] != TYPES.f)
                          return true;
                      if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||
                          mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||
                          mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                          return false;
                  }
                  return true;
              }

              /**
               * Returns true if the content size was changed since the last time this method was called.
               * @returns {boolean} True if the content size was changed, false otherwise.
               */
              function updateAutoContentSizeChanged() {
                  if (_sleeping)
                      return false;

                  var contentMeasureElement = getContentMeasureElement();
                  var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
                  var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
                  var css = {};
                  var float;
                  var bodyMinSizeC;
                  var changed;
                  var contentElementScrollSize;

                  if (setCSS) {
                      float = _contentElement.css(_strFloat);
                      css[_strFloat] = _isRTL ? _strRight : _strLeft;
                      css[_strWidth] = _strAuto;
                      _contentElement.css(css);
                  }
                  contentElementScrollSize = {
                      w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                      h: contentMeasureElement[LEXICON.sH] + textareaValueLength
                  };
                  if (setCSS) {
                      css[_strFloat] = float;
                      css[_strWidth] = _strHundredPercent;
                      _contentElement.css(css);
                  }

                  bodyMinSizeC = bodyMinSizeChanged();
                  changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);

                  _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;

                  return changed || bodyMinSizeC;
              }

              /**
               * Returns true when a attribute which the MutationObserver would observe has changed.  
               * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.
               */
              function meaningfulAttrsChanged() {
                  if (_sleeping || _mutationObserversConnected)
                      return;

                  var elem;
                  var curr;
                  var cache;
                  var changedAttrs = [];
                  var checks = [
                      {
                          _elem: _hostElement,
                          _attrs: _mutationObserverAttrsHost.concat(':visible')
                      },
                      {
                          _elem: _isTextarea ? _targetElement : undefined,
                          _attrs: _mutationObserverAttrsTextarea
                      }
                  ];

                  each(checks, function (index, check) {
                      elem = check._elem;
                      if (elem) {
                          each(check._attrs, function (index, attr) {
                              curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);
                              cache = _updateAutoCache[attr];

                              if (checkCache(curr, cache)) {
                                  changedAttrs.push(attr);
                              }

                              _updateAutoCache[attr] = curr;
                          });
                      }
                  });

                  updateViewportAttrsFromTarget(changedAttrs);

                  return changedAttrs[LEXICON.l] > 0;
              }

              /**
               * Checks is a CSS Property of a child element is affecting the scroll size of the content.
               * @param propertyName The CSS property name.
               * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.
               */
              function isSizeAffectingCSSProperty(propertyName) {
                  if (!_initialized)
                      return true;
                  var flexGrow = 'flex-grow';
                  var flexShrink = 'flex-shrink';
                  var flexBasis = 'flex-basis';
                  var affectingPropsX = [
                      _strWidth,
                      _strMinMinus + _strWidth,
                      _strMaxMinus + _strWidth,
                      _strMarginMinus + _strLeft,
                      _strMarginMinus + _strRight,
                      _strLeft,
                      _strRight,
                      'font-weight',
                      'word-spacing',
                      flexGrow,
                      flexShrink,
                      flexBasis
                  ];
                  var affectingPropsXContentBox = [
                      _strPaddingMinus + _strLeft,
                      _strPaddingMinus + _strRight,
                      _strBorderMinus + _strLeft + _strWidth,
                      _strBorderMinus + _strRight + _strWidth
                  ];
                  var affectingPropsY = [
                      _strHeight,
                      _strMinMinus + _strHeight,
                      _strMaxMinus + _strHeight,
                      _strMarginMinus + _strTop,
                      _strMarginMinus + _strBottom,
                      _strTop,
                      _strBottom,
                      'line-height',
                      flexGrow,
                      flexShrink,
                      flexBasis
                  ];
                  var affectingPropsYContentBox = [
                      _strPaddingMinus + _strTop,
                      _strPaddingMinus + _strBottom,
                      _strBorderMinus + _strTop + _strWidth,
                      _strBorderMinus + _strBottom + _strWidth
                  ];
                  var _strS = 's';
                  var _strVS = 'v-s';
                  var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
                  var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
                  var sizeIsAffected = false;
                  var checkPropertyName = function (arr, name) {
                      for (var i = 0; i < arr[LEXICON.l]; i++) {
                          if (arr[i] === name)
                              return true;
                      }
                      return false;
                  };

                  if (checkY) {
                      sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                      if (!sizeIsAffected && !_isBorderBox)
                          sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
                  }
                  if (checkX && !sizeIsAffected) {
                      sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                      if (!sizeIsAffected && !_isBorderBox)
                          sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
                  }
                  return sizeIsAffected;
              }


              //==== Update ====//

              /**
               * Sets the attribute values of the viewport element to the values from the target element.
               * The value of a attribute is only set if the attribute is whitelisted.
               * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.
               */
              function updateViewportAttrsFromTarget(attrs) {
                  attrs = attrs || _viewportAttrsFromTarget;
                  each(attrs, function (index, attr) {
                      if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                          var targetAttr = _targetElement.attr(attr);
                          if (type(targetAttr) == TYPES.s) {
                              _viewportElement.attr(attr, targetAttr);
                          }
                          else {
                              _viewportElement.removeAttr(attr);
                          }
                      }
                  });
              }

              /**
               * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.
               */
              function textareaUpdate() {
                  if (!_sleeping) {
                      var wrapAttrOff = !_textareaAutoWrappingCache;
                      var minWidth = _viewportSize.w;
                      var minHeight = _viewportSize.h;
                      var css = {};
                      var doMeasure = _widthAutoCache || wrapAttrOff;
                      var origWidth;
                      var width;
                      var origHeight;
                      var height;

                      //reset min size
                      css[_strMinMinus + _strWidth] = _strEmpty;
                      css[_strMinMinus + _strHeight] = _strEmpty;

                      //set width auto
                      css[_strWidth] = _strAuto;
                      _targetElement.css(css);

                      //measure width
                      origWidth = _targetElementNative[LEXICON.oW];
                      width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                      /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/

                      //set measured width
                      css[_strWidth] = _widthAutoCache ? _strAuto /*width*/ : _strHundredPercent;
                      css[_strMinMinus + _strWidth] = _strHundredPercent;

                      //set height auto
                      css[_strHeight] = _strAuto;
                      _targetElement.css(css);

                      //measure height
                      origHeight = _targetElementNative[LEXICON.oH];
                      height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);

                      //append correct size values
                      css[_strWidth] = width;
                      css[_strHeight] = height;
                      _textareaCoverElement.css(css);

                      //apply min width / min height to prevent textarea collapsing
                      css[_strMinMinus + _strWidth] = minWidth /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/;
                      css[_strMinMinus + _strHeight] = minHeight /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/;
                      _targetElement.css(css);

                      return {
                          _originalWidth: origWidth,
                          _originalHeight: origHeight,
                          _dynamicWidth: width,
                          _dynamicHeight: height
                      };
                  }
              }

              /**
               * Updates the plugin and DOM to the current options.
               * This method should only be called if a update is 100% required.
               * @param updateHints A objects which contains hints for this update:
               * {
               *   _hostSizeChanged : boolean,
               *   _contentSizeChanged : boolean,
               *   _force : boolean,                             == preventSwallowing
               *   _changedOptions : { },                        == preventSwallowing && preventSleep
              *  }
               */
              function update(updateHints) {
                  clearTimeout(_swallowedUpdateTimeout);
                  updateHints = updateHints || {};
                  _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
                  _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
                  _swallowedUpdateHints._force |= updateHints._force;

                  var now = COMPATIBILITY.now();
                  var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
                  var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
                  var force = !!_swallowedUpdateHints._force;
                  var changedOptions = updateHints._changedOptions;
                  var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && (now - _lastUpdateTime) < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
                  var displayIsHidden;

                  if (swallow)
                      _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);

                  //abort update due to:
                  //destroyed
                  //swallowing
                  //sleeping
                  //host is hidden or has false display
                  if (_destroyed || swallow || (_sleeping && !changedOptions) || (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) || _hostElement.css('display') === 'inline')
                      return;

                  _lastUpdateTime = now;
                  _swallowedUpdateHints = {};

                  //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.
                  if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                      //native scrollbars are hidden, so change the values to zero
                      _nativeScrollbarSize.x = 0;
                      _nativeScrollbarSize.y = 0;
                  }
                  else {
                      //refresh native scrollbar size (in case of zoom)
                      _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                  }

                  // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.
                  // The calculation: [scrollbar size +3 *3]
                  // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)
                  // (*3 because (1)increase / (2)decrease -button and (3)resize handle)
                  _nativeScrollbarMinSize = {
                      x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                      y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
                  };

                  changedOptions = changedOptions || {};
                  //freezeResizeObserver(_sizeObserverElement, true);
                  //freezeResizeObserver(_sizeAutoObserverElement, true);

                  var checkCacheAutoForce = function () {
                      return checkCache.apply(this, [].slice.call(arguments).concat([force]));
                  };

                  //save current scroll offset
                  var currScroll = {
                      x: _viewportElement[_strScrollLeft](),
                      y: _viewportElement[_strScrollTop]()
                  };

                  var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
                  var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;

                  //scrollbars visibility:
                  var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
                  var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);

                  //scrollbars autoHide:
                  var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
                  var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);

                  //scrollbars click scrolling
                  var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
                  var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);

                  //scrollbars drag scrolling
                  var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
                  var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);

                  //className
                  var className = _currentPreparedOptions.className;
                  var classNameChanged = checkCacheAutoForce(className, _classNameCache);

                  //resize
                  var resize = _currentPreparedOptions.resize;
                  var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.

                  //paddingAbsolute
                  var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
                  var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);

                  //clipAlways
                  var clipAlways = _currentPreparedOptions.clipAlways;
                  var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);

                  //sizeAutoCapable
                  var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.
                  var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);

                  //showNativeScrollbars
                  var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
                  var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);

                  //autoUpdate
                  var autoUpdate = _currentPreparedOptions.autoUpdate;
                  var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);

                  //overflowBehavior
                  var overflowBehavior = _currentPreparedOptions.overflowBehavior;
                  var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);

                  //dynWidth:
                  var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
                  var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);

                  //dynHeight:
                  var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
                  var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);

                  //scrollbars visibility
                  _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';
                  _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';
                  _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';
                  _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l';

                  //scrollbars autoHideDelay
                  _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;

                  //old className
                  _oldClassName = _classNameCache;

                  //resize
                  _resizeNone = resize === 'n';
                  _resizeBoth = resize === 'b';
                  _resizeHorizontal = resize === 'h';
                  _resizeVertical = resize === 'v';

                  //normalizeRTL
                  _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;

                  //ignore overlay scrollbar hiding
                  ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);

                  //refresh options cache
                  _scrollbarsVisibilityCache = scrollbarsVisibility;
                  _scrollbarsAutoHideCache = scrollbarsAutoHide;
                  _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
                  _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
                  _classNameCache = className;
                  _resizeCache = resize;
                  _paddingAbsoluteCache = paddingAbsolute;
                  _clipAlwaysCache = clipAlways;
                  _sizeAutoCapableCache = sizeAutoCapable;
                  _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
                  _autoUpdateCache = autoUpdate;
                  _overflowBehaviorCache = extendDeep({}, overflowBehavior);
                  _textareaDynWidthCache = textareaDynWidth;
                  _textareaDynHeightCache = textareaDynHeight;
                  _hasOverflowCache = _hasOverflowCache || { x: false, y: false };

                  //set correct class name to the host element
                  if (classNameChanged) {
                      removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                      addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);
                  }

                  //set correct auto Update
                  if (autoUpdateChanged) {
                      if (autoUpdate === true || (autoUpdate === null && _autoUpdateRecommended)) {
                          disconnectMutationObservers();
                          autoUpdateLoop.add(_base);
                      }
                      else {
                          autoUpdateLoop.remove(_base);
                          connectMutationObservers();
                      }
                  }

                  //activate or deactivate size auto capability
                  if (sizeAutoCapableChanged) {
                      if (sizeAutoCapable) {
                          if (_contentGlueElement) {
                              _contentGlueElement.show();
                          }
                          else {
                              _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                              _paddingElement.before(_contentGlueElement);
                          }
                          if (_sizeAutoObserverAdded) {
                              _sizeAutoObserverElement.show();
                          }
                          else {
                              _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                              _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];

                              _contentGlueElement.before(_sizeAutoObserverElement);
                              var oldSize = { w: -1, h: -1 };
                              setupResizeObserver(_sizeAutoObserverElement, function () {
                                  var newSize = {
                                      w: _sizeAutoObserverElementNative[LEXICON.oW],
                                      h: _sizeAutoObserverElementNative[LEXICON.oH]
                                  };
                                  if (checkCache(newSize, oldSize)) {
                                      if (_initialized && (_heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {
                                          update();
                                      }
                                      else if (_initialized && (!_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {
                                          update();
                                      }
                                  }
                                  oldSize = newSize;
                              });
                              _sizeAutoObserverAdded = true;
                              //fix heightAuto detector bug if height is fixed but contentHeight is 0.
                              //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.
                              if (_cssCalc !== null)
                                  _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');
                          }
                      }
                      else {
                          if (_sizeAutoObserverAdded)
                              _sizeAutoObserverElement.hide();
                          if (_contentGlueElement)
                              _contentGlueElement.hide();
                      }
                  }

                  //if force, update all resizeObservers too
                  if (force) {
                      _sizeObserverElement.find('*').trigger(_strScroll);
                      if (_sizeAutoObserverAdded)
                          _sizeAutoObserverElement.find('*').trigger(_strScroll);
                  }

                  //display hidden:
                  displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;

                  //textarea AutoWrapping:
                  var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;
                  var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);

                  //detect direction:
                  var cssDirection = _hostElement.css('direction');
                  var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);

                  //detect box-sizing:
                  var boxSizing = _hostElement.css('box-sizing');
                  var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);

                  //detect padding:
                  var padding = getTopRightBottomLeftHost(_strPaddingMinus);

                  //width + height auto detecting var:
                  var sizeAutoObserverElementBCRect;
                  //exception occurs in IE8 sometimes (unknown exception)
                  try {
                      sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
                  } catch (ex) {
                      return;
                  }

                  _isRTL = cssDirection === 'rtl';
                  _isBorderBox = (boxSizing === 'border-box');
                  var isRTLLeft = _isRTL ? _strLeft : _strRight;
                  var isRTLRight = _isRTL ? _strRight : _strLeft;

                  //detect width auto:
                  var widthAutoResizeDetection = false;
                  var widthAutoObserverDetection = (_sizeAutoObserverAdded && (_hostElement.css(_strFloat) !== 'none' /*|| _isTextarea */)) ? (MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0) && (!paddingAbsolute ? (_hostElementNative[LEXICON.cW] - _paddingX) > 0 : true) : false;
                  if (sizeAutoCapable && !widthAutoObserverDetection) {
                      var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
                      var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                      _contentGlueElement.css(_strWidth, _strAuto);

                      var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                      _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                      widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                      if (!widthAutoResizeDetection) {
                          _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
                          tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                          _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                          widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                      }
                  }
                  var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
                  var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
                  var wasWidthAuto = !widthAuto && _widthAutoCache;

                  //detect height auto:
                  var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? (MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0) /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */ : false;
                  var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
                  var wasHeightAuto = !heightAuto && _heightAutoCache;

                  //detect border:
                  //we need the border only if border box and auto size
                  var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;
                  var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;
                  var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY)

                  //detect margin:
                  var margin = getTopRightBottomLeftHost(_strMarginMinus);

                  //vars to apply correct css
                  var contentElementCSS = {};
                  var contentGlueElementCSS = {};

                  //funcs
                  var getHostSize = function () {
                      //has to be clientSize because offsetSize respect borders
                      return {
                          w: _hostElementNative[LEXICON.cW],
                          h: _hostElementNative[LEXICON.cH]
                      };
                  };
                  var getViewportSize = function () {
                      //viewport size is padding container because it never has padding, margin and a border
                      //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height
                      //if this happens add the difference to the viewportSize to compensate the rounding error
                      return {
                          w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                          h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                      };
                  };

                  //set info for padding
                  var paddingAbsoluteX = _paddingX = padding.l + padding.r;
                  var paddingAbsoluteY = _paddingY = padding.t + padding.b;
                  paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
                  paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
                  padding.c = checkCacheAutoForce(padding, _cssPaddingCache);

                  //set info for border
                  _borderX = border.l + border.r;
                  _borderY = border.t + border.b;
                  border.c = checkCacheAutoForce(border, _cssBorderCache);

                  //set info for margin
                  _marginX = margin.l + margin.r;
                  _marginY = margin.t + margin.b;
                  margin.c = checkCacheAutoForce(margin, _cssMarginCache);

                  //refresh cache
                  _textareaAutoWrappingCache = textareaAutoWrapping;
                  _cssDirectionCache = cssDirection;
                  _cssBoxSizingCache = boxSizing;
                  _widthAutoCache = widthAuto;
                  _heightAutoCache = heightAuto;
                  _cssPaddingCache = padding;
                  _cssBorderCache = border;
                  _cssMarginCache = margin;

                  //IEFix direction changed
                  if (cssDirectionChanged && _sizeAutoObserverAdded)
                      _sizeAutoObserverElement.css(_strFloat, isRTLRight);

                  //apply padding:
                  if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                      var paddingElementCSS = {};
                      var textareaCSS = {};
                      var paddingValues = [padding.t, padding.r, padding.b, padding.l];

                      setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
                      if (paddingAbsolute) {
                          setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
                          setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
                      }
                      else {
                          setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                          setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
                      }

                      _paddingElement.css(paddingElementCSS);
                      _targetElement.css(textareaCSS);
                  }

                  //viewport size is padding container because it never has padding, margin and a border.
                  _viewportSize = getViewportSize();

                  //update Textarea
                  var textareaSize = _isTextarea ? textareaUpdate() : false;
                  var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
                  var textareaDynOrigSize = _isTextarea && textareaSize ? {
                      w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                      h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
                  } : {};
                  _textareaSizeCache = textareaSize;

                  //fix height auto / width auto in cooperation with current padding & boxSizing behavior:
                  if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
                      contentElementCSS[_strHeight] = _strAuto;
                  }
                  else if (heightAutoChanged || paddingAbsoluteChanged) {
                      contentElementCSS[_strHeight] = _strHundredPercent;
                  }
                  if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
                      contentElementCSS[_strWidth] = _strAuto;
                      contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix
                  }
                  else if (widthAutoChanged || paddingAbsoluteChanged) {
                      contentElementCSS[_strWidth] = _strHundredPercent;
                      contentElementCSS[_strFloat] = _strEmpty;
                      contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix
                  }
                  if (widthAuto) {
                      //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width
                      contentGlueElementCSS[_strWidth] = _strAuto;

                      contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;
                      contentElementCSS[_strFloat] = isRTLRight;
                  }
                  else {
                      contentGlueElementCSS[_strWidth] = _strEmpty;
                  }
                  if (heightAuto) {
                      //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping
                      contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
                  }
                  else {
                      contentGlueElementCSS[_strHeight] = _strEmpty;
                  }
                  if (sizeAutoCapable)
                      _contentGlueElement.css(contentGlueElementCSS);
                  _contentElement.css(contentElementCSS);

                  //CHECKPOINT HERE ~
                  contentElementCSS = {};
                  contentGlueElementCSS = {};

                  //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true
                  if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                      var strOverflow = 'overflow';
                      var strOverflowX = strOverflow + '-x';
                      var strOverflowY = strOverflow + '-y';
                      var strHidden = 'hidden';
                      var strVisible = 'visible';

                      //Reset the viewport (very important for natively overlaid scrollbars and zoom change
                      //don't change the overflow prop as it is very expensive and affects performance !A LOT!
                      if (!_nativeScrollbarStyling) {
                          var viewportElementResetCSS = {};
                          var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;
                          var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;
                          setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
                          _viewportElement.css(viewportElementResetCSS);
                      }

                      //measure several sizes:
                      var contentMeasureElement = getContentMeasureElement();
                      //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid
                      var contentSize = {
                          //use clientSize because natively overlaidScrollbars add borders
                          w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                          h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                      };
                      var scrollSize = {
                          w: contentMeasureElement[LEXICON.sW],
                          h: contentMeasureElement[LEXICON.sH]
                      };

                      //apply the correct viewport style and measure viewport size
                      if (!_nativeScrollbarStyling) {
                          viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                          viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
                          _viewportElement.css(viewportElementResetCSS);
                      }
                      _viewportSize = getViewportSize();

                      //measure and correct several sizes
                      var hostSize = getHostSize();
                      var hostAbsoluteRectSize = {
                          w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
                          h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
                      };
                      var contentGlueSize = {
                          //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                          //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                          w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
                          h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
                      };
                      contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                      _contentGlueSizeCache = contentGlueSize;

                      //apply correct contentGlue size
                      if (sizeAutoCapable) {
                          //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto
                          if (contentGlueSize.c || (heightAuto || widthAuto)) {
                              contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                              contentGlueElementCSS[_strHeight] = contentGlueSize.h;

                              //textarea-sizes are already calculated correctly at this point
                              if (!_isTextarea) {
                                  contentSize = {
                                      //use clientSize because natively overlaidScrollbars add borders
                                      w: contentMeasureElement[LEXICON.cW],
                                      h: contentMeasureElement[LEXICON.cH]
                                  };
                              }
                          }
                          var textareaCoverCSS = {};
                          var setContentGlueElementCSSfunction = function (horizontal) {
                              var scrollbarVars = getScrollbarVars(horizontal);
                              var wh = scrollbarVars._w_h;
                              var strWH = scrollbarVars._width_height;
                              var autoSize = horizontal ? widthAuto : heightAuto;
                              var borderSize = horizontal ? _borderX : _borderY;
                              var paddingSize = horizontal ? _paddingX : _paddingY;
                              var marginSize = horizontal ? _marginX : _marginY;
                              var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);

                              //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks
                              if (!autoSize || (!autoSize && border.c))
                                  contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;

                              //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)
                              if (autoSize && (contentSize[wh] < viewportSize) && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                                  if (_isTextarea)
                                      textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                                  contentGlueElementCSS[strWH] -= 1;
                              }

                              //make sure content glue size is at least 1
                              if (contentSize[wh] > 0)
                                  contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                          };
                          setContentGlueElementCSSfunction(true);
                          setContentGlueElementCSSfunction(false);

                          if (_isTextarea)
                              _textareaCoverElement.css(textareaCoverCSS);
                          _contentGlueElement.css(contentGlueElementCSS);
                      }
                      if (widthAuto)
                          contentElementCSS[_strWidth] = _strHundredPercent;
                      if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
                          contentElementCSS[_strFloat] = 'none';

                      //apply and reset content style
                      _contentElement.css(contentElementCSS);
                      contentElementCSS = {};

                      //measure again, but this time all correct sizes:
                      var contentScrollSize = {
                          w: contentMeasureElement[LEXICON.sW],
                          h: contentMeasureElement[LEXICON.sH],
                      };
                      contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                      _contentScrollSizeCache = contentScrollSize;

                      //refresh viewport size after correct measuring
                      _viewportSize = getViewportSize();

                      hostSize = getHostSize();
                      hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                      _hostSizeCache = hostSize;

                      var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                      var previousOverflowAmount = _overflowAmountCache;
                      var overflowBehaviorIsVS = {};
                      var overflowBehaviorIsVH = {};
                      var overflowBehaviorIsS = {};
                      var overflowAmount = {};
                      var hasOverflow = {};
                      var hideOverflow = {};
                      var canScroll = {};
                      var viewportRect = _paddingElementNative[LEXICON.bCR]();
                      var setOverflowVariables = function (horizontal) {
                          var scrollbarVars = getScrollbarVars(horizontal);
                          var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                          var xyI = scrollbarVarsInverted._x_y;
                          var xy = scrollbarVars._x_y;
                          var wh = scrollbarVars._w_h;
                          var widthHeight = scrollbarVars._width_height;
                          var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';
                          var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                          var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                          overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';
                          overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';
                          overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';
                          overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                          overflowAmount[xy] *= (hideOverflowForceTextarea || (checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1)) ? 0 : 1;
                          hasOverflow[xy] = overflowAmount[xy] > 0;

                          //hideOverflow:
                          //x || y : true === overflow is hidden by "overflow: scroll" OR "overflow: hidden"
                          //xs || ys : true === overflow is hidden by "overflow: scroll"
                          hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? (hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI]) : hasOverflow[xy];
                          hideOverflow[xy + 's'] = hideOverflow[xy] ? (overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy]) : false;

                          canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];
                      };
                      setOverflowVariables(true);
                      setOverflowVariables(false);

                      overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                      _overflowAmountCache = overflowAmount;
                      hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                      _hasOverflowCache = hasOverflow;
                      hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                      _hideOverflowCache = hideOverflow;

                      //if native scrollbar is overlay at x OR y axis, prepare DOM
                      if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                          var borderDesign = 'px solid transparent';
                          var contentArrangeElementCSS = {};
                          var arrangeContent = {};
                          var arrangeChanged = force;
                          var setContentElementCSS;

                          if (hasOverflow.x || hasOverflow.y) {
                              arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                              arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                              arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                              _arrangeContentSizeCache = arrangeContent;
                          }

                          if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                              contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                              setContentElementCSS = function (horizontal) {
                                  var scrollbarVars = getScrollbarVars(horizontal);
                                  var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                  var xy = scrollbarVars._x_y;
                                  var strDirection = horizontal ? _strBottom : isRTLLeft;
                                  var invertedAutoSize = horizontal ? heightAuto : widthAuto;

                                  if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {
                                      contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? (ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy]) : _strEmpty;
                                      contentElementCSS[_strBorderMinus + strDirection] = ((horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding) ? (_overlayScrollbarDummySize[xy] + borderDesign) : _strEmpty;
                                  }
                                  else {
                                      arrangeContent[scrollbarVarsInverted._w_h] =
                                          contentElementCSS[_strMarginMinus + strDirection] =
                                          contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                                      arrangeChanged = true;
                                  }
                              };

                              if (_nativeScrollbarStyling) {
                                  addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding)
                              }
                              else {
                                  setContentElementCSS(true);
                                  setContentElementCSS(false);
                              }
                          }
                          if (ignoreOverlayScrollbarHiding) {
                              arrangeContent.w = arrangeContent.h = _strEmpty;
                              arrangeChanged = true;
                          }
                          if (arrangeChanged && !_nativeScrollbarStyling) {
                              contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                              contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;

                              if (!_contentArrangeElement) {
                                  _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                                  _viewportElement.prepend(_contentArrangeElement);
                              }
                              _contentArrangeElement.css(contentArrangeElementCSS);
                          }
                          _contentElement.css(contentElementCSS);
                      }

                      var viewportElementCSS = {};
                      var paddingElementCSS = {};
                      var setViewportCSS;
                      if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
                          viewportElementCSS[isRTLRight] = _strEmpty;
                          setViewportCSS = function (horizontal) {
                              var scrollbarVars = getScrollbarVars(horizontal);
                              var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                              var xy = scrollbarVars._x_y;
                              var XY = scrollbarVars._X_Y;
                              var strDirection = horizontal ? _strBottom : isRTLLeft;

                              var reset = function () {
                                  viewportElementCSS[strDirection] = _strEmpty;
                                  _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                              };
                              if (hasOverflow[xy] && hideOverflow[xy + 's']) {
                                  viewportElementCSS[strOverflow + XY] = _strScroll;
                                  if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                                      reset();
                                  }
                                  else {
                                      viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                                      _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                                  }
                              } else {
                                  viewportElementCSS[strOverflow + XY] = _strEmpty;
                                  reset();
                              }
                          };
                          setViewportCSS(true);
                          setViewportCSS(false);

                          // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible), 
                          // make viewport element greater in size (Firefox hide Scrollbars fix)
                          // because firefox starts hiding scrollbars on too small elements
                          // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly
                          // https://bugzilla.mozilla.org/show_bug.cgi?id=292284
                          if (!_nativeScrollbarStyling
                              && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y)
                              && ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))) {
                              viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                              viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;

                              viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                              viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                          }
                          else {
                              viewportElementCSS[_strPaddingMinus + _strTop] =
                                  viewportElementCSS[_strMarginMinus + _strTop] =
                                  viewportElementCSS[_strPaddingMinus + isRTLRight] =
                                  viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                          }
                          viewportElementCSS[_strPaddingMinus + isRTLLeft] =
                              viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;

                          //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible
                          if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {
                              //only hide if is Textarea
                              if (_isTextarea && hideOverflowForceTextarea) {
                                  paddingElementCSS[strOverflowX] =
                                      paddingElementCSS[strOverflowY] = strHidden;
                              }
                          }
                          else {
                              if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                                  //only un-hide if Textarea
                                  if (_isTextarea) {
                                      paddingElementCSS[strOverflowX] =
                                          paddingElementCSS[strOverflowY] = _strEmpty;
                                  }
                                  viewportElementCSS[strOverflowX] =
                                      viewportElementCSS[strOverflowY] = strVisible;
                              }
                          }

                          _paddingElement.css(paddingElementCSS);
                          _viewportElement.css(viewportElementCSS);
                          viewportElementCSS = {};

                          //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions
                          if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                              var elementStyle = _contentElementNative[LEXICON.s];
                              var dump;
                              elementStyle.webkitTransform = 'scale(1)';
                              elementStyle.display = 'run-in';
                              dump = _contentElementNative[LEXICON.oH];
                              elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify
                              elementStyle.webkitTransform = _strEmpty;
                          }
                          /*
                          //force hard redraw in webkit if native overlaid scrollbars shall appear
                          if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {
                              _hostElement.hide();
                              var dump = _hostElementNative[LEXICON.oH];
                              _hostElement.show();
                          }
                          */
                      }

                      //change to direction RTL and width auto Bugfix in Webkit
                      //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left
                      contentElementCSS = {};
                      if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                          if (_isRTL && widthAuto) {
                              var floatTmp = _contentElement.css(_strFloat);
                              var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                              _contentElement.css(_strFloat, floatTmp);
                              var posLeftWithFloat = MATH.round(_contentElement.position().left);

                              if (posLeftWithoutFloat !== posLeftWithFloat)
                                  contentElementCSS[_strLeft] = posLeftWithoutFloat;
                          }
                          else {
                              contentElementCSS[_strLeft] = _strEmpty;
                          }
                      }
                      _contentElement.css(contentElementCSS);

                      //handle scroll position
                      if (_isTextarea && contentSizeChanged) {
                          var textareaInfo = getTextareaInfo();
                          if (textareaInfo) {
                              var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                              var cursorRow = textareaInfo._cursorRow;
                              var cursorCol = textareaInfo._cursorColumn;
                              var widestRow = textareaInfo._widestRow;
                              var lastRow = textareaInfo._rows;
                              var lastCol = textareaInfo._columns;
                              var cursorPos = textareaInfo._cursorPosition;
                              var cursorMax = textareaInfo._cursorMax;
                              var cursorIsLastPosition = (cursorPos >= cursorMax && _textareaHasFocus);
                              var textareaScrollAmount = {
                                  x: (!textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow)) ? _overflowAmountCache.x : -1,
                                  y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? (currScroll.y === previousOverflowAmount.y) : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                              };
                              currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.
                              currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                          }
                          _textareaInfoCache = textareaInfo;
                      }
                      if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
                          currScroll.x += _contentBorderSize.w || 0;
                      if (widthAuto)
                          _hostElement[_strScrollLeft](0);
                      if (heightAuto)
                          _hostElement[_strScrollTop](0);
                      _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);

                      //scrollbars management:
                      var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';
                      var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';
                      var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';
                      var refreshScrollbarsVisibility = function (showX, showY) {
                          showY = showY === undefined ? showX : showY;
                          refreshScrollbarAppearance(true, showX, canScroll.x)
                          refreshScrollbarAppearance(false, showY, canScroll.y)
                      };

                      //manage class name which indicates scrollable overflow
                      addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
                      addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
                      addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);

                      //add or remove rtl class name for styling purposes except when its body, then the scrollbar stays
                      if (cssDirectionChanged && !_isBody) {
                          addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
                      }

                      //manage the resize feature (CSS3 resize "polyfill" for this plugin)
                      if (_isBody)
                          addClass(_hostElement, _classNameHostResizeDisabled);
                      if (resizeChanged) {
                          addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
                          addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
                          addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
                          addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
                          addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
                      }

                      //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)
                      if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                          if (ignoreOverlayScrollbarHiding) {
                              if (ignoreOverlayScrollbarHidingChanged) {
                                  removeClass(_hostElement, _classNameHostScrolling);
                                  if (ignoreOverlayScrollbarHiding) {
                                      refreshScrollbarsVisibility(false);
                                  }
                              }
                          }
                          else if (scrollbarsVisibilityAuto) {
                              refreshScrollbarsVisibility(canScroll.x, canScroll.y);
                          }
                          else if (scrollbarsVisibilityVisible) {
                              refreshScrollbarsVisibility(true);
                          }
                          else if (scrollbarsVisibilityHidden) {
                              refreshScrollbarsVisibility(false);
                          }
                      }

                      //manage the scrollbars auto hide feature (auto hide them after specific actions)
                      if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                          setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
                          refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
                      }

                      //manage scrollbars handle length & offset - don't remove!
                      if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
                          refreshScrollbarHandleLength(true);
                          refreshScrollbarHandleOffset(true);
                          refreshScrollbarHandleLength(false);
                          refreshScrollbarHandleOffset(false);
                      }

                      //manage interactivity
                      if (scrollbarsClickScrollingChanged)
                          refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                      if (scrollbarsDragScrollingChanged)
                          refreshScrollbarsInteractive(false, scrollbarsDragScrolling);

                      //callbacks:
                      dispatchCallback('onDirectionChanged', {
                          isRTL: _isRTL,
                          dir: cssDirection
                      }, cssDirectionChanged);
                      dispatchCallback('onHostSizeChanged', {
                          width: _hostSizeCache.w,
                          height: _hostSizeCache.h
                      }, hostSizeChanged);
                      dispatchCallback('onContentSizeChanged', {
                          width: _contentScrollSizeCache.w,
                          height: _contentScrollSizeCache.h
                      }, contentSizeChanged);
                      dispatchCallback('onOverflowChanged', {
                          x: hasOverflow.x,
                          y: hasOverflow.y,
                          xScrollable: hideOverflow.xs,
                          yScrollable: hideOverflow.ys,
                          clipped: hideOverflow.x || hideOverflow.y
                      }, hasOverflow.c || hideOverflow.c);
                      dispatchCallback('onOverflowAmountChanged', {
                          x: overflowAmount.x,
                          y: overflowAmount.y
                      }, overflowAmount.c);
                  }

                  //fix body min size
                  if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                      //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.
                      if (!_bodyMinSizeCache.f)
                          bodyMinSizeChanged();
                      if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
                          _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                      if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
                          _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                      _bodyMinSizeCache.c = false;
                  }

                  if (_initialized && changedOptions.updateOnLoad) {
                      updateElementsOnLoad();
                  }

                  //freezeResizeObserver(_sizeObserverElement, false);
                  //freezeResizeObserver(_sizeAutoObserverElement, false);

                  dispatchCallback('onUpdated', { forced: force });
              }

              /**
               * Updates the found elements of which the load event shall be handled.
               */
              function updateElementsOnLoad() {
                  if (!_isTextarea) {
                      eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                          _contentElement.find(updateOnLoadSelector).each(function (i, el) {
                              // if element doesn't have a updateOnLoadCallback applied
                              if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                                  _updateOnLoadElms.push(el);
                                  FRAMEWORK(el)
                                      .off(_updateOnLoadEventName, updateOnLoadCallback)
                                      .on(_updateOnLoadEventName, updateOnLoadCallback);
                              }
                          });
                      });
                  }
              }

              //==== Options ====//

              /**
               * Sets new options but doesn't call the update method.
               * @param newOptions The object which contains the new options.
               * @returns {*} A object which contains the changed options.
               */
              function setOptions(newOptions) {
                  var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions)

                  _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
                  _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);

                  return validatedOpts._prepared;
              }


              //==== Structure ====//

              /**
               * Builds or destroys the wrapper and helper DOM elements.
               * @param destroy Indicates whether the DOM shall be build or destroyed.
               */
              /**
               * Builds or destroys the wrapper and helper DOM elements.
               * @param destroy Indicates whether the DOM shall be build or destroyed.
               */
              function setupStructureDOM(destroy) {
                  var strParent = 'parent';
                  var classNameResizeObserverHost = 'os-resize-observer-host';
                  var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
                  var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
                  var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
                  var adoptAttrsMap = {};
                  var applyAdoptedAttrs = function () {
                      var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                      each(adoptAttrsMap, function (key, value) {
                          if (type(value) == TYPES.s) {
                              if (key == LEXICON.c)
                                  applyAdoptedAttrsElm.addClass(value);
                              else
                                  applyAdoptedAttrsElm.attr(key, value);
                          }
                      });
                  };
                  var hostElementClassNames = [
                      _classNameHostElement,
                      _classNameHostElementForeign,
                      _classNameHostTextareaElement,
                      _classNameHostResizeDisabled,
                      _classNameHostRTL,
                      _classNameHostScrollbarHorizontalHidden,
                      _classNameHostScrollbarVerticalHidden,
                      _classNameHostTransition,
                      _classNameHostScrolling,
                      _classNameHostOverflow,
                      _classNameHostOverflowX,
                      _classNameHostOverflowY,
                      _classNameThemeNone,
                      _classNameTextareaElement,
                      _classNameTextInherit,
                      _classNameCache].join(_strSpace);
                  var hostElementCSS = {};

                  //get host element as first element, because that's the most upper element and required for the other elements
                  _hostElement = _hostElement || (_isTextarea ? (_domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement))) : _targetElement);
                  _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
                  _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
                  _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
                  _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
                  _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined);

                  //add this class to workaround class changing issues with UI frameworks especially Vue
                  if (_domExists)
                      addClass(_hostElement, _classNameHostElementForeign);

                  //on destroy, remove all generated class names from the host element before collecting the adopted attributes 
                  //to prevent adopting generated class names
                  if (destroy)
                      removeClass(_hostElement, hostElementClassNames);

                  //collect all adopted attributes
                  adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
                  if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
                      each(adoptAttrs, function (i, v) {
                          if (type(v) == TYPES.s) {
                              adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                          }
                      });
                  }

                  if (!destroy) {
                      if (_isTextarea) {
                          if (!_currentPreparedOptions.sizeAutoCapable) {
                              hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                              hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                          }

                          if (!_domExists)
                              _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);

                          //jQuery clones elements in wrap functions, so we have to select them again
                          _hostElement = _targetElement[strParent]().css(hostElementCSS);
                      }

                      if (!_domExists) {
                          //add the correct class to the target element
                          addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);

                          //wrap the content into the generated elements to create the required DOM
                          _hostElement.wrapInner(_contentElement)
                              .wrapInner(_viewportElement)
                              .wrapInner(_paddingElement)
                              .prepend(_sizeObserverElement);

                          //jQuery clones elements in wrap functions, so we have to select them again
                          _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                          _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                          _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);

                          if (_isTextarea) {
                              _contentElement.prepend(_textareaCoverElement);
                              applyAdoptedAttrs();
                          }
                      }

                      if (_nativeScrollbarStyling)
                          addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                      if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
                          addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                      if (_isBody)
                          addClass(_htmlElement, _classNameHTMLElement);

                      _sizeObserverElementNative = _sizeObserverElement[0];
                      _hostElementNative = _hostElement[0];
                      _paddingElementNative = _paddingElement[0];
                      _viewportElementNative = _viewportElement[0];
                      _contentElementNative = _contentElement[0];

                      updateViewportAttrsFromTarget();
                  }
                  else {
                      if (_domExists && _initialized) {
                          //clear size observer
                          _sizeObserverElement.children().remove();

                          //remove the style property and classes from already generated elements
                          each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {
                              if (elm) {
                                  removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                              }
                          });

                          //add classes to the host element which was removed previously to match the expected DOM
                          addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                      }
                      else {
                          //remove size observer
                          remove(_sizeObserverElement);

                          //unwrap the content to restore DOM
                          _contentElement.contents()
                              .unwrap()
                              .unwrap()
                              .unwrap();

                          if (_isTextarea) {
                              _targetElement.unwrap();
                              remove(_hostElement);
                              remove(_textareaCoverElement);
                              applyAdoptedAttrs();
                          }
                      }

                      if (_isTextarea)
                          _targetElement.removeAttr(LEXICON.s);

                      if (_isBody)
                          removeClass(_htmlElement, _classNameHTMLElement);
                  }
              }

              /**
               * Adds or removes all wrapper elements interactivity events.
               * @param destroy Indicates whether the Events shall be added or removed.
               */
              function setupStructureEvents() {
                  var textareaKeyDownRestrictedKeyCodes = [
                      112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,    //F1 to F12
                      33, 34,                                                   //page up, page down
                      37, 38, 39, 40,                                           //left, up, right, down arrows
                      16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
                  ];
                  var textareaKeyDownKeyCodesList = [];
                  var textareaUpdateIntervalID;
                  var scrollStopTimeoutId;
                  var scrollStopDelay = 175;
                  var strFocus = 'focus';

                  function updateTextarea(doClearInterval) {
                      textareaUpdate();
                      _base.update(_strAuto);
                      if (doClearInterval && _autoUpdateRecommended)
                          clearInterval(textareaUpdateIntervalID);
                  }
                  function textareaOnScroll(event) {
                      _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
                      _targetElement[_strScrollTop](0);
                      COMPATIBILITY.prvD(event);
                      COMPATIBILITY.stpP(event);
                      return false;
                  }
                  function textareaOnDrop(event) {
                      setTimeout(function () {
                          if (!_destroyed)
                              updateTextarea();
                      }, 50);
                  }
                  function textareaOnFocus() {
                      _textareaHasFocus = true;
                      addClass(_hostElement, strFocus);
                  }
                  function textareaOnFocusout() {
                      _textareaHasFocus = false;
                      textareaKeyDownKeyCodesList = [];
                      removeClass(_hostElement, strFocus);
                      updateTextarea(true);
                  }
                  function textareaOnKeyDown(event) {
                      var keyCode = event.keyCode;

                      if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                          if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                              updateTextarea();
                              textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);
                          }
                          if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                              textareaKeyDownKeyCodesList.push(keyCode);
                      }
                  }
                  function textareaOnKeyUp(event) {
                      var keyCode = event.keyCode;
                      var index = inArray(keyCode, textareaKeyDownKeyCodesList);

                      if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                          if (index > -1)
                              textareaKeyDownKeyCodesList.splice(index, 1);
                          if (!textareaKeyDownKeyCodesList[LEXICON.l])
                              updateTextarea(true);
                      }
                  }
                  function contentOnTransitionEnd(event) {
                      if (_autoUpdateCache === true)
                          return;
                      event = event.originalEvent || event;
                      if (isSizeAffectingCSSProperty(event.propertyName))
                          _base.update(_strAuto);
                  }
                  function viewportOnScroll(event) {
                      if (!_sleeping) {
                          if (scrollStopTimeoutId !== undefined)
                              clearTimeout(scrollStopTimeoutId);
                          else {
                              if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                  refreshScrollbarsAutoHide(true);

                              if (!nativeOverlayScrollbarsAreActive())
                                  addClass(_hostElement, _classNameHostScrolling);

                              dispatchCallback('onScrollStart', event);
                          }

                          //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset
                          //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point
                          //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove
                          if (!_scrollbarsHandlesDefineScrollPos) {
                              refreshScrollbarHandleOffset(true);
                              refreshScrollbarHandleOffset(false);
                          }
                          dispatchCallback('onScroll', event);

                          scrollStopTimeoutId = setTimeout(function () {
                              if (!_destroyed) {
                                  //OnScrollStop:
                                  clearTimeout(scrollStopTimeoutId);
                                  scrollStopTimeoutId = undefined;

                                  if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                      refreshScrollbarsAutoHide(false);

                                  if (!nativeOverlayScrollbarsAreActive())
                                      removeClass(_hostElement, _classNameHostScrolling);

                                  dispatchCallback('onScrollStop', event);
                              }
                          }, scrollStopDelay);
                      }
                  }


                  if (_isTextarea) {
                      if (_msieVersion > 9 || !_autoUpdateRecommended) {
                          addDestroyEventListener(_targetElement, 'input', updateTextarea);
                      }
                      else {
                          addDestroyEventListener(_targetElement,
                              [_strKeyDownEvent, _strKeyUpEvent],
                              [textareaOnKeyDown, textareaOnKeyUp]);
                      }

                      addDestroyEventListener(_targetElement,
                          [_strScroll, 'drop', strFocus, strFocus + 'out'],
                          [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);
                  }
                  else {
                      addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
                  }
                  addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
              }


              //==== Scrollbars ====//

              /**
               * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)
               * @param destroy Indicates whether the DOM shall be build or destroyed.
               */
              function setupScrollbarsDOM(destroy) {
                  var selectOrGenerateScrollbarDOM = function (isHorizontal) {
                      var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                      var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                      var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                      var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);

                      if (!_domExists && !destroy) {
                          scrollbar.append(track);
                          track.append(handle);
                      }

                      return {
                          _scrollbar: scrollbar,
                          _track: track,
                          _handle: handle
                      };
                  };
                  function resetScrollbarDOM(isHorizontal) {
                      var scrollbarVars = getScrollbarVars(isHorizontal);
                      var scrollbar = scrollbarVars._scrollbar;
                      var track = scrollbarVars._track;
                      var handle = scrollbarVars._handle;

                      if (_domExists && _initialized) {
                          each([scrollbar, track, handle], function (i, elm) {
                              removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                          });
                      }
                      else {
                          remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                      }
                  }
                  var horizontalElements;
                  var verticalElements;

                  if (!destroy) {
                      horizontalElements = selectOrGenerateScrollbarDOM(true);
                      verticalElements = selectOrGenerateScrollbarDOM();

                      _scrollbarHorizontalElement = horizontalElements._scrollbar;
                      _scrollbarHorizontalTrackElement = horizontalElements._track;
                      _scrollbarHorizontalHandleElement = horizontalElements._handle;
                      _scrollbarVerticalElement = verticalElements._scrollbar;
                      _scrollbarVerticalTrackElement = verticalElements._track;
                      _scrollbarVerticalHandleElement = verticalElements._handle;

                      if (!_domExists) {
                          _paddingElement.after(_scrollbarVerticalElement);
                          _paddingElement.after(_scrollbarHorizontalElement);
                      }
                  }
                  else {
                      resetScrollbarDOM(true);
                      resetScrollbarDOM();
                  }
              }

              /**
               * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)
               * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.
               */
              function setupScrollbarEvents(isHorizontal) {
                  var scrollbarVars = getScrollbarVars(isHorizontal);
                  var scrollbarVarsInfo = scrollbarVars._info;
                  var insideIFrame = _windowElementNative.top !== _windowElementNative;
                  var xy = scrollbarVars._x_y;
                  var XY = scrollbarVars._X_Y;
                  var scroll = _strScroll + scrollbarVars._Left_Top;
                  var strActive = 'active';
                  var strSnapHandle = 'snapHandle';
                  var strClickEvent = 'click';
                  var scrollDurationFactor = 1;
                  var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl
                  var trackTimeout;
                  var mouseDownScroll;
                  var mouseDownOffset;
                  var mouseDownInvertedScale;

                  function getPointerPosition(event) {
                      return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.
                  }
                  function getPreparedScrollbarsOption(name) {
                      return _currentPreparedOptions.scrollbars[name];
                  }
                  function increaseTrackScrollAmount() {
                      scrollDurationFactor = 0.5;
                  }
                  function decreaseTrackScrollAmount() {
                      scrollDurationFactor = 1;
                  }
                  function stopClickEventPropagation(event) {
                      COMPATIBILITY.stpP(event);
                  }
                  function documentKeyDown(event) {
                      if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                          increaseTrackScrollAmount();
                  }
                  function documentKeyUp(event) {
                      if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                          decreaseTrackScrollAmount();
                  }
                  function onMouseTouchDownContinue(event) {
                      var originalEvent = event.originalEvent || event;
                      var isTouchEvent = originalEvent.touches !== undefined;
                      return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || (isTouchEvent && !getPreparedScrollbarsOption('touchSupport')) ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                  }
                  function documentDragMove(event) {
                      if (onMouseTouchDownContinue(event)) {
                          var trackLength = scrollbarVarsInfo._trackLength;
                          var handleLength = scrollbarVarsInfo._handleLength;
                          var scrollRange = scrollbarVarsInfo._maxScroll;
                          var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                          var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                          var scrollDelta = (scrollRange * scrollDeltaPercent);
                          scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                          if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                              scrollDelta *= -1;

                          _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));

                          if (_scrollbarsHandlesDefineScrollPos)
                              refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);

                          if (!_supportPassiveEvents)
                              COMPATIBILITY.prvD(event);
                      }
                      else
                          documentMouseTouchUp(event);
                  }
                  function documentMouseTouchUp(event) {
                      event = event || event.originalEvent;

                      setupResponsiveEventListener(_documentElement,
                          [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                          [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                          true);
                      COMPATIBILITY.rAF()(function() {
                          setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                      });
                      
                          
                      if (_scrollbarsHandlesDefineScrollPos)
                          refreshScrollbarHandleOffset(isHorizontal, true);

                      _scrollbarsHandlesDefineScrollPos = false;
                      removeClass(_bodyElement, _classNameDragging);
                      removeClass(scrollbarVars._handle, strActive);
                      removeClass(scrollbarVars._track, strActive);
                      removeClass(scrollbarVars._scrollbar, strActive);

                      mouseDownScroll = undefined;
                      mouseDownOffset = undefined;
                      mouseDownInvertedScale = 1;

                      decreaseTrackScrollAmount();

                      if (trackTimeout !== undefined) {
                          _base.scrollStop();
                          clearTimeout(trackTimeout);
                          trackTimeout = undefined;
                      }

                      if (event) {
                          var rect = _hostElementNative[LEXICON.bCR]();
                          var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;

                          //if mouse is outside host element
                          if (!mouseInsideHost)
                              hostOnMouseLeave();

                          if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                              refreshScrollbarsAutoHide(false);
                      }
                  }
                  function onHandleMouseTouchDown(event) {
                      if (onMouseTouchDownContinue(event))
                          onHandleMouseTouchDownAction(event);
                  }
                  function onHandleMouseTouchDownAction(event) {
                      mouseDownScroll = _viewportElement[scroll]();
                      mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                      if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
                          mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;

                      mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                      mouseDownOffset = getPointerPosition(event);

                      _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                      addClass(_bodyElement, _classNameDragging);
                      addClass(scrollbarVars._handle, strActive);
                      addClass(scrollbarVars._scrollbar, strActive);

                      setupResponsiveEventListener(_documentElement,
                          [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                          [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);
                      COMPATIBILITY.rAF()(function() {
                          setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                      });
                      

                      if (_msieVersion || !_documentMixed)
                          COMPATIBILITY.prvD(event);
                      COMPATIBILITY.stpP(event);
                  }
                  function onTrackMouseTouchDown(event) {
                      if (onMouseTouchDownContinue(event)) {
                          var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
                          var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
                          var scrollBaseDuration = 270 * handleToViewportRatio;
                          var scrollFirstIterationDelay = 400 * handleToViewportRatio;
                          var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
                          var ctrlKey = event.ctrlKey;
                          var instantScroll = event.shiftKey;
                          var instantScrollTransition = instantScroll && ctrlKey;
                          var isFirstIteration = true;
                          var easing = 'linear';
                          var decreaseScroll;
                          var finishedCondition;
                          var scrollActionFinsished = function (transition) {
                              if (_scrollbarsHandlesDefineScrollPos)
                                  refreshScrollbarHandleOffset(isHorizontal, transition);
                          };
                          var scrollActionInstantFinished = function () {
                              scrollActionFinsished();
                              onHandleMouseTouchDownAction(event);
                          };
                          var scrollAction = function () {
                              if (!_destroyed) {
                                  var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                                  var handleOffset = scrollbarVarsInfo._handleOffset;
                                  var trackLength = scrollbarVarsInfo._trackLength;
                                  var handleLength = scrollbarVarsInfo._handleLength;
                                  var scrollRange = scrollbarVarsInfo._maxScroll;
                                  var currScroll = scrollbarVarsInfo._currentScroll;
                                  var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                                  var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                                  var instantScrollPosition = scrollRange * ((mouseOffset - (handleLength / 2)) / (trackLength - handleLength)); // 100% * positionPercent
                                  var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);
                                  var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                                  var scrollObj = {};
                                  var animationObj = {
                                      easing: easing,
                                      step: function (now) {
                                          if (_scrollbarsHandlesDefineScrollPos) {
                                              _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340
                                              refreshScrollbarHandleOffset(isHorizontal, now);
                                          }
                                      }
                                  };
                                  instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                                  instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;

                                  //_base.scrollStop();

                                  if (instantScroll) {
                                      _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position
                                      if (instantScrollTransition) {
                                          //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position
                                          //and the animation stops at the correct point
                                          instantScrollPosition = _viewportElement[scroll]();
                                          //scroll back to the position before instant scrolling so animation can be performed
                                          _viewportElement[scroll](currScroll);

                                          instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;
                                          instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;

                                          scrollObj[xy] = instantScrollPosition;
                                          _base.scroll(scrollObj, extendDeep(animationObj, {
                                              duration: 130,
                                              complete: scrollActionInstantFinished
                                          }));
                                      }
                                      else
                                          scrollActionInstantFinished();
                                  }
                                  else {
                                      decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                                      finishedCondition = rtlIsNormal
                                          ? (decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset)
                                          : (decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset);

                                      if (finishedCondition) {
                                          clearTimeout(trackTimeout);
                                          _base.scrollStop();
                                          trackTimeout = undefined;
                                          scrollActionFinsished(true);
                                      }
                                      else {
                                          trackTimeout = setTimeout(scrollAction, timeoutDelay);

                                          scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;
                                          _base.scroll(scrollObj, extendDeep(animationObj, {
                                              duration: scrollDuration
                                          }));
                                      }
                                      isFirstIteration = false;
                                  }
                              }
                          };
                          if (ctrlKey)
                              increaseTrackScrollAmount();

                          mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                          mouseDownOffset = COMPATIBILITY.page(event)[xy];

                          _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                          addClass(_bodyElement, _classNameDragging);
                          addClass(scrollbarVars._track, strActive);
                          addClass(scrollbarVars._scrollbar, strActive);

                          setupResponsiveEventListener(_documentElement,
                              [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                              [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);

                          scrollAction();
                          COMPATIBILITY.prvD(event);
                          COMPATIBILITY.stpP(event);
                      }
                  }
                  function onTrackMouseTouchEnter(event) {
                      //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is "scroll" or "move".
                      _scrollbarsHandleHovered = true;
                      if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                          refreshScrollbarsAutoHide(true);
                  }
                  function onTrackMouseTouchLeave(event) {
                      _scrollbarsHandleHovered = false;
                      if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                          refreshScrollbarsAutoHide(false);
                  }
                  function onScrollbarMouseTouchDown(event) {
                      COMPATIBILITY.stpP(event);
                  }

                  addDestroyEventListener(scrollbarVars._handle,
                      _strMouseTouchDownEvent,
                      onHandleMouseTouchDown);
                  addDestroyEventListener(scrollbarVars._track,
                      [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],
                      [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);
                  addDestroyEventListener(scrollbarVars._scrollbar,
                      _strMouseTouchDownEvent,
                      onScrollbarMouseTouchDown);

                  if (_supportTransition) {
                      addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {
                          if (event.target !== scrollbarVars._scrollbar[0])
                              return;
                          refreshScrollbarHandleLength(isHorizontal);
                          refreshScrollbarHandleOffset(isHorizontal);
                      });
                  }
              }

              /**
               * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.
               * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.
               * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.
               * @param canScroll True if the scrollbar is scrollable, false otherwise.
               */
              function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
                  var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
                  var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;

                  addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
                  addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
              }

              /**
               * Autoshows / autohides both scrollbars with.
               * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.
               * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.
               */
              function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
                  clearTimeout(_scrollbarsAutoHideTimeoutId);
                  if (shallBeVisible) {
                      //if(_hasOverflowCache.x && _hideOverflowCache.xs)
                      removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                      //if(_hasOverflowCache.y && _hideOverflowCache.ys)
                      removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                  }
                  else {
                      var anyActive;
                      var strActive = 'active';
                      var hide = function () {
                          if (!_scrollbarsHandleHovered && !_destroyed) {
                              anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                              if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                  addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                              if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                  addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                          }
                      };
                      if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
                          _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                      else
                          hide();
                  }
              }

              /**
               * Refreshes the handle length of the given scrollbar.
               * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
               */
              function refreshScrollbarHandleLength(isHorizontal) {
                  var handleCSS = {};
                  var scrollbarVars = getScrollbarVars(isHorizontal);
                  var scrollbarVarsInfo = scrollbarVars._info;
                  var digit = 1000000;
                  //get and apply intended handle length
                  var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
                  handleCSS[scrollbarVars._width_height] = (MATH.floor(handleRatio * 100 * digit) / digit) + '%'; //the last * digit / digit is for flooring to the 4th digit

                  if (!nativeOverlayScrollbarsAreActive())
                      scrollbarVars._handle.css(handleCSS);

                  //measure the handle length to respect min & max length
                  scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];
                  scrollbarVarsInfo._handleLengthRatio = handleRatio;
              }

              /**
               * Refreshes the handle offset of the given scrollbar.
               * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
               * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)
               */
              function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
                  var transition = type(scrollOrTransition) == TYPES.b;
                  var transitionDuration = 250;
                  var isRTLisHorizontal = _isRTL && isHorizontal;
                  var scrollbarVars = getScrollbarVars(isHorizontal);
                  var scrollbarVarsInfo = scrollbarVars._info;
                  var strTranslateBrace = 'translate(';
                  var strTransform = VENDORS._cssProperty('transform');
                  var strTransition = VENDORS._cssProperty('transition');
                  var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
                  var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition;

                  //measure the handle length to respect min & max length
                  var handleLength = scrollbarVarsInfo._handleLength;
                  var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];
                  var handleTrackDiff = trackLength - handleLength;
                  var handleCSS = {};
                  var transformOffset;
                  var translateValue;

                  //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'
                  // because its a bit behind during the small delay when content size updates
                  //(delay = mutationObserverContentLag, if its 0 then this var could be used)
                  var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative
                  var getScrollRatio = function (base) {
                      return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
                  };
                  var getHandleOffset = function (scrollRatio) {
                      var offset = handleTrackDiff * scrollRatio;
                      offset = isNaN(offset) ? 0 : offset;
                      offset = (isRTLisHorizontal && !_rtlScrollBehavior.i) ? (trackLength - handleLength - offset) : offset;
                      offset = MATH.max(0, offset);
                      return offset;
                  };
                  var scrollRatio = getScrollRatio(nativeScroll);
                  var unsnappedScrollRatio = getScrollRatio(currentScroll);
                  var handleOffset = getHandleOffset(unsnappedScrollRatio);
                  var snappedHandleOffset = getHandleOffset(scrollRatio);

                  scrollbarVarsInfo._maxScroll = maxScroll;
                  scrollbarVarsInfo._currentScroll = nativeScroll;
                  scrollbarVarsInfo._currentScrollRatio = scrollRatio;

                  if (_supportTransform) {
                      transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px
                      //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %
                      translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';

                      handleCSS[strTransform] = translateValue;

                      //apply or clear up transition
                      if (_supportTransition)
                          handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;
                  }
                  else
                      handleCSS[scrollbarVars._left_top] = handleOffset;


                  //only apply css if offset has changed and overflow exists.
                  if (!nativeOverlayScrollbarsAreActive()) {
                      scrollbarVars._handle.css(handleCSS);

                      //clear up transition
                      if (_supportTransform && _supportTransition && transition) {
                          scrollbarVars._handle.one(_strTransitionEndEvent, function () {
                              if (!_destroyed)
                                  scrollbarVars._handle.css(strTransition, _strEmpty);
                          });
                      }
                  }

                  scrollbarVarsInfo._handleOffset = handleOffset;
                  scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
                  scrollbarVarsInfo._trackLength = trackLength;
              }

              /**
               * Refreshes the interactivity of the given scrollbar element.
               * @param isTrack True if the track element is the target, false if the handle element is the target.
               * @param value True for interactivity false for no interactivity.
               */
              function refreshScrollbarsInteractive(isTrack, value) {
                  var action = value ? 'removeClass' : 'addClass';
                  var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
                  var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
                  var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;

                  element1[action](className);
                  element2[action](className);
              }

              /**
               * Returns a object which is used for fast access for specific variables.
               * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.
               * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}
               */
              function getScrollbarVars(isHorizontal) {
                  return {
                      _width_height: isHorizontal ? _strWidth : _strHeight,
                      _Width_Height: isHorizontal ? 'Width' : 'Height',
                      _left_top: isHorizontal ? _strLeft : _strTop,
                      _Left_Top: isHorizontal ? 'Left' : 'Top',
                      _x_y: isHorizontal ? _strX : _strY,
                      _X_Y: isHorizontal ? 'X' : 'Y',
                      _w_h: isHorizontal ? 'w' : 'h',
                      _l_t: isHorizontal ? 'l' : 't',
                      _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                      _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                      _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                      _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
                  };
              }


              //==== Scrollbar Corner ====//

              /**
               * Builds or destroys the scrollbar corner DOM element.
               * @param destroy Indicates whether the DOM shall be build or destroyed.
               */
              function setupScrollbarCornerDOM(destroy) {
                  _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);

                  if (!destroy) {
                      if (!_domExists) {
                          _hostElement.append(_scrollbarCornerElement);
                      }
                  }
                  else {
                      if (_domExists && _initialized) {
                          removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                      }
                      else {
                          remove(_scrollbarCornerElement);
                      }
                  }
              }

              /**
               * Initializes all scrollbar corner interactivity events.
               */
              function setupScrollbarCornerEvents() {
                  var insideIFrame = _windowElementNative.top !== _windowElementNative;
                  var mouseDownPosition = {};
                  var mouseDownSize = {};
                  var mouseDownInvertedScale = {};
                  var reconnectMutationObserver;

                  function documentDragMove(event) {
                      if (onMouseTouchDownContinue(event)) {
                          var pageOffset = getCoordinates(event);
                          var hostElementCSS = {};
                          if (_resizeHorizontal || _resizeBoth)
                              hostElementCSS[_strWidth] = (mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x);
                          if (_resizeVertical || _resizeBoth)
                              hostElementCSS[_strHeight] = (mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y);
                          _hostElement.css(hostElementCSS);
                          COMPATIBILITY.stpP(event);
                      }
                      else {
                          documentMouseTouchUp(event);
                      }
                  }
                  function documentMouseTouchUp(event) {
                      var eventIsTrusted = event !== undefined;

                      setupResponsiveEventListener(_documentElement,
                          [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                          [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                          true);

                      removeClass(_bodyElement, _classNameDragging);
                      if (_scrollbarCornerElement.releaseCapture)
                          _scrollbarCornerElement.releaseCapture();

                      if (eventIsTrusted) {
                          if (reconnectMutationObserver)
                              connectMutationObservers();
                          _base.update(_strAuto);
                      }
                      reconnectMutationObserver = false;
                  }
                  function onMouseTouchDownContinue(event) {
                      var originalEvent = event.originalEvent || event;
                      var isTouchEvent = originalEvent.touches !== undefined;
                      return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                  }
                  function getCoordinates(event) {
                      return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
                  }

                  addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {
                      if (onMouseTouchDownContinue(event) && !_resizeNone) {
                          if (_mutationObserversConnected) {
                              reconnectMutationObserver = true;
                              disconnectMutationObservers();
                          }

                          mouseDownPosition = getCoordinates(event);

                          mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                          mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                          mouseDownInvertedScale = getHostElementInvertedScale();

                          setupResponsiveEventListener(_documentElement,
                              [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                              [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);

                          addClass(_bodyElement, _classNameDragging);
                          if (_scrollbarCornerElement.setCapture)
                              _scrollbarCornerElement.setCapture();

                          COMPATIBILITY.prvD(event);
                          COMPATIBILITY.stpP(event);
                      }
                  });
              }


              //==== Utils ====//

              /**
               * Calls the callback with the given name. The Context of this callback is always _base (this).
               * @param name The name of the target which shall be called.
               * @param args The args with which the callback shall be called.
               * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a "true" value.
               */
              function dispatchCallback(name, args, dependent) {
                  if (dependent === false)
                      return;
                  if (_initialized) {
                      var callback = _currentPreparedOptions.callbacks[name];
                      var extensionOnName = name;
                      var ext;

                      if (extensionOnName.substr(0, 2) === 'on')
                          extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);

                      if (type(callback) == TYPES.f)
                          callback.call(_base, args);

                      each(_extensions, function () {
                          ext = this;
                          if (type(ext.on) == TYPES.f)
                              ext.on(extensionOnName, args);
                      });
                  }
                  else if (!_destroyed)
                      _callbacksInitQeueue.push({ n: name, a: args });
              }

              /**
               * Sets the "top, right, bottom, left" properties, with a given prefix, of the given css object.
               * @param targetCSSObject The css object to which the values shall be applied.
               * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
               * @param values A array of values which shall be applied to the "top, right, bottom, left" -properties. The array order is [top, right, bottom, left].
               * If this argument is undefined the value '' (empty string) will be applied to all properties.
               */
              function setTopRightBottomLeft(targetCSSObject, prefix, values) {
                  prefix = prefix || _strEmpty;
                  values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];

                  targetCSSObject[prefix + _strTop] = values[0];
                  targetCSSObject[prefix + _strRight] = values[1];
                  targetCSSObject[prefix + _strBottom] = values[2];
                  targetCSSObject[prefix + _strLeft] = values[3];
              }

              /**
               * Gets the "top, right, bottom, left" CSS properties of the CSS property with the given prefix from the host element.
               * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
               * @param suffix The suffix of the "top, right, bottom, left" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)
               * @param zeroX True if the x axis shall be 0.
               * @param zeroY True if the y axis shall be 0.
               * @returns {{}} The object which contains the numbers of the read CSS properties.
               */
              function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
                  suffix = suffix || _strEmpty;
                  prefix = prefix || _strEmpty;
                  return {
                      t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
                      r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
                      b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
                      l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
                  };
              }

              /**
               * Returns the computed CSS transition string from the given element.
               * @param element The element from which the transition string shall be returned.
               * @returns {string} The CSS transition string from the given element.
               */
              function getCSSTransitionString(element) {
                  var transitionStr = VENDORS._cssProperty('transition');
                  var assembledValue = element.css(transitionStr);
                  if (assembledValue)
                      return assembledValue;
                  var regExpString = '\\s*(' + '([^,(]+(\\(.+?\\))?)+' + ')[\\s,]*';
                  var regExpMain = new RegExp(regExpString);
                  var regExpValidate = new RegExp('^(' + regExpString + ')+$');
                  var properties = 'property duration timing-function delay'.split(' ');
                  var result = [];
                  var strResult;
                  var valueArray;
                  var i = 0;
                  var j;
                  var splitCssStyleByComma = function (str) {
                      strResult = [];
                      if (!str.match(regExpValidate))
                          return str;
                      while (str.match(regExpMain)) {
                          strResult.push(RegExp.$1);
                          str = str.replace(regExpMain, _strEmpty);
                      }

                      return strResult;
                  };
                  for (; i < properties[LEXICON.l]; i++) {
                      valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));
                      for (j = 0; j < valueArray[LEXICON.l]; j++)
                          result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
                  }
                  return result.join(', ');
              }

              /**
               * Generates a Regular Expression which matches with a string which starts with 'os-host'.
               * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).
               * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).
               */
              function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
                  var i;
                  var split;
                  var appendix;
                  var appendClasses = function (classes, condition) {
                      appendix = '';
                      if (condition && typeof classes == TYPES.s) {
                          split = classes.split(_strSpace);
                          for (i = 0; i < split[LEXICON.l]; i++)
                              appendix += '|' + split[i] + '$';
                          // split[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') for escaping regex characters
                      }
                      return appendix;
                  };

                  return new RegExp(
                      '(^' + _classNameHostElement + '([-_].+|)$)' +
                      appendClasses(_classNameCache, withCurrClassNameOption) +
                      appendClasses(_oldClassName, withOldClassNameOption), 'g');
              }

              /**
               * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)
               * @returns {{x: number, y: number}} The scale of the host-element.
               */
              function getHostElementInvertedScale() {
                  var rect = _paddingElementNative[LEXICON.bCR]();
                  return {
                      x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                      y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
                  };
              }

              /**
               * Checks whether the given object is a HTMLElement.
               * @param o The object which shall be checked.
               * @returns {boolean} True the given object is a HTMLElement, false otherwise.
               */
              function isHTMLElement(o) {
                  var strOwnerDocument = 'ownerDocument';
                  var strHTMLElement = 'HTMLElement';
                  var wnd = o && o[strOwnerDocument] ? (o[strOwnerDocument].parentWindow || window) : window;
                  return (
                      typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2
                          o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s
                  );
              }

              /**
               * Compares 2 arrays and returns the differences between them as a array.
               * @param a1 The first array which shall be compared.
               * @param a2 The second array which shall be compared.
               * @returns {Array} The differences between the two arrays.
               */
              function getArrayDifferences(a1, a2) {
                  var a = [];
                  var diff = [];
                  var i;
                  var k;
                  for (i = 0; i < a1.length; i++)
                      a[a1[i]] = true;
                  for (i = 0; i < a2.length; i++) {
                      if (a[a2[i]])
                          delete a[a2[i]];
                      else
                          a[a2[i]] = true;
                  }
                  for (k in a)
                      diff.push(k);
                  return diff;
              }

              /**
               * Returns Zero or the number to which the value can be parsed.
               * @param value The value which shall be parsed.
               * @param toFloat Indicates whether the number shall be parsed to a float.
               */
              function parseToZeroOrNumber(value, toFloat) {
                  var num = toFloat ? parseFloat(value) : parseInt(value, 10);
                  return isNaN(num) ? 0 : num;
              }

              /**
               * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.
               * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.
               */
              function getTextareaInfo() {
                  //read needed values
                  var textareaCursorPosition = _targetElementNative.selectionStart;
                  if (textareaCursorPosition === undefined)
                      return;

                  var textareaValue = _targetElement.val();
                  var textareaLength = textareaValue[LEXICON.l];
                  var textareaRowSplit = textareaValue.split('\n');
                  var textareaLastRow = textareaRowSplit[LEXICON.l];
                  var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\n');
                  var widestRow = 0;
                  var textareaLastCol = 0;
                  var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
                  var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
                  var rowCols;
                  var i;

                  //get widest Row and the last column of the textarea
                  for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                      rowCols = textareaRowSplit[i][LEXICON.l];
                      if (rowCols > textareaLastCol) {
                          widestRow = i + 1;
                          textareaLastCol = rowCols;
                      }
                  }

                  return {
                      _cursorRow: cursorRow, //cursorRow
                      _cursorColumn: cursorCol, //cursorCol
                      _rows: textareaLastRow, //rows
                      _columns: textareaLastCol, //cols
                      _widestRow: widestRow, //wRow
                      _cursorPosition: textareaCursorPosition, //pos
                      _cursorMax: textareaLength //max
                  };
              }

              /**
               * Determines whether native overlay scrollbars are active.
               * @returns {boolean} True if native overlay scrollbars are active, false otherwise.
               */
              function nativeOverlayScrollbarsAreActive() {
                  return (_ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y));
              }

              /**
               * Gets the element which is used to measure the content size.
               * @returns {*} TextareaCover if target element is textarea else the ContentElement.
               */
              function getContentMeasureElement() {
                  return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
              }

              /**
               * Generates a string which represents a HTML div with the given classes or attributes.
               * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as "className".)
               * @param content The content of the div as string.
               * @returns {string} The concated string which represents a HTML div and its content.
               */
              function generateDiv(classesOrAttrs, content) {
                  return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ?
                      'class="' + classesOrAttrs + '"' :
                      (function () {
                          var key;
                          var attrs = _strEmpty;
                          if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                              for (key in classesOrAttrs)
                                  attrs += (key === 'c' ? 'class' : key) + '="' + classesOrAttrs[key] + '" ';
                          }
                          return attrs;
                      })() :
                      _strEmpty) +
                      '>' +
                      (content || _strEmpty) +
                      '</div>';
              }

              /**
               * Selects or generates a div with the given class attribute.
               * @param className The class names (divided by spaces) of the div which shall be selected or generated.
               * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)
               * If its a boolean it decides whether only the children of the host element shall be selected.
               * @returns {*} The generated or selected element.
               */
              function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
                  var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
                  var selectParent = onlyChildren ? _hostElement : (selectParentOrOnlyChildren || _hostElement);

                  return (_domExists && !selectParent[LEXICON.l])
                      ? null
                      : _domExists
                          ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\s/g, _strDot)).eq(0)
                          : FRAMEWORK(generateDiv(className))
              }

              /**
               * Gets the value of the given property from the given object.
               * @param obj The object from which the property value shall be got.
               * @param path The property of which the value shall be got.
               * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.
               */
              function getObjectPropVal(obj, path) {
                  var splits = path.split(_strDot);
                  var i = 0;
                  var val;
                  for (; i < splits.length; i++) {
                      if (!obj[LEXICON.hOP](splits[i]))
                          return;
                      val = obj[splits[i]];
                      if (i < splits.length && type(val) == TYPES.o)
                          obj = val;
                  }
                  return val;
              }

              /**
               * Sets the value of the given property from the given object.
               * @param obj The object from which the property value shall be set.
               * @param path The property of which the value shall be set.
               * @param val The value of the property which shall be set.
               */
              function setObjectPropVal(obj, path, val) {
                  var splits = path.split(_strDot);
                  var splitsLength = splits.length;
                  var i = 0;
                  var extendObj = {};
                  var extendObjRoot = extendObj;
                  for (; i < splitsLength; i++)
                      extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
                  FRAMEWORK.extend(obj, extendObjRoot, true);
              }

              /**	
               * Runs a action for each selector inside the updateOnLoad option.	
               * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).	
               */
              function eachUpdateOnLoad(action) {
                  var updateOnLoad = _currentPreparedOptions.updateOnLoad;
                  updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;

                  if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
                      each(updateOnLoad, action);
                  }
              }


              //==== Utils Cache ====//

              /**
               * Compares two values or objects and returns true if they aren't equal.
               * @param current The first value or object which shall be compared.
               * @param cache The second value or object which shall be compared.
               * @param force If true the returned value is always true.
               * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.
               */
              function checkCache(current, cache, force) {
                  if (force)
                      return force;
                  if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                      for (var prop in current) {
                          if (prop !== 'c') {
                              if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                                  if (checkCache(current[prop], cache[prop]))
                                      return true;
                              }
                              else {
                                  return true;
                              }
                          }
                      }
                  }
                  else {
                      return current !== cache;
                  }
                  return false;
              }


              //==== Shortcuts ====//

              /**
               * jQuery extend method shortcut with a appended "true" as first argument.
               */
              function extendDeep() {
                  return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
              }

              /**
               * jQuery addClass method shortcut.
               */
              function addClass(el, classes) {
                  return _frameworkProto.addClass.call(el, classes);
              }

              /**
               * jQuery removeClass method shortcut.
               */
              function removeClass(el, classes) {
                  return _frameworkProto.removeClass.call(el, classes);
              }

              /**
               * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.
               */
              function addRemoveClass(el, classes, doAdd) {
                  return doAdd ? addClass(el, classes) : removeClass(el, classes);
              }

              /**
               * jQuery remove method shortcut.
               */
              function remove(el) {
                  return _frameworkProto.remove.call(el);
              }

              /**
               * Finds the first child element with the given selector of the given element.
               * @param el The root element from which the selector shall be valid.
               * @param selector The selector of the searched element.
               * @returns {*} The first element which is a child of the given element and matches the givens selector.
               */
              function findFirst(el, selector) {
                  return _frameworkProto.find.call(el, selector).eq(0);
              }


              //==== API ====//

              /**
               * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.
               * This behavior can be reset by calling the update method.
               */
              _base.sleep = function () {
                  _sleeping = true;
              };

              /**
               * Updates the plugin and DOM to the current options.
               * This method should only be called if a update is 100% required.
               * @param force True if every property shall be updated and the cache shall be ignored.
               * !INTERNAL USAGE! : force can be a string "auto", "sync" or "zoom" too
               * if "auto" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.
               * if "sync" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.
               * if "zoom" then a update takes place where it's assumed that content and host size changed
               * @returns {boolean|undefined} 
               * If force is "sync" then a boolean is returned which indicates whether a update was needed due to pending changes.
               * If force is "auto" then a boolean is returned whether a update was needed due to attribute or size changes.
               * undefined otherwise.
               */
              _base.update = function (force) {
                  if (_destroyed)
                      return;

                  var attrsChanged;
                  var contentSizeC;
                  var isString = type(force) == TYPES.s;
                  var doUpdateAuto;
                  var mutHost;
                  var mutContent;

                  if (isString) {
                      if (force === _strAuto) {
                          attrsChanged = meaningfulAttrsChanged();
                          contentSizeC = updateAutoContentSizeChanged();
                          doUpdateAuto = attrsChanged || contentSizeC;
                          if (doUpdateAuto) {
                              update({
                                  _contentSizeChanged: contentSizeC,
                                  _changedOptions: _initialized ? undefined : _currentPreparedOptions
                              });
                          }
                      }
                      else if (force === _strSync) {
                          if (_mutationObserversConnected) {
                              mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                              mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                          }
                          else {
                              mutHost = _base.update(_strAuto);
                          }
                      }
                      else if (force === 'zoom') {
                          update({
                              _hostSizeChanged: true,
                              _contentSizeChanged: true
                          });
                      }
                  }
                  else {
                      force = _sleeping || force;
                      _sleeping = false;
                      if (!_base.update(_strSync) || force)
                          update({ _force: force });
                  }

                  updateElementsOnLoad();

                  return doUpdateAuto || mutHost || mutContent;
              };

              /**
               Gets or sets the current options. The update method will be called automatically if new options were set.
               * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.
               * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.
               * @returns {*}
               */
              _base.options = function (newOptions, value) {
                  var option = {};
                  var changedOps;

                  //return current options if newOptions are undefined or empty
                  if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                      if (type(newOptions) == TYPES.s) {
                          if (arguments.length > 1) {
                              setObjectPropVal(option, newOptions, value);
                              changedOps = setOptions(option);
                          }
                          else
                              return getObjectPropVal(_currentOptions, newOptions);
                      }
                      else
                          return _currentOptions;
                  }
                  else {
                      changedOps = setOptions(newOptions);
                  }

                  if (!FRAMEWORK.isEmptyObject(changedOps)) {
                      update({ _changedOptions: changedOps });
                  }
              };

              /**
               * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.
               */
              _base.destroy = function () {
                  if (_destroyed)
                      return;

                  //remove this instance from auto update loop
                  autoUpdateLoop.remove(_base);

                  //disconnect all mutation observers
                  disconnectMutationObservers();

                  //remove all resize observers
                  setupResizeObserver(_sizeObserverElement);
                  setupResizeObserver(_sizeAutoObserverElement);

                  //remove all extensions
                  for (var extName in _extensions)
                      _base.removeExt(extName);

                  //remove all 'destroy' events
                  while (_destroyEvents[LEXICON.l] > 0)
                      _destroyEvents.pop()();

                  //remove all events from host element
                  setupHostMouseTouchEvents(true);

                  //remove all helper / detection elements
                  if (_contentGlueElement)
                      remove(_contentGlueElement);
                  if (_contentArrangeElement)
                      remove(_contentArrangeElement);
                  if (_sizeAutoObserverAdded)
                      remove(_sizeAutoObserverElement);

                  //remove all generated DOM
                  setupScrollbarsDOM(true);
                  setupScrollbarCornerDOM(true);
                  setupStructureDOM(true);

                  //remove all generated image load events
                  for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                      FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
                  _updateOnLoadElms = undefined;

                  _destroyed = true;
                  _sleeping = true;

                  //remove this instance from the instances list
                  INSTANCES(pluginTargetElement, 0);
                  dispatchCallback('onDestroyed');

                  //remove all properties and methods
                  //for (var property in _base)
                  //    delete _base[property];
                  //_base = undefined;
              };

              /**
               * Scrolls to a given position or element.
               * @param coordinates
               * 1. Can be "coordinates" which looks like:
               *    { x : ?, y : ? } OR          Object with x and y properties
               *    { left : ?, top : ? } OR     Object with left and top properties
               *    { l : ?, t : ? } OR          Object with l and t properties
               *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)
               *    ?                            A single value which stays for both axis
               *    A value can be a number, a string or a calculation.
               *
               *    Operators:
               *    [NONE]  The current scroll will be overwritten by the value.
               *    '+='    The value will be added to the current scroll offset
               *    '-='    The value will be subtracted from the current scroll offset
               *    '*='    The current scroll wil be multiplicated by the value.
               *    '/='    The current scroll wil be divided by the value.
               *
               *    Units:
               *    [NONE]  The value is the final scroll amount.                   final = (value * 1)
               *    'px'    Same as none
               *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)
               *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)
               *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)
               *
               *    example final values:
               *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'
               *
               * 2. Can be a HTML or jQuery element:
               *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.
               *
               * 3. Can be a object with a HTML or jQuery element with additional settings:
               *    {
               *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.
               *      scroll : [string, array, object],               Default value is 'always'.
               *      block : [string, array, object],                Default value is 'begin'.
               *      margin : [number, boolean, array, object]       Default value is false.
               *    }
               *
               *    Possible scroll settings are:
               *    'always'      Scrolls always.
               *    'ifneeded'    Scrolls only if the element isnt fully in view.
               *    'never'       Scrolls never.
               *
               *    Possible block settings are:
               *    'begin'   Both axis shall be docked to the "begin" edge. - The element will be docked to the top and left edge of the viewport.
               *    'end'     Both axis shall be docked to the "end" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)
               *    'center'  Both axis shall be docked to "center". - The element will be centered in the viewport.
               *    'nearest' The element will be docked to the nearest edge(s).
               *
               *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.
               *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.
               *    [NUMBER]                                          The margin will be used for all edges.
               *
               * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.
               * @param easing The animation easing.
               * @param complete The animation complete callback.
               * @returns {{
               *   position: {x: number, y: number},
               *   ratio: {x: number, y: number},
               *   max: {x: number, y: number},
               *   handleOffset: {x: number, y: number},
               *   handleLength: {x: number, y: number},
               *   handleLengthRatio: {x: number, y: number}, t
               *   rackLength: {x: number, y: number},
               *   isRTL: boolean,
               *   isRTLNormalized: boolean
               *  }}
               */
              _base.scroll = function (coordinates, duration, easing, complete) {
                  if (arguments.length === 0 || coordinates === undefined) {
                      var infoX = _scrollHorizontalInfo;
                      var infoY = _scrollVerticalInfo;
                      var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                      var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                      var scrollX = infoX._currentScroll;
                      var scrollXRatio = infoX._currentScrollRatio;
                      var maxScrollX = infoX._maxScroll;
                      scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                      scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                      scrollX *= normalizeNegate ? -1 : 1;
                      maxScrollX *= normalizeNegate ? -1 : 1;

                      return {
                          position: {
                              x: scrollX,
                              y: infoY._currentScroll
                          },
                          ratio: {
                              x: scrollXRatio,
                              y: infoY._currentScrollRatio
                          },
                          max: {
                              x: maxScrollX,
                              y: infoY._maxScroll
                          },
                          handleOffset: {
                              x: infoX._handleOffset,
                              y: infoY._handleOffset
                          },
                          handleLength: {
                              x: infoX._handleLength,
                              y: infoY._handleLength
                          },
                          handleLengthRatio: {
                              x: infoX._handleLengthRatio,
                              y: infoY._handleLengthRatio
                          },
                          trackLength: {
                              x: infoX._trackLength,
                              y: infoY._trackLength
                          },
                          snappedHandleOffset: {
                              x: infoX._snappedHandleOffset,
                              y: infoY._snappedHandleOffset
                          },
                          isRTL: _isRTL,
                          isRTLNormalized: _normalizeRTLCache
                      };
                  }

                  _base.update(_strSync);

                  var normalizeRTL = _normalizeRTLCache;
                  var coordinatesXAxisProps = [_strX, _strLeft, 'l'];
                  var coordinatesYAxisProps = [_strY, _strTop, 't'];
                  var coordinatesOperators = ['+=', '-=', '*=', '/='];
                  var durationIsObject = type(duration) == TYPES.o;
                  var completeCallback = durationIsObject ? duration.complete : complete;
                  var i;
                  var finalScroll = {};
                  var specialEasing = {};
                  var doScrollLeft;
                  var doScrollTop;
                  var animationOptions;
                  var strEnd = 'end';
                  var strBegin = 'begin';
                  var strCenter = 'center';
                  var strNearest = 'nearest';
                  var strAlways = 'always';
                  var strNever = 'never';
                  var strIfNeeded = 'ifneeded';
                  var strLength = LEXICON.l;
                  var settingsAxis;
                  var settingsScroll;
                  var settingsBlock;
                  var settingsMargin;
                  var finalElement;
                  var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];
                  var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
                  var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
                  var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');
                  var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
                  var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
                  var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
                  var updateScrollbarInfos = function () {
                      if (doScrollLeft)
                          refreshScrollbarHandleOffset(true);
                      if (doScrollTop)
                          refreshScrollbarHandleOffset(false);
                  };
                  var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {
                      updateScrollbarInfos();
                      completeCallback();
                  };
                  function checkSettingsStringValue(currValue, allowedValues) {
                      for (i = 0; i < allowedValues[strLength]; i++) {
                          if (currValue === allowedValues[i])
                              return true;
                      }
                      return false;
                  }
                  function getRawScroll(isX, coordinates) {
                      var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                      coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;

                      if (COMPATIBILITY.isA(coordinates))
                          return isX ? coordinates[0] : coordinates[1];
                      else if (type(coordinates) == TYPES.o) {
                          //decides RTL normalization "hack" with .n
                          //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL; 
                          for (i = 0; i < coordinateProps[strLength]; i++)
                              if (coordinateProps[i] in coordinates)
                                  return coordinates[coordinateProps[i]];
                      }
                  }
                  function getFinalScroll(isX, rawScroll) {
                      var isString = type(rawScroll) == TYPES.s;
                      var operator;
                      var amount;
                      var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                      var currScroll = scrollInfo._currentScroll;
                      var maxScroll = scrollInfo._maxScroll;
                      var mult = ' * ';
                      var finalValue;
                      var isRTLisX = _isRTL && isX;
                      var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                      var strReplace = 'replace';
                      var evalFunc = eval;
                      var possibleOperator;
                      if (isString) {
                          //check operator
                          if (rawScroll[strLength] > 2) {
                              possibleOperator = rawScroll.substr(0, 2);
                              if (inArray(possibleOperator, coordinatesOperators) > -1)
                                  operator = possibleOperator;
                          }

                          //calculate units and shortcuts
                          rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                          rawScroll = rawScroll
                          [strReplace](/min/g, 0) //'min' = 0%
                          [strReplace](/</g, 0)   //'<'   = 0%
                          [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)    //'max' = 100%
                          [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)      //'>'   = 100%
                          [strReplace](/px/g, _strEmpty)
                          [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0))
                          [strReplace](/vw/g, mult + _viewportSize.w)
                          [strReplace](/vh/g, mult + _viewportSize.h);
                          amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                      }
                      else {
                          amount = rawScroll;
                      }

                      if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {
                          var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                          var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                          var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                          var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                          operatorCurrScroll = invert ? (maxScroll - operatorCurrScroll) : operatorCurrScroll;
                          switch (operator) {
                              case '+=':
                                  finalValue = operatorCurrScroll + amount;
                                  break;
                              case '-=':
                                  finalValue = operatorCurrScroll - amount;
                                  break;
                              case '*=':
                                  finalValue = operatorCurrScroll * amount;
                                  break;
                              case '/=':
                                  finalValue = operatorCurrScroll / amount;
                                  break;
                              default:
                                  finalValue = amount;
                                  break;
                          }
                          finalValue = invert ? maxScroll - finalValue : finalValue;
                          finalValue *= negate ? -1 : 1;
                          finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                      }
                      return finalValue === currScroll ? undefined : finalValue;
                  }
                  function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                      var resultDefault = [defaultValue, defaultValue];
                      var valueType = type(value);
                      var valueArrLength;
                      var valueArrItem;

                      //value can be [ string, or array of two strings ]
                      if (valueType == valueInternalType) {
                          value = [value, value];
                      }
                      else if (valueType == TYPES.a) {
                          valueArrLength = value[strLength];
                          if (valueArrLength > 2 || valueArrLength < 1)
                              value = resultDefault;
                          else {
                              if (valueArrLength === 1)
                                  value[1] = defaultValue;
                              for (i = 0; i < valueArrLength; i++) {
                                  valueArrItem = value[i];
                                  if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                                      value = resultDefault;
                                      break;
                                  }
                              }
                          }
                      }
                      else if (valueType == TYPES.o)
                          value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                      else
                          value = resultDefault;
                      return { x: value[0], y: value[1] };
                  }
                  function generateMargin(marginTopRightBottomLeftArray) {
                      var result = [];
                      var currValue;
                      var currValueType;
                      var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                      for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                          if (i === valueDirections[strLength])
                              break;
                          currValue = marginTopRightBottomLeftArray[i];
                          currValueType = type(currValue);
                          if (currValueType == TYPES.b)
                              result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                          else
                              result.push(currValueType == TYPES.n ? currValue : 0);
                      }
                      return result;
                  }

                  if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                      //get settings
                      var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                      var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                      var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                      var block = coordinatesIsElementObj ? coordinates.block : 0;
                      var marginDefault = [0, 0, 0, 0];
                      var marginType = type(margin);
                      var marginLength;
                      finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);

                      if (finalElement[strLength] > 0) {
                          //margin can be [ boolean, number, array of 2, array of 4, object ]
                          if (marginType == TYPES.n || marginType == TYPES.b)
                              margin = generateMargin([margin, margin, margin, margin]);
                          else if (marginType == TYPES.a) {
                              marginLength = margin[strLength];
                              if (marginLength === 2)
                                  margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                              else if (marginLength >= 4)
                                  margin = generateMargin(margin);
                              else
                                  margin = marginDefault;
                          }
                          else if (marginType == TYPES.o)
                              margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                          else
                              margin = marginDefault;

                          //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;
                          settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';
                          settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                          settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                          settingsMargin = margin;

                          var viewportScroll = {
                              l: _scrollHorizontalInfo._currentScroll,
                              t: _scrollVerticalInfo._currentScroll
                          };
                          // use padding element instead of viewport element because padding element has never padding, margin or position applied.
                          var viewportOffset = _paddingElement.offset();

                          //get coordinates
                          var elementOffset = finalElement.offset();
                          var doNotScroll = {
                              x: settingsScroll.x == strNever || settingsAxis == _strY,
                              y: settingsScroll.y == strNever || settingsAxis == _strX
                          };
                          elementOffset[_strTop] -= settingsMargin[0];
                          elementOffset[_strLeft] -= settingsMargin[3];
                          var elementScrollCoordinates = {
                              x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                              y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                          };
                          if (_isRTL) {
                              if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                                  elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                              if (_rtlScrollBehavior.n && normalizeRTL)
                                  elementScrollCoordinates.x *= -1;
                              if (_rtlScrollBehavior.i && normalizeRTL)
                                  elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                          }

                          //measuring is required
                          if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                              var measuringElm = finalElement[0];
                              var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                                  width: measuringElm[LEXICON.oW],
                                  height: measuringElm[LEXICON.oH]
                              };
                              var elementSize = {
                                  w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                                  h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                              };
                              var finalizeBlock = function (isX) {
                                  var vars = getScrollbarVars(isX);
                                  var wh = vars._w_h;
                                  var lt = vars._left_top;
                                  var xy = vars._x_y;
                                  var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                                  var blockIsCenter = settingsBlock[xy] == strCenter;
                                  var blockIsNearest = settingsBlock[xy] == strNearest;
                                  var scrollNever = settingsScroll[xy] == strNever;
                                  var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                                  var vpSize = _viewportSize[wh];
                                  var vpOffset = viewportOffset[lt];
                                  var elSize = elementSize[wh];
                                  var elOffset = elementOffset[lt];
                                  var divide = blockIsCenter ? 2 : 1;
                                  var elementCenterOffset = elOffset + (elSize / 2);
                                  var viewportCenterOffset = vpOffset + (vpSize / 2);
                                  var isInView =
                                      elSize <= vpSize
                                      && elOffset >= vpOffset
                                      && elOffset + elSize <= vpOffset + vpSize;

                                  if (scrollNever)
                                      doNotScroll[xy] = true;
                                  else if (!doNotScroll[xy]) {
                                      if (blockIsNearest || scrollIfNeeded) {
                                          doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                                          blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                                      }
                                      elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? ((vpSize / divide) - (elSize / divide)) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                                  }
                              };
                              finalizeBlock(true);
                              finalizeBlock(false);
                          }

                          if (doNotScroll.y)
                              delete elementScrollCoordinates.y;
                          if (doNotScroll.x)
                              delete elementScrollCoordinates.x;

                          coordinates = elementScrollCoordinates;
                      }
                  }

                  finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
                  finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
                  doScrollLeft = finalScroll[_strScrollLeft] !== undefined;
                  doScrollTop = finalScroll[_strScrollTop] !== undefined;

                  if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                      if (durationIsObject) {
                          duration.complete = proxyCompleteCallback;
                          _viewportElement.animate(finalScroll, duration);
                      }
                      else {
                          animationOptions = {
                              duration: duration,
                              complete: proxyCompleteCallback
                          };
                          if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
                              specialEasing[_strScrollLeft] = easing[0] || easing.x;
                              specialEasing[_strScrollTop] = easing[1] || easing.y;
                              animationOptions.specialEasing = specialEasing;
                          }
                          else {
                              animationOptions.easing = easing;
                          }
                          _viewportElement.animate(finalScroll, animationOptions);
                      }
                  }
                  else {
                      if (doScrollLeft)
                          _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                      if (doScrollTop)
                          _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                      updateScrollbarInfos();
                  }
              };

              /**
               * Stops all scroll animations.
               * @returns {*} The current OverlayScrollbars instance (for chaining).
               */
              _base.scrollStop = function (param1, param2, param3) {
                  _viewportElement.stop(param1, param2, param3);
                  return _base;
              };

              /**
               * Returns all relevant elements.
               * @param elementName The name of the element which shall be returned.
               * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}
               */
              _base.getElements = function (elementName) {
                  var obj = {
                      target: _targetElementNative,
                      host: _hostElementNative,
                      padding: _paddingElementNative,
                      viewport: _viewportElementNative,
                      content: _contentElementNative,
                      scrollbarHorizontal: {
                          scrollbar: _scrollbarHorizontalElement[0],
                          track: _scrollbarHorizontalTrackElement[0],
                          handle: _scrollbarHorizontalHandleElement[0]
                      },
                      scrollbarVertical: {
                          scrollbar: _scrollbarVerticalElement[0],
                          track: _scrollbarVerticalTrackElement[0],
                          handle: _scrollbarVerticalHandleElement[0]
                      },
                      scrollbarCorner: _scrollbarCornerElement[0]
                  };
                  return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
              };

              /**
               * Returns a object which describes the current state of this instance.
               * @param stateProperty A specific property from the state object which shall be returned.
               * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}
               */
              _base.getState = function (stateProperty) {
                  function prepare(obj) {
                      if (!FRAMEWORK.isPlainObject(obj))
                          return obj;
                      var extended = extendDeep({}, obj);
                      var changePropertyName = function (from, to) {
                          if (extended[LEXICON.hOP](from)) {
                              extended[to] = extended[from];
                              delete extended[from];
                          }
                      };
                      changePropertyName('w', _strWidth); //change w to width
                      changePropertyName('h', _strHeight); //change h to height
                      delete extended.c; //delete c (the 'changed' prop)
                      return extended;
                  };
                  var obj = {
                      destroyed: !!prepare(_destroyed),
                      sleeping: !!prepare(_sleeping),
                      autoUpdate: prepare(!_mutationObserversConnected),
                      widthAuto: prepare(_widthAutoCache),
                      heightAuto: prepare(_heightAutoCache),
                      padding: prepare(_cssPaddingCache),
                      overflowAmount: prepare(_overflowAmountCache),
                      hideOverflow: prepare(_hideOverflowCache),
                      hasOverflow: prepare(_hasOverflowCache),
                      contentScrollSize: prepare(_contentScrollSizeCache),
                      viewportSize: prepare(_viewportSize),
                      hostSize: prepare(_hostSizeCache),
                      documentMixed: prepare(_documentMixed)
                  };
                  return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
              };

              /**
               * Gets all or specific extension instance.
               * @param extName The name of the extension from which the instance shall be got.
               * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.
               */
              _base.ext = function (extName) {
                  var result;
                  var privateMethods = _extensionsPrivateMethods.split(' ');
                  var i = 0;
                  if (type(extName) == TYPES.s) {
                      if (_extensions[LEXICON.hOP](extName)) {
                          result = extendDeep({}, _extensions[extName]);
                          for (; i < privateMethods.length; i++)
                              delete result[privateMethods[i]];
                      }
                  }
                  else {
                      result = {};
                      for (i in _extensions)
                          result[i] = extendDeep({}, _base.ext(i));
                  }
                  return result;
              };

              /**
               * Adds a extension to this instance.
               * @param extName The name of the extension which shall be added.
               * @param extensionOptions The extension options which shall be used.
               * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.
               */
              _base.addExt = function (extName, extensionOptions) {
                  var registeredExtensionObj = _plugin.extension(extName);
                  var instance;
                  var instanceAdded;
                  var instanceContract;
                  var contractResult;
                  var contractFulfilled = true;
                  if (registeredExtensionObj) {
                      if (!_extensions[LEXICON.hOP](extName)) {
                          instance = registeredExtensionObj.extensionFactory.call(_base,
                              extendDeep({}, registeredExtensionObj.defaultOptions),
                              FRAMEWORK,
                              COMPATIBILITY);

                          if (instance) {
                              instanceContract = instance.contract;
                              if (type(instanceContract) == TYPES.f) {
                                  contractResult = instanceContract(window);
                                  contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                              }
                              if (contractFulfilled) {
                                  _extensions[extName] = instance;
                                  instanceAdded = instance.added;
                                  if (type(instanceAdded) == TYPES.f)
                                      instanceAdded(extensionOptions);

                                  return _base.ext(extName);
                              }
                          }
                      }
                      else
                          return _base.ext(extName);
                  }
                  else
                      console.warn("A extension with the name \"" + extName + "\" isn't registered.");
              };

              /**
               * Removes a extension from this instance.
               * @param extName The name of the extension which shall be removed.
               * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.
               */
              _base.removeExt = function (extName) {
                  var instance = _extensions[extName];
                  var instanceRemoved;
                  if (instance) {
                      delete _extensions[extName];

                      instanceRemoved = instance.removed;
                      if (type(instanceRemoved) == TYPES.f)
                          instanceRemoved();

                      return true;
                  }
                  return false;
              };

              /**
               * Constructs the plugin.
               * @param targetElement The element to which the plugin shall be applied.
               * @param options The initial options of the plugin.
               * @param extensions The extension(s) which shall be added right after the initialization.
               * @returns {boolean} True if the plugin was successfully initialized, false otherwise.
               */
              function construct(targetElement, options, extensions) {
                  _defaultOptions = globals.defaultOptions;
                  _nativeScrollbarStyling = globals.nativeScrollbarStyling;
                  _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                  _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
                  _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
                  _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);

                  //parse & set options but don't update
                  setOptions(extendDeep({}, _defaultOptions, options));

                  _cssCalc = globals.cssCalc;
                  _msieVersion = globals.msie;
                  _autoUpdateRecommended = globals.autoUpdateRecommended;
                  _supportTransition = globals.supportTransition;
                  _supportTransform = globals.supportTransform;
                  _supportPassiveEvents = globals.supportPassiveEvents;
                  _supportResizeObserver = globals.supportResizeObserver;
                  _supportMutationObserver = globals.supportMutationObserver;
                  _restrictedMeasuring = globals.restrictedMeasuring;
                  _documentElement = FRAMEWORK(targetElement.ownerDocument);
                  _documentElementNative = _documentElement[0];
                  _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
                  _windowElementNative = _windowElement[0];
                  _htmlElement = findFirst(_documentElement, 'html');
                  _bodyElement = findFirst(_htmlElement, 'body');
                  _targetElement = FRAMEWORK(targetElement);
                  _targetElementNative = _targetElement[0];
                  _isTextarea = _targetElement.is('textarea');
                  _isBody = _targetElement.is('body');
                  _documentMixed = _documentElementNative !== document;

                  /* On a div Element The if checks only whether:
                   * - the targetElement has the class "os-host"
                   * - the targetElement has a a child with the class "os-padding"
                   * 
                   * If that's the case, its assumed the DOM has already the following structure:
                   * (The ".os-host" element is the targetElement)
                   *
                   *  <div class="os-host">
                   *      <div class="os-resize-observer-host"></div>
                   *      <div class="os-padding">
                   *          <div class="os-viewport">
                   *              <div class="os-content"></div>
                   *          </div>
                   *      </div>
                   *      <div class="os-scrollbar os-scrollbar-horizontal ">
                   *          <div class="os-scrollbar-track">
                   *              <div class="os-scrollbar-handle"></div>
                   *          </div>
                   *      </div>
                   *      <div class="os-scrollbar os-scrollbar-vertical">
                   *          <div class="os-scrollbar-track">
                   *              <div class="os-scrollbar-handle"></div>
                   *          </div>
                   *      </div>
                   *      <div class="os-scrollbar-corner"></div>
                   *  </div>
                   *
                   * =====================================================================================
                   * 
                   * On a Textarea Element The if checks only whether:
                   * - the targetElement has the class "os-textarea" 
                   * - the targetElement is inside a element with the class "os-content" 
                   * 
                   * If that's the case, its assumed the DOM has already the following structure:
                   * (The ".os-textarea" (textarea) element is the targetElement)
                   *
                   *  <div class="os-host-textarea">
                   *      <div class="os-resize-observer-host"></div>
                   *      <div class="os-padding os-text-inherit">
                   *          <div class="os-viewport os-text-inherit">
                   *              <div class="os-content os-text-inherit">
                   *                  <div class="os-textarea-cover"></div>
                   *                  <textarea class="os-textarea os-text-inherit"></textarea>
                   *              </div>
                   *          </div>
                   *      </div>
                   *      <div class="os-scrollbar os-scrollbar-horizontal ">
                   *          <div class="os-scrollbar-track">
                   *              <div class="os-scrollbar-handle"></div>
                   *          </div>
                   *      </div>
                   *      <div class="os-scrollbar os-scrollbar-vertical">
                   *          <div class="os-scrollbar-track">
                   *              <div class="os-scrollbar-handle"></div>
                   *          </div>
                   *      </div>
                   *      <div class="os-scrollbar-corner"></div>
                   *  </div>
                   */
                  _domExists = _isTextarea
                      ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)
                      : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];

                  var initBodyScroll;
                  var bodyMouseTouchDownListener;

                  //check if the plugin hasn't to be initialized
                  if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                      dispatchCallback('onInitializationWithdrawn');
                      if (_domExists) {
                          setupStructureDOM(true);
                          setupScrollbarsDOM(true);
                          setupScrollbarCornerDOM(true);
                      }

                      _destroyed = true;
                      _sleeping = true;

                      return _base;
                  }

                  if (_isBody) {
                      initBodyScroll = {};
                      initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                      initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());

                      bodyMouseTouchDownListener = function () {
                          _viewportElement.removeAttr(LEXICON.ti);
                          setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
                      }
                  }

                  //build OverlayScrollbars DOM
                  setupStructureDOM();
                  setupScrollbarsDOM();
                  setupScrollbarCornerDOM();

                  //create OverlayScrollbars events
                  setupStructureEvents();
                  setupScrollbarEvents(true);
                  setupScrollbarEvents(false);
                  setupScrollbarCornerEvents();

                  //create mutation observers
                  createMutationObservers();

                  //build resize observer for the host element
                  setupResizeObserver(_sizeObserverElement, hostOnResized);

                  if (_isBody) {
                      //apply the body scroll to handle it right in the update method
                      _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);

                      //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling
                      if (document.activeElement == targetElement && _viewportElementNative.focus) {
                          //set a tabindex to make the viewportElement focusable
                          _viewportElement.attr(LEXICON.ti, '-1');
                          _viewportElementNative.focus();

                          /* the tabindex has to be removed due to;
                           * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too
                           * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                           */
                          setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
                      }
                  }

                  //update for the first time & initialize cache
                  _base.update(_strAuto);

                  //the plugin is initialized now!
                  _initialized = true;
                  dispatchCallback('onInitialized');

                  //call all callbacks which would fire before the initialized was complete
                  each(_callbacksInitQeueue, function (index, value) { dispatchCallback(value.n, value.a); });
                  _callbacksInitQeueue = [];

                  //add extensions
                  if (type(extensions) == TYPES.s)
                      extensions = [extensions];
                  if (COMPATIBILITY.isA(extensions))
                      each(extensions, function (index, value) { _base.addExt(value); });
                  else if (FRAMEWORK.isPlainObject(extensions))
                      each(extensions, function (key, value) { _base.addExt(key, value); });

                  //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)
                  setTimeout(function () {
                      if (_supportTransition && !_destroyed)
                          addClass(_hostElement, _classNameHostTransition);
                  }, 333);

                  return _base;
              }

              if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
                  INSTANCES(pluginTargetElement, _base);
              }

              return _base;
          }

          /**
           * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.
           * @param pluginTargetElements The elements to which the Plugin shall be initialized.
           * @param options The custom options with which the plugin shall be initialized.
           * @param extensions The extension(s) which shall be added right after initialization.
           * @returns {*}
           */
          _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {
              if (arguments[LEXICON.l] === 0)
                  return this;

              var arr = [];
              var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
              var inst;
              var result;

              //pluginTargetElements is null or undefined
              if (!pluginTargetElements)
                  return optsIsPlainObj || !options ? result : arr;

              /*
                 pluginTargetElements will be converted to:
                 1. A jQueryElement Array
                 2. A HTMLElement Array
                 3. A Array with a single HTML Element
                 so pluginTargetElements is always a array.
              */
              pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
              initOverlayScrollbarsStatics();

              if (pluginTargetElements[LEXICON.l] > 0) {
                  if (optsIsPlainObj) {
                      FRAMEWORK.each(pluginTargetElements, function (i, v) {
                          inst = v;
                          if (inst !== undefined)
                              arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                      });
                  }
                  else {
                      FRAMEWORK.each(pluginTargetElements, function (i, v) {
                          inst = INSTANCES(v);
                          if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst)))
                              arr.push(inst);
                          else if (options === undefined)
                              arr.push(inst);
                      });
                  }
                  result = arr[LEXICON.l] === 1 ? arr[0] : arr;
              }
              return result;
          };

          /**
           * Returns a object which contains global information about the plugin and each instance of it.
           * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.
           */
          _plugin.globals = function () {
              initOverlayScrollbarsStatics();
              var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
              delete globals['msie'];
              return globals;
          };

          /**
           * Gets or Sets the default options for each new plugin initialization.
           * @param newDefaultOptions The object with which the default options shall be extended.
           */
          _plugin.defaultOptions = function (newDefaultOptions) {
              initOverlayScrollbarsStatics();
              var currDefaultOptions = _pluginsGlobals.defaultOptions;
              if (newDefaultOptions === undefined)
                  return FRAMEWORK.extend(true, {}, currDefaultOptions);

              //set the new default options
              _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
          };

          /**
           * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.
           * @param osInstance The potential OverlayScrollbars instance which shall be checked.
           * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.
           */
          _plugin.valid = function (osInstance) {
              return osInstance instanceof _plugin && !osInstance.getState().destroyed;
          };

          /**
           * Registers, Unregisters or returns a extension.
           * Register: Pass the name and the extension. (defaultOptions is optional)
           * Unregister: Pass the name and anything except a function as extension parameter.
           * Get extension: Pass the name of the extension which shall be got.
           * Get all extensions: Pass no arguments.
           * @param extensionName The name of the extension which shall be registered, unregistered or returned.
           * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.
           * @param defaultOptions The default options which shall be used for the registered extension.
           */
          _plugin.extension = function (extensionName, extension, defaultOptions) {
              var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
              var argLen = arguments[LEXICON.l];
              var i = 0;
              if (argLen < 1 || !extNameTypeString) {
                  //return a copy of all extension objects
                  return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
              }
              else if (extNameTypeString) {
                  if (COMPATIBILITY.type(extension) == TYPES.f) {
                      //register extension
                      _pluginsExtensions.push({
                          name: extensionName,
                          extensionFactory: extension,
                          defaultOptions: defaultOptions
                      });
                  }
                  else {
                      for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                          if (_pluginsExtensions[i].name === extensionName) {
                              if (argLen > 1)
                                  _pluginsExtensions.splice(i, 1); //remove extension
                              else
                                  return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name
                          }
                      }
                  }
              }
          };

          return _plugin;
      })();

      if (JQUERY && JQUERY.fn) {
          /**
           * The jQuery initialization interface.
           * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.
           * @param extensions The extension(s) which shall be added right after initialization.
           * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.
           */
          JQUERY.fn.overlayScrollbars = function (options, extensions) {
              var _elements = this;
              if (JQUERY.isPlainObject(options)) {
                  JQUERY.each(_elements, function () { PLUGIN(this, options, extensions); });
                  return _elements;
              }
              else
                  return PLUGIN(_elements, options);
          };
      }
      return PLUGIN;
  }
));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SelectDefaultConfig = {
        label: "",
        size: "normal",
        selectDeferred: 0,
        clearButton: false,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        usePlaceholder: false,
        placeholder: "",
        addEmptyValue: false,
        emptyValue: "",
        duration: 0,
        prepend: "",
        append: "",
        filterPlaceholder: "Search...",
        filter: true,
        copyInlineStyles: false,
        dropHeight: 200,
        checkDropUp: true,
        dropUp: false,
        showGroupName: false,
        shortTag: true,

        clsSelect: "",
        clsSelectInput: "",
        clsPrepend: "",
        clsAppend: "",
        clsOption: "",
        clsOptionActive: "",
        clsOptionGroup: "",
        clsDropList: "",
        clsDropContainer: "",
        clsSelectedItem: "",
        clsSelectedItemRemover: "",
        clsLabel: "",

        onChange: Metro.noop,
        onUp: Metro.noop,
        onDrop: Metro.noop,
        onItemSelect: Metro.noop,
        onItemDeselect: Metro.noop,
        onSelectCreate: Metro.noop
    };

    Metro.selectSetup = function (options) {
        SelectDefaultConfig = $.extend({}, SelectDefaultConfig, options);
    };

    if (typeof window["metroSelectSetup"] !== undefined) {
        Metro.selectSetup(window["metroSelectSetup"]);
    }

    Metro.Component('select', {
        init: function( options, elem ) {
            this._super(elem, options, SelectDefaultConfig, {
                list: null,
                placeholder: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createSelect();
            this._createEvents();

            this._fireEvent("select-create", {
                element: element
            });
        },

        _setPlaceholder: function(){
            var element = this.element, o = this.options;
            var input = element.siblings(".select-input");
            if (o.usePlaceholder === true && (!Utils.isValue(element.val()) || element.val() == o.emptyValue)) {
                input.html(this.placeholder);
            }
        },

        _addTag: function(val, data){
            var element = this.element, o = this.options;
            var tag, tagSize, container = element.closest(".select");
            tag = $("<div>").addClass("tag").addClass(o.shortTag ? "short-tag" : "").addClass(o.clsSelectedItem).html("<span class='title'>"+val+"</span>").data("option", data);
            $("<span>").addClass("remover").addClass(o.clsSelectedItemRemover).html("&times;").appendTo(tag);

            if (container.hasClass("input-large")) {
                tagSize = "large";
            } else if (container.hasClass("input-small")) {
                tagSize = "small"
            }

            tag.addClass(tagSize);

            return tag;
        },

        _addOption: function(item, parent, input, multiple, group){
            var option = $(item);
            var l, a;
            var element = this.element, o = this.options;
            var html = Utils.isValue(option.attr('data-template')) ? option.attr('data-template').replace("$1", item.text):item.text;

            l = $("<li>").addClass(o.clsOption).data("option", item).attr("data-text", item.text).attr('data-value', item.value ? item.value : "");
            a = $("<a>").html(html);

            l.addClass(item.className);

            l.data("group", group);

            if (option.is(":disabled")) {
                l.addClass("disabled");
            }

            if (option.is(":selected")) {

                if (o.showGroupName && group) {
                    html += "&nbsp;<span class='selected-item__group-name'>" + group + "</span>";
                }

                if (multiple) {
                    l.addClass("d-none");
                    input.append(this._addTag(html, l));
                } else {
                    element.val(item.value);
                    input.html(html);
                    element.fire("change", {
                        val: item.value
                    });
                    l.addClass("active");
                }
            }

            l.append(a).appendTo(parent);
        },

        _addOptionGroup: function(item, parent, input, multiple){
            var that = this, o = this.options;
            var group = $(item);

            $("<li>").html(item.label).addClass("group-title").addClass(o.clsOptionGroup).appendTo(parent);

            $.each(group.children(), function(){
                that._addOption(this, parent, input, multiple, item.label);
            })
        },

        _createOptions: function(){
            var that = this, element = this.element, o = this.options, select = element.parent();
            var list = select.find("ul").empty();
            var selected = element.find("option[selected]").length > 0;
            var multiple = element[0].multiple;
            var input = element.siblings(".select-input");

            element.siblings(".select-input").empty();

            if (o.addEmptyValue === true) {
                element.prepend($("<option "+(!selected ? 'selected' : '')+" value='"+o.emptyValue+"' class='d-none'></option>"));
            }

            $.each(element.children(), function(){
                if (this.tagName === "OPTION") {
                    that._addOption(this, list, input, multiple, null);
                } else if (this.tagName === "OPTGROUP") {
                    that._addOptionGroup(this, list, input, multiple);
                }
            });
        },

        _createSelect: function(){
            var that = this, element = this.element, o = this.options;

            var container = $("<label>").addClass("select " + element[0].className).addClass(o.clsSelect);
            var multiple = element[0].multiple;
            var select_id = Utils.elementId("select");
            var buttons = $("<div>").addClass("button-group");
            var input, drop_container, drop_container_input, list, filter_input, dropdown_toggle;
            var checkboxID = Utils.elementId("select-focus-trigger");
            var checkbox = $("<input type='checkbox'>").addClass("select-focus-trigger").attr("id", checkboxID);

            this.placeholder = $("<span>").addClass("placeholder").html(o.placeholder);

            container.attr("id", select_id).attr("for", checkboxID);
            container.addClass("input-" + o.size);

            dropdown_toggle = $("<span>").addClass("dropdown-toggle");
            dropdown_toggle.appendTo(container);

            if (multiple) {
                container.addClass("multiple");
            }

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);
            checkbox.appendTo(container);

            input = $("<div>").addClass("select-input").addClass(o.clsSelectInput).attr("name", "__" + select_id + "__");
            drop_container = $("<div>").addClass("drop-container").addClass(o.clsDropContainer);
            drop_container_input = $("<div>").appendTo(drop_container);
            list = $("<ul>").addClass("option-list").addClass(o.clsDropList).css({
                "max-height": o.dropHeight
            });
            filter_input = $("<input type='text' data-role='input'>").attr("placeholder", o.filterPlaceholder).appendTo(drop_container_input);

            container.append(input);
            container.append(drop_container);

            drop_container.append(drop_container_input);

            if (o.filter !== true) {
                drop_container_input.hide();
            }

            drop_container.append(list);

            this._createOptions();

            this._setPlaceholder();

            Metro.makePlugin(drop_container, "dropdown", {
                dropFilter: ".select",
                duration: o.duration,
                toggleElement: [container],
                checkDropUp: o.checkDropUp,
                dropUp: o.dropUp,
                onDrop: function(){
                    var dropped, target;
                    dropdown_toggle.addClass("active-toggle");
                    dropped = $(".select .drop-container");
                    $.each(dropped, function(){
                        var drop = $(this);
                        if (drop.is(drop_container)) {
                            return ;
                        }
                        var dataDrop = Metro.getPlugin(drop, 'dropdown');
                        if (dataDrop && dataDrop.close) {
                            dataDrop.close();
                        }
                    });

                    filter_input.val("").trigger(Metro.events.keyup);//.focus();

                    target = list.find("li.active").length > 0 ? $(list.find("li.active")[0]) : undefined;
                    if (target !== undefined) {
                        list[0].scrollTop = target.position().top - ( (list.height() - target.height() )/ 2);
                    }

                    that._fireEvent("drop", {
                        list: list[0]
                    });
                },
                onUp: function(){
                    dropdown_toggle.removeClass("active-toggle");

                    that._fireEvent("up", {
                        list: list[0]
                    });
                }
            });

            this.list = list;

            if (o.clearButton === true && !element[0].readOnly) {
                var clearButton = $("<button>").addClass("button input-clear-button").addClass(o.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            } else {
                buttons.addClass("d-none");
            }

            if (o.prepend !== "" && !multiple) {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (o.append !== "" && !multiple) {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
            }

            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".select");
            var drop_container = container.find(".drop-container");
            var input = element.siblings(".select-input");
            var filter_input = drop_container.find("input");
            var list = drop_container.find("ul");
            var clearButton = container.find(".input-clear-button");
            var checkbox = container.find(".select-focus-trigger");

            checkbox.on("focus", function(){
                container.addClass("focused");
            });

            checkbox.on("blur", function(){
                container.removeClass("focused");
            });

            clearButton.on(Metro.events.click, function(e){
                element.val(o.emptyValue);
                if (element[0].multiple) {
                    list.find("li").removeClass("d-none");
                    input.clear();
                }
                that._setPlaceholder();
                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.change, function(){
                that._setPlaceholder();
            });

            container.on(Metro.events.click, function(){
                $(".focused").removeClass("focused");
                container.addClass("focused");
            });

            input.on(Metro.events.click, function(){
                $(".focused").removeClass("focused");
                container.addClass("focused");
            });

            list.on(Metro.events.click, "li", function(e){
                if ($(this).hasClass("group-title")) {
                    e.preventDefault();
                    e.stopPropagation();
                    return ;
                }
                var leaf = $(this);
                var val = leaf.data('value');
                var group = leaf.data('group');
                var html = leaf.children('a').html();
                var selected;
                var option = leaf.data("option");
                var options = element.find("option");

                if (o.showGroupName && group) {
                    html += "&nbsp;<span class='selected-item__group-name'>" + group + "</span>";
                }

                if (element[0].multiple) {
                    leaf.addClass("d-none");
                    input.append(that._addTag(html, leaf));
                } else {
                    list.find("li.active").removeClass("active").removeClass(o.clsOptionActive);
                    leaf.addClass("active").addClass(o.clsOptionActive);
                    input.html(html);
                    Metro.getPlugin(drop_container, "dropdown").close();
                }

                $.each(options, function(){
                    if (this === option) {
                        this.selected = true;
                    }
                });

                that._fireEvent("item-select", {
                    val: val,
                    option: option,
                    leaf: leaf[0]
                });

                selected = that.getSelected();

                that._fireEvent("change", {
                    selected: selected
                });
            });

            input.on("click", ".tag .remover", function(e){
                var item = $(this).closest(".tag");
                var leaf = item.data("option");
                var option = leaf.data('option');
                var selected;

                leaf.removeClass("d-none");
                $.each(element.find("option"), function(){
                    if (this === option) {
                        this.selected = false;
                    }
                });
                item.remove();

                that._fireEvent("item-deselect", {
                    option: option
                });

                selected = that.getSelected();

                that._fireEvent("change", {
                    selected: selected
                });

                e.preventDefault();
                e.stopPropagation();
            });

            filter_input.on(Metro.events.keyup, function(){
                var filter = this.value.toUpperCase();
                var li = list.find("li");
                var i, a;
                for (i = 0; i < li.length; i++) {
                    if ($(li[i]).hasClass("group-title")) continue;
                    a = li[i].getElementsByTagName("a")[0];
                    if (a.innerHTML.toUpperCase().indexOf(filter) > -1) {
                        li[i].style.display = "";
                    } else {
                        li[i].style.display = "none";
                    }
                }
            });

            filter_input.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            });

            drop_container.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.closest(".select").addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.closest(".select").removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        reset: function(to_default){
            var element = this.element;
            var options = element.find("option");
            var select = element.closest('.select');
            var selected;

            $.each(options, function(){
                this.selected = !Utils.isNull(to_default) ? this.defaultSelected : false;
            });

            this.list.find("li").remove();
            select.find(".select-input").html('');

            this._createOptions();

            selected = this.getSelected();

            this._fireEvent("change", {
                selected: selected
            });
        },

        getSelected: function(){
            var element = this.element;
            var result = [];

            element.find("option").each(function(){
                if (this.selected) result.push(this.value);
            });

            return result;
        },

        val: function(val){
            var element = this.element, o = this.options;
            var input = element.siblings(".select-input");
            var options = element.find("option");
            var list_items = this.list.find("li");
            var result = [];
            var multiple = element.attr("multiple") !== undefined;
            var option;
            var i, html, list_item, option_value, tag, selected;

            if (Utils.isNull(val)) {
                $.each(options, function(){
                    if (this.selected) result.push(this.value);
                });
                return multiple ? result : result[0];
            }

            $.each(options, function(){
                this.selected = false;
            });
            list_items.removeClass("active");
            input.html('');

            if (Array.isArray(val) === false) {
                val  = [val];
            }

            $.each(val, function(){
                for (i = 0; i < options.length; i++) {
                    option = options[i];
                    html = Utils.isValue(option.getAttribute('data-template')) ? option.getAttribute('data-template').replace("$1", option.text) : option.text;
                    if (""+option.value === ""+this) {
                        option.selected = true;
                        break;
                    }
                }

                for(i = 0; i < list_items.length; i++) {
                    list_item = $(list_items[i]);
                    option_value = list_item.attr("data-value");
                    if (""+option_value === ""+this) {
                        if (multiple) {
                            list_item.addClass("d-none");
                            tag = $("<div>").addClass("tag").addClass(o.clsSelectedItem).html("<span class='title'>"+html+"</span>").appendTo(input);
                            tag.data("option", list_item);
                            $("<span>").addClass("remover").addClass(o.clsSelectedItemRemover).html("&times;").appendTo(tag);
                        } else {
                            list_item.addClass("active");
                            input.html(html);
                        }
                        break;
                    }
                }
            });

            selected = this.getSelected();

            this._fireEvent("change", {
                selected: selected
            });
        },

        data: function(op, selected, delimiter){
            var element = this.element;
            var option_group, _selected;
            var _delimiter = delimiter || ",";

            if (typeof selected === "string") {
                _selected = selected.toArray(_delimiter).map(function(v){
                    return +v;
                });
            } else if (Array.isArray(selected)) {
                _selected = selected.slice().map(function(v){
                    return +v;
                });
            } else {
                _selected = [];
            }

            element.empty();

            if (typeof op === 'string') {
                element.html(op);
            } else if (Utils.isObject(op)) {
                $.each(op, function(key, val){
                    if (Utils.isObject(val)) {
                        option_group = $("<optgroup label=''>").attr("label", key).appendTo(element);
                        $.each(val, function(key2, val2){
                            var op = $("<option>").attr("value", key2).text(val2).appendTo(option_group);
                            if (_selected.indexOf(+key2) > -1) {
                                op.prop("selected", true);
                            }
                        });
                    } else {
                        var op = $("<option>").attr("value", key).text(val).appendTo(element);
                        if (_selected.indexOf(+key) > -1) {
                            op.prop("selected", true);
                        }
                    }
                });
            }

            this._createOptions();
        },

        changeAttribute: function(attributeName){
            if (attributeName === 'disabled') {
                this.toggleState();
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.closest(".select");
            var drop_container = container.find(".drop-container");
            var input = element.siblings(".select-input");
            var filter_input = drop_container.find("input");
            var list = drop_container.find("ul");
            var clearButton = container.find(".input-clear-button");

            container.off(Metro.events.click);
            container.off(Metro.events.click, ".input-clear-button");
            input.off(Metro.events.click);
            filter_input.off(Metro.events.blur);
            filter_input.off(Metro.events.focus);
            list.off(Metro.events.click, "li");
            filter_input.off(Metro.events.keyup);
            drop_container.off(Metro.events.click);
            clearButton.off(Metro.events.click);

            drop_container.data("dropdown").destroy();

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $(".select").removeClass("focused");
    }, {ns: "blur-select-elements"});
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SliderDefaultConfig = {
        sliderDeferred: 0,
        roundValue: true,
        min: 0,
        max: 100,
        accuracy: 0,
        showMinMax: false,
        minMaxPosition: Metro.position.TOP,
        value: 0,
        buffer: 0,
        hint: false,
        hintAlways: false,
        hintPosition: Metro.position.TOP,
        hintMask: "$1",
        vertical: false,
        target: null,
        returnType: "value", // value or percent
        size: 0,

        clsSlider: "",
        clsBackside: "",
        clsComplete: "",
        clsBuffer: "",
        clsMarker: "",
        clsHint: "",
        clsMinMax: "",
        clsMin: "",
        clsMax: "",

        onStart: Metro.noop,
        onStop: Metro.noop,
        onMove: Metro.noop,
        onSliderClick: Metro.noop,
        onChange: Metro.noop,
        onChangeValue: Metro.noop,
        onChangeBuffer: Metro.noop,
        onFocus: Metro.noop,
        onBlur: Metro.noop,
        onSliderCreate: Metro.noop
    };

    Metro.sliderSetup = function (options) {
        SliderDefaultConfig = $.extend({}, SliderDefaultConfig, options);
    };

    if (typeof window["metroSliderSetup"] !== undefined) {
        Metro.sliderSetup(window["metroSliderSetup"]);
    }

    Metro.Component('slider', {
        init: function( options, elem ) {
            this._super(elem, options, SliderDefaultConfig, {
                slider: null,
                value: 0,
                percent: 0,
                pixel: 0,
                buffer: 0,
                keyInterval: false,
                id: Utils.elementId('slider')
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this._createSlider();
            this._createEvents();
            this.buff(o.buffer);
            this.val(o.value);

            this._fireEvent("slider-create", {
                element: element
            });
        },

        _createSlider: function(){
            var element = this.element, o = this.options;

            var prev = element.prev();
            var parent = element.parent();
            var slider = $("<div>").addClass("slider " + element[0].className).addClass(o.clsSlider);
            var backside = $("<div>").addClass("backside").addClass(o.clsBackside);
            var complete = $("<div>").addClass("complete").addClass(o.clsComplete);
            var buffer = $("<div>").addClass("buffer").addClass(o.clsBuffer);
            var marker = $("<button>").attr("type", "button").addClass("marker").addClass(o.clsMarker);
            var hint = $("<div>").addClass("hint").addClass(o.hintPosition + "-side").addClass(o.clsHint);
            var i;

            if (o.size > 0) {
                if (o.vertical === true) {
                    slider.outerHeight(o.size);
                } else {
                    slider.outerWidth(o.size);
                }
            }

            if (o.vertical === true) {
                slider.addClass("vertical-slider");
            }

            if (prev.length === 0) {
                parent.prepend(slider);
            } else {
                slider.insertAfter(prev);
            }

            if (o.hintAlways === true) {
                hint.css({
                    display: "block"
                }).addClass("permanent-hint");
            }

            element.appendTo(slider);
            backside.appendTo(slider);
            complete.appendTo(slider);
            buffer.appendTo(slider);
            marker.appendTo(slider);
            hint.appendTo(marker);

            if (o.showMinMax === true) {
                var min_max_wrapper = $("<div>").addClass("slider-min-max").addClass(o.clsMinMax);
                $("<span>").addClass("slider-text-min").addClass(o.clsMin).html(o.min).appendTo(min_max_wrapper);
                $("<span>").addClass("slider-text-max").addClass(o.clsMax).html(o.max).appendTo(min_max_wrapper);
                if (o.minMaxPosition === Metro.position.TOP) {
                    min_max_wrapper.insertBefore(slider);
                } else {
                    min_max_wrapper.insertAfter(slider);
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    slider.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.slider = slider;
        },

        _createEvents: function(){
            var that = this, slider = this.slider, o = this.options;
            var marker = slider.find(".marker");
            var hint = slider.find(".hint");

            marker.on(Metro.events.startAll, function(){
                if (o.hint === true && o.hintAlways !== true) {
                    hint.fadeIn(300);
                }

                $(document).on(Metro.events.moveAll, function(e){
                    that._move(e);

                    that._fireEvent("move", {
                        val: that.value,
                        percent: that.percent
                    });

                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});

                    if (o.hintAlways !== true) {
                        hint.fadeOut(300);
                    }

                    that._fireEvent("stop", {
                        val: that.value,
                        percent: that.percent
                    });
                }, {ns: that.id});

                that._fireEvent("start", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.focus, function(){
                that._fireEvent("focus", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.blur, function(){
                that._fireEvent("blur", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.keydown, function(e){

                var key = e.keyCode ? e.keyCode : e.which;

                if ([37,38,39,40].indexOf(key) === -1) {
                    return;
                }

                var step = o.accuracy === 0 ? 1 : o.accuracy;

                if (that.keyInterval) {
                    return ;
                }
                that.keyInterval = setInterval(function(){

                    var val = that.value;

                    if (e.keyCode === 37 || e.keyCode === 40) { // left, down
                        if (val - step < o.min) {
                            val = o.min;
                        } else {
                            val -= step;
                        }
                    }

                    if (e.keyCode === 38 || e.keyCode === 39) { // right, up
                        if (val + step > o.max) {
                            val = o.max;
                        } else {
                            val += step;
                        }
                    }

                    that.value = that._correct(val);
                    that.percent = that._convert(that.value, 'val2prc');
                    that.pixel = that._convert(that.percent, 'prc2pix');

                    that._redraw();
                }, 100);

                e.preventDefault();
            });

            marker.on(Metro.events.keyup, function(){
                clearInterval(that.keyInterval);
                that.keyInterval = false;
            });

            slider.on(Metro.events.click, function(e){
                that._move(e);

                that._fireEvent("slider-click", {
                    val: that.value,
                    percent: that.percent
                });

                that._fireEvent("stop", {
                    val: that.value,
                    percent: that.percent
                });
            });

            $(window).on(Metro.events.resize,function(){
                that.val(that.value);
                that.buff(that.buffer);
            }, {ns: that.id});
        },

        _convert: function(v, how){
            var slider = this.slider, o = this.options;
            var length = (o.vertical === true ? slider.outerHeight() : slider.outerWidth()) - slider.find(".marker").outerWidth();
            switch (how) {
                case "pix2prc": return ( v * 100 / length );
                case "pix2val": return ( this._convert(v, 'pix2prc') * ((o.max - o.min) / 100) + o.min );
                case "val2prc": return ( (v - o.min)/( (o.max - o.min) / 100 )  );
                case "prc2pix": return ( v / ( 100 / length ));
                case "val2pix": return ( this._convert(this._convert(v, 'val2prc'), 'prc2pix') );
            }

            return 0;
        },

        _correct: function(value){
            var res = value;
            var accuracy  = this.options.accuracy;
            var min = this.options.min, max = this.options.max;

            if (accuracy === 0 || isNaN(accuracy)) {
                return res;
            }

            res = Math.round(value/accuracy)*accuracy;

            if (res < min) {
                res = min;
            }

            if (res > max) {
                res = max;
            }

            return res.toFixed(Utils.decCount(accuracy));
        },

        _move: function(e){
            var slider = this.slider, o = this.options;
            var offset = slider.offset(),
                marker_size = slider.find(".marker").outerWidth(),
                length = o.vertical === true ? slider.outerHeight() : slider.outerWidth(),
                cPos, cPix, cStart = 0, cStop = length - marker_size;

            cPos = o.vertical === true ? Utils.pageXY(e).y - offset.top : Utils.pageXY(e).x - offset.left;
            cPix = o.vertical === true ? length - cPos - marker_size / 2 : cPos - marker_size / 2;

            if (cPix < cStart || cPix > cStop) {
                return ;
            }

            this.value = this._correct(this._convert(cPix, 'pix2val'));
            this.percent = this._convert(this.value, 'val2prc');
            this.pixel = this._convert(this.percent, 'prc2pix');

            this._redraw();
        },

        _hint: function(){
            var o = this.options, slider = this.slider, hint = slider.find(".hint");
            var value = +this.value || 0;
            var percent = +this.percent || 0;

            if (o.roundValue) {
                value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o.accuracy));
                percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o.accuracy));
            }

            hint.text(o.hintMask.replace("$1", value).replace("$2", percent));
        },

        _value: function(){
            var element = this.element, o = this.options;
            var value = o.returnType === 'value' ? this.value : this.percent;
            var percent = this.percent;
            var buffer = this.buffer;

            if (o.roundValue) {
                value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o.accuracy));
                percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o.accuracy));
                buffer = (Utils.isValue(buffer) ? +buffer : 0).toFixed(Utils.decCount(o.accuracy));
            }

            if (element[0].tagName === "INPUT") {
                element.val(value);
            }

            if (o.target !== null) {
                var target = $(o.target);
                if (target.length !== 0) {

                    $.each(target, function(){
                        var t = $(this);
                        if (this.tagName === "INPUT") {
                            t.val(value);
                        } else {
                            t.text(value);
                        }
                        t.trigger("change");
                    });
                }
            }

            this._fireEvent("change-value", {
                val: value
            });

            this._fireEvent("change", {
                val: value,
                percent: percent,
                buffer: buffer
            });
        },

        _marker: function(){
            var slider = this.slider, o = this.options;
            var marker = slider.find(".marker"), complete = slider.find(".complete");
            var length = o.vertical === true ? slider.outerHeight() : slider.outerWidth();
            var marker_size = parseInt(Utils.getStyleOne(marker, "width"));
            var slider_visible = Utils.isVisible(slider);

            if (slider_visible) {
                marker.css({
                    'margin-top': 0,
                    'margin-left': 0
                });
            }

            if (o.vertical === true) {
                if (slider_visible) {
                    marker.css('top', length - this.pixel);
                } else {
                    marker.css('top', (100 - this.percent) + "%");
                    marker.css('margin-top', marker_size / 2);
                }
                complete.css('height', this.percent+"%");
            } else {
                if (slider_visible) {
                    marker.css('left', this.pixel);
                } else {
                    marker.css('left', this.percent + "%");
                    marker.css('margin-left', this.percent === 0 ? 0 : -1 * marker_size / 2);
                }
                complete.css('width', this.percent+"%");
            }
        },

        _redraw: function(){
            this._marker();
            this._value();
            this._hint();
        },

        _buffer: function(){
            var element = this.element, o = this.options;
            var buffer = this.slider.find(".buffer");

            if (o.vertical === true) {
                buffer.css("height", this.buffer + "%");
            } else {
                buffer.css("width", this.buffer + "%");
            }

            this._fireEvent("change-buffer", {
                val: this.buffer
            });

            this._fireEvent("change", {
                val: element.val(),
                percent: this.percent,
                buffer: this.buffer
            });
        },

        val: function(v){
            var o = this.options;

            if (v === undefined || isNaN(v)) {
                return this.value;
            }

            if (v < o.min) {
                v = o.min;
            }

            if (v > o.max) {
                v = o.max;
            }

            this.value = this._correct(v);
            this.percent = this._convert(this.value, 'val2prc');
            this.pixel = this._convert(this.percent, 'prc2pix');

            this._redraw();
        },

        buff: function(v){
            var slider = this.slider;
            var buffer = slider.find(".buffer");

            if (v === undefined || isNaN(v)) {
                return this.buffer;
            }

            if (buffer.length === 0) {
                return false;
            }

            v = parseInt(v);

            if (v > 100) {
                v = 100;
            }

            if (v < 0) {
                v = 0;
            }

            this.buffer = v;
            this._buffer();
        },

        changeValue: function(){
            var element = this.element, o = this.options;
            var val = element.attr("data-value");
            if (val < o.min) {
                val = o.min
            }
            if (val > o.max) {
                val = o.max
            }
            this.val(val);
        },

        changeBuffer: function(){
            var element = this.element;
            var val = parseInt(element.attr("data-buffer"));
            if (val < 0) {
                val = 0
            }
            if (val > 100) {
                val = 100
            }
            this.buff(val);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value": this.changeValue(); break;
                case "data-buffer": this.changeBuffer(); break;
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, slider = this.slider;
            var marker = slider.find(".marker");

            marker.off(Metro.events.startAll);
            marker.off(Metro.events.focus);
            marker.off(Metro.events.blur);
            marker.off(Metro.events.keydown);
            marker.off(Metro.events.keyup);
            slider.off(Metro.events.click);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SorterDefaultConfig = {
        sorterDeferred: 0,
        thousandSeparator: ",",
        decimalSeparator: ",",
        sortTarget: null,
        sortSource: null,
        sortDir: "asc",
        sortStart: true,
        saveInitial: true,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSorterCreate: Metro.noop
    };

    Metro.sorterSetup = function (options) {
        SorterDefaultConfig = $.extend({}, SorterDefaultConfig, options);
    };

    if (typeof window["metroSorterSetup"] !== undefined) {
        Metro.sorterSetup(window["metroSorterSetup"]);
    }

    Metro.Component('sorter', {
        init: function( options, elem ) {
            this._super(elem, options, SorterDefaultConfig, {
                initial: []
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();

            this._fireEvent("sorter-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            if (o.sortTarget === null) {
                o.sortTarget = element.children()[0].tagName;
            }

            this.initial = element.find(o.sortTarget).get();

            if (o.sortStart === true) {
                this.sort(o.sortDir);
            }
        },

        _getItemContent: function(item){
            var o = this.options;
            var data, inset, i, format;

            if (Utils.isValue(o.sortSource)) {
                data = "";
                inset = item.getElementsByClassName(o.sortSource);

                if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                    data += inset[i].textContent;
                }
                format = inset[0].dataset.format;
            } else {
                data = item.textContent;
                format = item.dataset.format;
            }

            data = (""+data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(format)) {

                if (['number', 'int', 'float', 'money'].indexOf(format) !== -1 && (o.thousandSeparator !== "," || o.decimalSeparator !== "." )) {
                    data = Utils.parseNumber(data, o.thousandSeparator, o.decimalSeparator);
                }

                switch (format) {
                    case "date": data = Utils.isDate(data) ? new Date(data) : ""; break;
                    case "number": data = Number(data); break;
                    case "int": data = parseInt(data); break;
                    case "float": data = parseFloat(data); break;
                    case "money": data = Utils.parseMoney(data); break;
                    case "card": data = Utils.parseCard(data); break;
                    case "phone": data = Utils.parsePhone(data); break;
                }
            }

            return data;
        },

        sort: function(dir){
            var that = this, element = this.element, o = this.options;
            var items;
            var id = Utils.elementId("temp");
            var prev;

            if (dir !== undefined) {
                o.sortDir = dir;
            }

            items = element.find(o.sortTarget).get();

            if (items.length === 0) {
                return ;
            }

            prev = $("<div>").attr("id", id).insertBefore($(element.find(o.sortTarget)[0]));

            this._fireEvent("sort-start", {
                items: items
            });

            items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2 ) {
                    result = -1;
                }

                if (c1 > c2 ) {
                    result = 1;
                }

                if (result !== 0) {
                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            if (o.sortDir === "desc") {
                items.reverse();
            }

            element.find(o.sortTarget).remove();

            $.each(items, function(){
                var $this = $(this);
                $this.insertAfter(prev);
                prev = $this;
            });

            $("#"+id).remove();

            this._fireEvent("sort-stop", {
                items: items
            });
        },

        reset: function(){
            var element = this.element, o = this.options;
            var items;
            var id = Utils.elementId('sorter');
            var prev;

            items = this.initial;

            if (items.length === 0) {
                return ;
            }

            prev = $("<div>").attr("id", id).insertBefore($(element.find(o.sortTarget)[0]));

            element.find(o.sortTarget).remove();

            $.each(items, function(){
                var $this = $(this);
                $this.insertAfter(prev);
                prev = $this;
            });

            $("#"+id).remove();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeSortDir = function() {
                var dir = element.attr("data-sort-dir").trim();
                if (dir === "") return;
                o.sortDir = dir;
                that.sort();
            };

            var changeSortContent = function(){
                var content = element.attr("data-sort-content").trim();
                if (content === "") return ;
                o.sortContent = content;
                that.sort();
            };

            switch (attributeName) {
                case "data-sort-dir": changeSortDir(); break;
                case "data-sort-content": changeSortContent(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['sorter'] = {
        create: function(el, op){
            return Utils.$()(el).sorter(op);
        },

        isSorter: function(el){
            return Utils.isMetroObject(el, "sorter");
        },

        sort: function(el, dir){
            if (!this.isSorter(el)) {
                return false;
            }
            if (dir === undefined) {
                dir = "asc";
            }
            Metro.getPlugin(el, "sorter").sort(dir);
        },

        reset: function(el){
            if (!this.isSorter(el)) {
                return false;
            }
            Metro.getPlugin(el, "sorter").reset();
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SpinnerDefaultConfig = {
        spinnerDeferred: 0,
        label: "",
        step: 1,
        plusIcon: "<span class='default-icon-plus'></span>",
        minusIcon: "<span class='default-icon-minus'></span>",
        buttonsPosition: "default",
        defaultValue: 0,
        minValue: null,
        maxValue: null,
        fixed: 0,
        repeatThreshold: 1000,
        hideCursor: false,
        clsSpinner: "",
        clsSpinnerInput: "",
        clsSpinnerButton: "",
        clsSpinnerButtonPlus: "",
        clsSpinnerButtonMinus: "",
        clsLabel: "",
        onBeforeChange: Metro.noop_true,
        onChange: Metro.noop,
        onPlusClick: Metro.noop,
        onMinusClick: Metro.noop,
        onArrowUp: Metro.noop,
        onArrowDown: Metro.noop,
        onButtonClick: Metro.noop,
        onArrowClick: Metro.noop,
        onSpinnerCreate: Metro.noop
    };

    Metro.spinnerSetup = function (options) {
        SpinnerDefaultConfig = $.extend({}, SpinnerDefaultConfig, options);
    };

    if (typeof window["metroSpinnerSetup"] !== undefined) {
        Metro.spinnerSetup(window["metroSpinnerSetup"]);
    }

    Metro.Component('spinner', {
        init: function( options, elem ) {
            this._super(elem, options, SpinnerDefaultConfig, {
                repeat_timer: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("spinner-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var spinner = $("<div>").addClass("spinner").addClass("buttons-"+o.buttonsPosition).addClass(element[0].className).addClass(o.clsSpinner);
            var button_plus = $("<button>").attr("type", "button").addClass("button spinner-button spinner-button-plus").addClass(o.clsSpinnerButton + " " + o.clsSpinnerButtonPlus).html(o.plusIcon);
            var button_minus = $("<button>").attr("type", "button").addClass("button spinner-button spinner-button-minus").addClass(o.clsSpinnerButton + " " + o.clsSpinnerButtonMinus).html(o.minusIcon);
            var init_value = element.val().trim();

            if (!Utils.isValue(init_value)) {
                element.val(0);
            }

            element[0].className = '';

            spinner.insertBefore(element);
            element.appendTo(spinner).addClass(o.clsSpinnerInput);

            element.addClass("original-input");

            button_plus.appendTo(spinner);
            button_minus.appendTo(spinner);

            if (o.hideCursor === true) {
                spinner.addClass("hide-cursor");
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(spinner);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (o.disabled === true || element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var spinner = element.closest(".spinner");
            var spinner_buttons = spinner.find(".spinner-button");

            var spinnerButtonClick = function(plus, threshold){
                var curr = element.val();

                var val = Number(element.val());
                var step = Number(o.step);

                if (plus) {
                    val += step;
                } else {
                    val -= step;
                }

                that._setValue(val.toFixed(o.fixed), true);

                that._fireEvent(plus ? "plus-click" : "minus-click", {
                    curr: curr,
                    val: val,
                    elementVal: element.val()
                });

                that._fireEvent(plus ? "arrow-up" : "arrow-down", {
                    curr: curr,
                    val: val,
                    elementVal: element.val()
                });

                that._fireEvent("button-click", {
                    curr: curr,
                    val: val,
                    elementVal: element.val(),
                    button: plus ? "plus" : "minus"
                });

                that._fireEvent("arrow-click", {
                    curr: curr,
                    val: val,
                    elementVal: element.val(),
                    button: plus ? "plus" : "minus"
                });

                setTimeout(function(){
                    if (that.repeat_timer) {
                        spinnerButtonClick(plus, 100);
                    }
                }, threshold);
            };

            spinner.on(Metro.events.click, function(e){
                $(".focused").removeClass("focused");
                spinner.addClass("focused");
                e.preventDefault();
                e.stopPropagation();
            });

            spinner_buttons.on(Metro.events.start, function(e){
                var plus = $(this).closest(".spinner-button").hasClass("spinner-button-plus");
                e.preventDefault();
                that.repeat_timer = true;
                spinnerButtonClick(plus, o.repeatThreshold);
            });

            spinner_buttons.on(Metro.events.stop, function(){
                that.repeat_timer = false;
            });

            element.on(Metro.events.keydown, function(e){
                if (e.keyCode === Metro.keyCode.UP_ARROW || e.keyCode === Metro.keyCode.DOWN_ARROW) {
                    that.repeat_timer = true;
                    spinnerButtonClick(e.keyCode === Metro.keyCode.UP_ARROW, o.repeatThreshold);
                }
            });

            spinner.on(Metro.events.keyup, function(){
                that.repeat_timer = false;
            });
        },

        _setValue: function(val, trigger_change){
            var element = this.element, o = this.options;

            if (Utils.exec(o.onBeforeChange, [val], element[0]) !== true) {
                return ;
            }

            if (Utils.isValue(o.maxValue) && val > Number(o.maxValue)) {
                val =  Number(o.maxValue);
            }

            if (Utils.isValue(o.minValue) && val < Number(o.minValue)) {
                val =  Number(o.minValue);
            }

            element.val(val);

            this._fireEvent("change", {val: val}, false, true);

            if (trigger_change === true) {
                element.fire("change", {
                    val: val
                });
            }
        },

        val: function(val){
            var that = this, element = this.element, o = this.options;
            if (!Utils.isValue(val)) {
                return element.val();
            }

            that._setValue(val.toFixed(o.fixed), true);
        },

        toDefault: function(){
            var o = this.options;
            var val = Utils.isValue(o.defaultValue) ? Number(o.defaultValue) : 0;
            this._setValue(val.toFixed(o.fixed), true);

            this._fireEvent("change", {
                val: val
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;

            var changeValue = function(){
                var val = element.attr('value').trim();
                if (Utils.isValue(val)) {
                    that._setValue(Number(val), false);
                }
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'value': changeValue(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var spinner = element.closest(".spinner");
            var spinner_buttons = spinner.find(".spinner-button");

            spinner.off(Metro.events.click);
            spinner_buttons.off(Metro.events.start);
            spinner_buttons.off(Metro.events.stop);
            element.off(Metro.events.keydown);
            spinner.off(Metro.events.keyup);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $(".spinner").removeClass("focused");
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Storage = Metro.storage;
    var SplitterDefaultConfig = {
        splitterDeferred: 0,
        splitMode: "horizontal", // horizontal or vertical
        splitSizes: null,
        gutterSize: 4,
        minSizes: null,
        children: "*",
        gutterClick: "expand", // TODO expand or collapse
        saveState: false,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResizeSplit: Metro.noop,
        onResizeWindow: Metro.noop,
        onSplitterCreate: Metro.noop
    };

    Metro.splitterSetup = function (options) {
        SplitterDefaultConfig = $.extend({}, SplitterDefaultConfig, options);
    };

    if (typeof window["metroSplitterSetup"] !== undefined) {
        Metro.splitterSetup(window["metroSplitterSetup"]);
    }

    Metro.Component('splitter', {
        init: function( options, elem ) {
            this._super(elem, options, SplitterDefaultConfig, {
                storage: Utils.isValue(Storage) ? Storage : null,
                storageKey: "SPLITTER:",
                id: Utils.elementId("splitter")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("splitter-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var children = element.children(o.children).addClass("split-block");
            var i, children_sizes = [];
            var resizeProp = o.splitMode === "horizontal" ? "width" : "height";

            element.addClass("splitter");
            if (o.splitMode.toLowerCase() === "vertical") {
                element.addClass("vertical");
            }

            for (i = 0; i < children.length - 1; i++) {
                $("<div>").addClass("gutter").css(resizeProp, o.gutterSize).insertAfter($(children[i]));
            }

            this._setSize();

            if (Utils.isValue(o.minSizes)) {
                if (String(o.minSizes).contains(",")) {
                    children_sizes = o.minSizes.toArray();
                    for (i = 0; i < children_sizes.length; i++) {
                        $(children[i]).data("min-size", children_sizes[i]);
                        children[i].style.setProperty('min-'+resizeProp, String(children_sizes[i]).contains("%") ? children_sizes[i] : String(children_sizes[i]).replace("px", "")+"px", 'important');
                    }
                } else {
                    $.each(children, function(){
                        this.style.setProperty('min-'+resizeProp, String(o.minSizes).contains("%") ? o.minSizes : String(o.minSizes).replace("px", "")+"px", 'important');
                    });
                }
            }

            if (o.saveState && this.storage !== null) {
                this._getSize();
            }
        },

        _setSize: function(){
            var element = this.element, o = this.options;
            var gutters, children_sizes, i;
            var children = element.children(".split-block");

            gutters = element.children(".gutter");

            if (!Utils.isValue(o.splitSizes)) {
                children.css({
                    flexBasis: "calc("+(100/children.length)+"% - "+(gutters.length * o.gutterSize)+"px)"
                })
            } else {
                children_sizes = o.splitSizes.toArray();
                for(i = 0; i < children_sizes.length; i++) {
                    $(children[i]).css({
                        flexBasis: "calc("+children_sizes[i]+"% - "+(gutters.length * o.gutterSize)+"px)"
                    });
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var gutters = element.children(".gutter");

            gutters.on(Metro.events.startAll, function(e){
                var w = o.splitMode === "horizontal" ? element.width() : element.height();
                var gutter = $(this);
                var prev_block = gutter.prev(".split-block");
                var next_block = gutter.next(".split-block");
                var prev_block_size = 100 * (o.splitMode === "horizontal" ? prev_block.outerWidth(true) : prev_block.outerHeight(true)) / w;
                var next_block_size = 100 * (o.splitMode === "horizontal" ? next_block.outerWidth(true) : next_block.outerHeight(true)) / w;
                var start_pos = Utils.getCursorPosition(element[0], e);

                gutter.addClass("active");

                prev_block.addClass("stop-pointer");
                next_block.addClass("stop-pointer");

                that._fireEvent("resize-start", {
                    pos: start_pos,
                    gutter: gutter[0],
                    prevBlock: prev_block[0],
                    nextBlock: next_block[0]
                });

                $(window).on(Metro.events.moveAll, function(e){
                    var pos = Utils.getCursorPosition(element[0], e);
                    var new_pos;

                    if (o.splitMode === "horizontal") {
                        new_pos = (pos.x * 100 / w) - (start_pos.x * 100 / w);

                    } else {
                        new_pos = (pos.y * 100 / w) - (start_pos.y * 100 / w);
                    }

                    prev_block.css("flex-basis", "calc(" + (prev_block_size + new_pos) + "% - "+(gutters.length * o.gutterSize)+"px)");
                    next_block.css("flex-basis", "calc(" + (next_block_size - new_pos) + "% - "+(gutters.length * o.gutterSize)+"px)");

                    that._fireEvent("resize-split", {
                        pos: pos,
                        gutter: gutter[0],
                        prevBlock: prev_block[0],
                        nextBlock: next_block[0]
                    });

                }, {ns: that.id});

                $(window).on(Metro.events.stopAll, function(e){
                    var cur_pos;

                    prev_block.removeClass("stop-pointer");
                    next_block.removeClass("stop-pointer");

                    that._saveSize();

                    gutter.removeClass("active");

                    $(window).off(Metro.events.moveAll,{ns: that.id});
                    $(window).off(Metro.events.stopAll,{ns: that.id});

                    cur_pos = Utils.getCursorPosition(element[0], e);

                    that._fireEvent("resize-stop", {
                        pos: cur_pos,
                        gutter: gutter[0],
                        prevBlock: prev_block[0],
                        nextBlock: next_block[0]
                    });

                }, {ns: that.id})
            });

            $(window).on(Metro.events.resize, function(){
                var gutter = element.children(".gutter");
                var prev_block = gutter.prev(".split-block");
                var next_block = gutter.next(".split-block");

                that._fireEvent("resize-window", {
                    prevBlock: prev_block[0],
                    nextBlock: next_block[0]
                });

            }, {ns: that.id});
        },

        _saveSize: function(){
            var element = this.element, o = this.options;
            var storage = this.storage, itemsSize = [];
            var id = element.attr("id") || this.id;

            if (o.saveState === true && storage !== null) {

                $.each(element.children(".split-block"), function(){
                    var item = $(this);
                    itemsSize.push(item.css("flex-basis"));
                });

                if (storage)
                    storage.setItem(this.storageKey + id, itemsSize);
            }

        },

        _getSize: function(){
            var element = this.element, o = this.options;
            var storage = this.storage, itemsSize = [];
            var id = element.attr("id") || this.id;

            if (o.saveState === true && storage !== null) {

                itemsSize = storage.getItem(this.storageKey + id);

                $.each(element.children(".split-block"), function(i, v){
                    var item = $(v);
                    if (Utils.isValue(itemsSize) && Utils.isValue(itemsSize[i])) item.css("flex-basis", itemsSize[i]);
                });
            }
        },

        size: function(size){
            var that = this, o = this.options;
            if (Utils.isValue(size)) {
                o.splitSizes = size;
                that._setSize();
            }
            return this;
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;

            function changeSize(){
                var size = element.attr("data-split-sizes");
                that.size(size);
            }

            if (attributeName === 'data-split-sizes') {
                changeSize();
            }
        },

        destroy: function(){
            var element = this.element;
            var gutters = element.children(".gutter");
            gutters.off(Metro.events.start);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro , $) {
  'use strict';

  var Utils = Metro.utils;
  var startMenuDefaultConfig = {
    elements: {
      sideNav: '.sidenav-simple' ,
      powerBTN: '[data-role="power-button"]' ,
      expandBTN: '[data-role="start-menu-expand"]' ,
      powerPopover: 'ul' ,
      startBTN: '[data-target="start-menu"]'
    } ,
    sideNavToggleCls: 'sidenav-simple-expand-xxl win-shadow hover'
  };

  Metro.startMenuSetup = function (options) {
    startMenuDefaultConfig = $.extend({}, startMenuDefaultConfig, options);
  };

  if (typeof window["metroStartMenuSetup"] !== undefined) {
    Metro.startMenuSetup(window["metroStartMenuSetup"]);
  }

  Metro.Component('start-menu', {
    init: function (options, elem) {
      this._super(elem, options, startMenuDefaultConfig, {
          id: Utils.elementId('start-menu')
      });

      return this;
    },

    _create: function () {
      var element = this.element;

      this._createStructure();
      this._createEvents();

      this._fireEvent("start-menu-create", {
        element: element
      });
    },

    _createStructure: function () {
      var o = this.options;
      var element = this.element;

      o.elements.sideNav = element.find(o.elements.sideNav);
      o.elements.powerBTN = element.find(o.elements.powerBTN);
      o.elements.expandBTN = element.find(o.elements.expandBTN);
      o.elements.powerPopover = o.elements.powerBTN.find(o.elements.powerPopover);
      o.elements.startBTN = $(document).find(o.elements.startBTN);
    },

    _createEvents: function () {
      var o = this.options;
      var that = this;

      $(document).on(Metro.events.click , function(e) {
        var target = $(e.target);
        
        if((target.attr('data-role') !== 'start-menu' && target.parents('[data-role="start-menu"]').length <= 0) &&
            (target.attr('data-target') !== 'start-menu' && target.parents('[data-target="start-menu"]').length <= 0)) {
          that.setStartMenuStatus(Metro.statuses.HIDE);
        }
      });

      o.elements.expandBTN.on(Metro.events.click , function() {
        that.setSideNavStatus(Metro.statuses.TOGGLE);
      });

      o.elements.startBTN.on(Metro.events.click , function() {
        that.setStartMenuStatus(Metro.statuses.TOGGLE);
      });

      o.elements.sideNav.on(Metro.events.enter , function() {
        that.setSideNavStatus(Metro.statuses.SHOW);
      });

      o.elements.sideNav.on(Metro.events.leave , function() {
        that.setSideNavStatus(Metro.statuses.HIDE);
      });

      o.elements.powerBTN.on(Metro.events.click , function() {
        that.setPowerPopoverStatus(Metro.statuses.TOGGLE);
      });

      o.elements.powerPopover.on(Metro.events.leave , function() {
        that.setPowerPopoverStatus(Metro.statuses.HIDE);
      });
    } ,

    setStartMenuStatus: function(s) {
      var element = this.element;

      switch(s) {
        case Metro.statuses.SHOW:
          element.show();
          break;
        case Metro.statuses.HIDE:
          element.hide();
          break;
        case Metro.statuses.TOGGLE:
          element.toggle();
          break;
      }
    } ,

    setPowerPopoverStatus: function(s) {
      var powerPopover = this.options.elements.powerPopover;

      switch(s) {
        case Metro.statuses.SHOW:
          powerPopover.removeClass('d-none');
          break;
        case Metro.statuses.HIDE:
          powerPopover.addClass('d-none');
          break;
        case Metro.statuses.TOGGLE:
          powerPopover.toggleClass('d-none');
          break;
      }
    } ,

    setSideNavStatus: function(s) {
      var o = this.options;
      var sideNav = o.elements.sideNav;

      switch(s) {
        case Metro.statuses.SHOW:
          sideNav.addClass(o.sideNavToggleCls);
          break;
        case Metro.statuses.HIDE:
          this.setPowerPopoverStatus(s);
          sideNav.removeClass(o.sideNavToggleCls);
          break;
        case Metro.statuses.TOGGLE:
          sideNav.toggleClass(o.sideNavToggleCls);
          break;
      }
    }
  });
}(Metro , m4q));

(function(Metro, $) {
    'use strict';
    var StepperDefaultConfig = {
        stepperDeferred: 0,
        view: Metro.stepperView.SQUARE, // square, cycle, diamond
        steps: 3,
        step: 1,
        stepClick: false,
        clsStepper: "",
        clsStep: "",
        clsComplete: "",
        clsCurrent: "",
        onStep: Metro.noop,
        onStepClick: Metro.noop,
        onStepperCreate: Metro.noop
    };

    Metro.stepperSetup = function (options) {
        StepperDefaultConfig = $.extend({}, StepperDefaultConfig, options);
    };

    if (typeof window["metroStepperSetup"] !== undefined) {
        Metro.stepperSetup(window["metroStepperSetup"]);
    }

    Metro.Component('stepper', {
        init: function( options, elem ) {
            this._super(elem, options, StepperDefaultConfig, {
                current: 0
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (o.step <= 0) {
                o.step = 1;
            }

            this._createStepper();
            this._createEvents();

            this._fireEvent("stepper-create", {
                element: element
            });
        },

        _createStepper: function(){
            var element = this.element, o = this.options;
            var i;

            element.addClass("stepper").addClass(o.view).addClass(o.clsStepper);

            for(i = 1; i <= o.steps; i++) {
                $("<span>").addClass("step").addClass(o.clsStep).data("step", i).html("<span>"+i+"</span>").appendTo(element);
            }

            this.current = 1;
            this.toStep(o.step);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".step", function(){
                var step = $(this).data("step");
                if (o.stepClick === true) {
                    that.toStep(step);

                    that._fireEvent("step-click", {
                        step: step
                    });
                }
            });
        },

        next: function(){
            var element = this.element;
            var steps = element.find(".step");

            if (this.current + 1 > steps.length) {
                return ;
            }

            this.current++;

            this.toStep(this.current);
        },

        prev: function(){
            if (this.current - 1 === 0) {
                return ;
            }

            this.current--;

            this.toStep(this.current);
        },

        last: function(){
            var element = this.element;

            this.toStep(element.find(".step").length);
        },

        first: function(){
            this.toStep(1);
        },

        toStep: function(step){
            var element = this.element, o = this.options;
            var target = $(element.find(".step").get(step - 1));
            var prevStep = this.current;

            if (target.length === 0) {
                return ;
            }

            this.current = step;

            element.find(".step")
                .removeClass("complete current")
                .removeClass(o.clsCurrent)
                .removeClass(o.clsComplete);

            target.addClass("current").addClass(o.clsCurrent);
            target.prevAll().addClass("complete").addClass(o.clsComplete);

            this._fireEvent("step", {
                step: this.current,
                prev: prevStep
            });

        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".step");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro) {
    'use strict';
    var Utils = Metro.utils;

    var MetroStorage = function(type){
        return new MetroStorage.init(type);
    };

    MetroStorage.prototype = {
        setKey: function(key){
            this.key = key
        },

        getKey: function(){
            return this.key;
        },

        setItem: function(key, value){
            this.storage.setItem(this.key + ":" + key, JSON.stringify(value));
        },

        getItem: function(key, default_value, reviver){
            var result, value;

            value = this.storage.getItem(this.key + ":" + key);

            try {
                result = JSON.parse(value, reviver);
            } catch (e) {
                result = null;
            }
            return Utils.nvl(result, default_value);
        },

        getItemPart: function(key, sub_key, default_value, reviver){
            var i;
            var val = this.getItem(key, default_value, reviver);

            sub_key = sub_key.split("->");
            for(i = 0; i < sub_key.length; i++) {
                val = val[sub_key[i]];
            }
            return val;
        },

        delItem: function(key){
            this.storage.removeItem(this.key + ":" + key)
        },

        size: function(unit){
            var divider;
            switch (unit) {
                case 'm':
                case 'M': {
                    divider = 1024 * 1024;
                    break;
                }
                case 'k':
                case 'K': {
                    divider = 1024;
                    break;
                }
                default: divider = 1;
            }
            return JSON.stringify(this.storage).length / divider;
        }
    };

    MetroStorage.init = function(type){

        this.key = "";
        this.storage = type ? type : window.localStorage;

        return this;
    };

    MetroStorage.init.prototype = MetroStorage.prototype;

    Metro.storage = MetroStorage(window.localStorage);
    Metro.session = MetroStorage(window.sessionStorage);
}(Metro));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SwitchDefaultConfig = {
        switchDeferred: 0,
        material: false,
        transition: true,
        caption: "",
        captionPosition: "right",
        clsSwitch: "",
        clsCheck: "",
        clsCaption: "",
        onSwitchCreate: Metro.noop
    };

    Metro.switchSetup = function (options) {
        SwitchDefaultConfig = $.extend({}, SwitchDefaultConfig, options);
    };

    if (typeof window["metroSwitchSetup"] !== undefined) {
        Metro.switchSetup(window["metroSwitchSetup"]);
    }

    Metro.Component('switch', {
        init: function( options, elem ) {
            this._super(elem, options, SwitchDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var container ;
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "checkbox");

            if (element.attr("readonly") !== undefined) {
                element.on("click", function(e){
                    e.preventDefault();
                })
            }

            container = element.wrap(
                $("<label>").addClass((o.material === true ? " switch-material " : " switch ") + element[0].className)
            );

            check.appendTo(container);
            caption.appendTo(container);

            if (element.attr("data-on")) check.attr("data-on", element.attr("data-on"));
            if (element.attr("data-off")) check.attr("data-off", element.attr("data-off"));

            if (o.transition === true) {
                container.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                container.addClass("caption-left");
            }

            element[0].className = '';

            container.addClass(o.clsSwitch);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

            this._fireEvent("switch-create");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggle: function(v){
            var element = this.element;

            if (!Utils.isValue(v)) {
                element.prop("checked", !Utils.bool(element.prop("checked")));
            } else {
                element.prop("checked", v === 1);
            }

            return this;
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Export = Metro.export;
    var TableDefaultConfig = {
        tableDeferred: 0,
        emptyTableTitle: "Nothing to show",
        templateBeginToken: "<%",
        templateEndToken: "%>",
        paginationDistance: 5,

        locale: METRO_LOCALE,

        horizontalScroll: false,
        horizontalScrollStop: null,
        check: false,
        checkType: "checkbox",
        checkStyle: 1,
        checkColIndex: 0,
        checkName: null,
        checkStoreKey: "TABLE:$1:KEYS",
        rownum: false,
        rownumTitle: "#",

        filters: null,
        filtersOperator: "and",

        head: null,
        body: null,
        static: false,
        source: null,

        searchMinLength: 1,
        searchThreshold: 500,
        searchFields: null,

        showRowsSteps: true,
        showSearch: true,
        showTableInfo: true,
        showPagination: true,
        paginationShortMode: true,
        showActivity: true,
        muteTable: true,
        showSkip: false,

        rows: 10,
        rowsSteps: "10,25,50,100",

        staticView: false,
        viewSaveMode: "client",
        viewSavePath: "TABLE:$1:OPTIONS",

        sortDir: "asc",
        decimalSeparator: ".",
        thousandSeparator: ",",

        tableRowsCountTitle: "Show entries:",
        tableSearchTitle: "Search:",
        tableInfoTitle: "Showing $1 to $2 of $3 entries",
        paginationPrevTitle: "Prev",
        paginationNextTitle: "Next",
        allRecordsTitle: "All",
        inspectorTitle: "Inspector",
        tableSkipTitle: "Go to page",

        activityType: "cycle",
        activityStyle: "color",
        activityTimeout: 100,

        searchWrapper: null,
        rowsWrapper: null,
        infoWrapper: null,
        paginationWrapper: null,
        skipWrapper: null,

        cellWrapper: false,

        clsComponent: "",
        clsTableContainer: "",
        clsTable: "",

        clsHead: "",
        clsHeadRow: "",
        clsHeadCell: "",

        clsBody: "",
        clsBodyRow: "",
        clsBodyCell: "",
        clsCellWrapper: "",

        clsFooter: "",
        clsFooterRow: "",
        clsFooterCell: "",

        clsTableTop: "",
        clsRowsCount: "",
        clsSearch: "",

        clsTableBottom: "",
        clsTableInfo: "",
        clsTablePagination: "",

        clsPagination: "",
        clsTableSkip: "",
        clsTableSkipInput: "",
        clsTableSkipButton: "",

        clsEvenRow: "",
        clsOddRow: "",
        clsRow: "",

        clsEmptyTableTitle: "",

        onDraw: Metro.noop,
        onDrawRow: Metro.noop,
        onDrawCell: Metro.noop,
        onAppendRow: Metro.noop,
        onAppendCell: Metro.noop,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSearch: Metro.noop,
        onRowsCountChange: Metro.noop,
        onDataLoad: Metro.noop,
        onDataLoadError: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataSaveError: Metro.noop,
        onFilterRowAccepted: Metro.noop,
        onFilterRowDeclined: Metro.noop,
        onCheckClick: Metro.noop,
        onCheckClickAll: Metro.noop,
        onCheckDraw: Metro.noop,
        onViewSave: Metro.noop,
        onViewGet: Metro.noop,
        onViewCreated: Metro.noop,
        onTableCreate: Metro.noop,
        onSkip: Metro.noop
    };

    Metro.tableSetup = function(options){
        TableDefaultConfig = $.extend({}, TableDefaultConfig, options);
    };

    if (typeof window["metroTableSetup"] !== undefined) {
        Metro.tableSetup(window["metroTableSetup"]);
    }

    Metro.Component('table', {
        init: function( options, elem ) {
            this._super(elem, options, TableDefaultConfig, {
                currentPage: 1,
                pagesCount: 1,
                searchString: "",
                data: null,
                activity: null,
                loadActivity: null,
                busy: false,
                filters: [],
                wrapperInfo: null,
                wrapperSearch: null,
                wrapperRows: null,
                wrapperPagination: null,
                wrapperSkip: null,
                filterIndex: null,
                filtersIndexes: [],
                component: null,
                inspector: null,
                view: {},
                viewDefault: {},
                locale: Metro.locales["en-US"],
                input_interval: null,
                searchFields: [],
                id: Utils.elementId('table'),
                sort: {
                    dir: "asc",
                    colIndex: 0
                },
                service: [],
                heads: [],
                items: [],
                foots: [],
                filteredItems: [],
                index: {}
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var id = Utils.elementId("table");
            var table_component, table_container, activity;

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", id);
            }

            if (Utils.isValue(Metro.locales[o.locale])) {
                this.locale = Metro.locales[o.locale];
            }

            if (Utils.isValue(o.searchFields)) {
                this.searchFields = o.searchFields.toArray();
            }

            if (Utils.isValue(o.head)) {
                var _head = o.head;
                o.head = Utils.isObject(o.head);
                if (!o.head) {
                    console.warn("Head "+_head+" defined but not exists!");
                    o.head = null;
                }
            }

            if (Utils.isValue(o.body)) {
                var _body = o.body;
                o.body = Utils.isObject(o.body);
                if (!o.body) {
                    console.warn("Body "+_body+" defined but not exists!");
                    o.body = null;
                }
            }

            if (o.static === true) {
                o.showPagination = false;
                o.showRowsSteps = false;
                o.showSearch = false;
                o.showTableInfo = false;
                o.showSkip = false;
                o.rows = -1;
            }

            table_component = $("<div>").addClass("table-component");
            table_component.insertBefore(element);

            table_container = $("<div>").addClass("table-container").addClass(o.clsTableContainer).appendTo(table_component);
            element.appendTo(table_container);

            if (o.horizontalScroll === true) {
                table_container.addClass("horizontal-scroll");
            }
            if (!Utils.isNull(o.horizontalScrollStop) && Utils.mediaExist(o.horizontalScrollStop)) {
                table_container.removeClass("horizontal-scroll");
            }

            table_component.addClass(o.clsComponent);

            this.activity =  $("<div>").addClass("table-progress").appendTo(table_component);

            activity = $("<div>").appendTo(this.activity);
            Metro.makePlugin(activity, "activity", {
                type: o.activityType,
                style: o.activityStyle
            });

            if (o.showActivity !== true) {
                this.activity.css({
                    visibility: "hidden"
                })
            }

            this.component = table_component[0];

            if (o.source !== null) {

                this._fireEvent("data-load", {
                    source: o.source
                });

                var objSource = Utils.isObject(o.source);

                if (objSource !== false && $.isPlainObject(objSource)) {
                    that._build(objSource);
                } else {
                    this.activity.show(function () {
                        $.json(o.source).then(function (data) {
                            that.activity.hide();
                            if (typeof data !== "object") {
                                throw new Error("Data for table is not a object");
                            }

                            that._fireEvent("data-loaded", {
                                source: o.source,
                                data: data
                            });

                            that._build(data);
                        }, function (xhr) {
                            that.activity.hide();

                            that._fireEvent("data-load-error", {
                                source: o.source,
                                xhr: xhr
                            });
                        });
                    });
                }
            } else {
                that._build();
            }
        },

        _createIndex: function(){
            var that = this, colIndex = this.options.checkColIndex;
            setImmediate(function(){
                that.items.forEach(function(v, i){
                    that.index[v[colIndex]] = i;
                });
            });
        },

        _build: function(data){
            var that = this, element = this.element, o = this.options;
            var view, id = element.attr("id"), viewPath;

            o.rows = parseInt(o.rows);

            this.items = [];
            this.heads = [];
            this.foots = [];

            if (Array.isArray(o.head)) {
                this.heads = o.head;
            }

            if (Array.isArray(o.body)) {
                this.items = o.body;
            }

            if (Utils.isValue(data)) {
                this._createItemsFromJSON(data);
            } else {
                this._createItemsFromHTML()
            }

            // Create index
            this._createIndex();

            this.view = this._createView();
            this.viewDefault = Utils.objectClone(this.view);

            viewPath = o.viewSavePath.replace("$1", id);

            if (o.viewSaveMode.toLowerCase() === "client") {

                view = Metro.storage.getItem(viewPath);
                if (Utils.isValue(view) && Utils.objectLength(view) === Utils.objectLength(this.view)) {
                    this.view = view;

                    this._fireEvent("view-get", {
                        source: "client",
                        view: view
                    });
                }
                this._final();

            } else {

                $.json(viewPath, (viewPath !== o.viewSavePath ? null : {id: id}))
                .then(function(view){
                    if (Utils.isValue(view) && Utils.objectLength(view) === Utils.objectLength(that.view)) {
                        that.view = view;
                        that._fireEvent("view-get", {
                            source: "server",
                            view: view
                        });
                    }
                    that._final();
                }, function(){
                    that._final();
                    console.warn("Warning! Error loading view for table " + element.attr('id') + " ");
                });

            }
        },

        _final: function(){
            var element = this.element, o = this.options;
            var id = element.attr("id");

            Metro.storage.delItem(o.checkStoreKey.replace("$1", id));

            this._service();
            this._createStructure();
            this._createInspector();
            this._createEvents();

            this._fireEvent("table-create", {
                element: element
            });
        },

        _service: function(){
            var o = this.options;

            this.service = [
                {
                    // Rownum
                    title: o.rownumTitle,
                    format: undefined,
                    name: undefined,
                    sortable: false,
                    sortDir: undefined,
                    clsColumn: "rownum-cell " + (o.rownum !== true ? "d-none" : ""),
                    cls: "rownum-cell " + (o.rownum !== true ? "d-none" : ""),
                    colspan: undefined,
                    type: "rownum"
                },
                {
                    // Check
                    title: o.checkType === "checkbox" ? "<input type='checkbox' data-role='checkbox' class='table-service-check-all' data-style='"+o.checkStyle+"'>" : "",
                    format: undefined,
                    name: undefined,
                    sortable: false,
                    sortDir: undefined,
                    clsColumn: "check-cell " + (o.check !== true ? "d-none" : ""),
                    cls: "check-cell "+(o.check !== true ? "d-none" : ""),
                    colspan: undefined,
                    type: "rowcheck"
                }
            ];
        },

        _createView: function(){
            var view;

            view = {};

            $.each(this.heads, function(i){

                if (Utils.isValue(this.cls)) {this.cls = this.cls.replace("hidden", "");}
                if (Utils.isValue(this.clsColumn)) {this.clsColumn = this.clsColumn.replace("hidden", "");}

                view[i] = {
                    "index": i,
                    "index-view": i,
                    "show": !Utils.isValue(this.show) ? true : this.show,
                    "size": Utils.isValue(this.size) ? this.size : ""
                }
            });

            this._fireEvent("view-created", {
                view: view
            });

            return view;
        },

        _createInspectorItems: function(table){
            var that = this, o = this.options;
            var j, tds = [], row;
            var cells = this.heads;

            table.html("");

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(i){
                row = $("<tr>");
                row.data('index', i);
                row.data('index-view', i);
                $("<td>").html("<input type='checkbox' data-style='"+o.checkStyle+"' data-role='checkbox' name='column_show_check[]' value='"+i+"' "+(Utils.bool(that.view[i]['show']) ? "checked" : "")+">").appendTo(row);
                $("<td>").html(this.title).appendTo(row);
                $("<td>").html("<input type='number' data-role='spinner' name='column_size' value='"+that.view[i]['size']+"' data-index='"+i+"'>").appendTo(row);
                $("<td>").html("" +
                    "<button class='button square js-table-inspector-field-up' type='button'><span class='mif-arrow-up'></span></button>" +
                    "<button class='button square js-table-inspector-field-down' type='button'><span class='mif-arrow-down'></span></button>" +
                    "").appendTo(row);
                tds[that.view[i]['index-view']] = row;
            });

            //
            for (j = 0; j < cells.length; j++){
                tds[j].appendTo(table);
            }
        },

        _createInspector: function(){
            var o = this.options;
            var inspector, table_wrap, table, tbody, actions;

            inspector = $("<div data-role='draggable' data-drag-element='.table-inspector-header' data-drag-area='body'>").addClass("table-inspector");
            inspector.attr("for", this.element.attr("id"));

            $("<div class='table-inspector-header'>"+o.inspectorTitle+"</div>").appendTo(inspector);

            table_wrap = $("<div>").addClass("table-wrap").appendTo(inspector);

            table = $("<table>").addClass("table subcompact");
            tbody = $("<tbody>").appendTo(table);

            table.appendTo(table_wrap);

            this._createInspectorItems(tbody);

            actions = $("<div class='table-inspector-actions'>").appendTo(inspector);
            $("<button class='button primary js-table-inspector-save' type='button'>").html(this.locale.buttons.save).appendTo(actions);
            $("<button class='button secondary js-table-inspector-reset ml-2 mr-2' type='button'>").html(this.locale.buttons.reset).appendTo(actions);
            $("<button class='button link js-table-inspector-cancel place-right' type='button'>").html(this.locale.buttons.cancel).appendTo(actions);

            inspector.data("open", false);
            this.inspector = inspector;

            $("body").append(inspector);

            this._createInspectorEvents();
        },

        _resetInspector: function(){
            var inspector = this.inspector;
            var table = inspector.find("table tbody");
            this._createInspectorItems(table);
            this._createInspectorEvents();
        },

        _createHeadsFromHTML: function(){
            var that = this, element = this.element;
            var head = element.find("thead");

            if (head.length > 0) $.each(head.find("tr > *"), function(){
                var item = $(this);
                var dir, head_item, item_class;

                if (Utils.isValue(item.data('sort-dir'))) {
                    dir = item.data('sort-dir');
                } else {
                    if (item.hasClass("sort-asc")) {
                        dir = "asc";
                    } else if (item.hasClass("sort-desc")) {
                        dir = "desc"
                    } else {
                        dir = undefined;
                    }
                }

                item_class = item[0].className.replace("sortable-column", "");
                item_class = item_class.replace("sort-asc", "");
                item_class = item_class.replace("sort-desc", "");
                item_class = item_class.replace("hidden", "");

                head_item = {
                    type: "data",
                    title: item.html(),
                    name: Utils.isValue(item.data("name")) ? item.data("name") : item.text().replace(" ", "_"),
                    sortable: item.hasClass("sortable-column") || (Utils.isValue(item.data('sortable')) && JSON.parse(item.data('sortable') === true)),
                    sortDir: dir,
                    format: Utils.isValue(item.data("format")) ? item.data("format") : "string",
                    formatMask: Utils.isValue(item.data("format-mask")) ? item.data("format-mask") : null,
                    clsColumn: Utils.isValue(item.data("cls-column")) ? item.data("cls-column") : "",
                    cls: item_class,
                    colspan: item.attr("colspan"),
                    size: Utils.isValue(item.data("size")) ? item.data("size") : "",
                    show: !(item.hasClass("hidden") || (Utils.isValue(item.data('show')) && JSON.parse(item.data('show')) === false)),

                    required: Utils.isValue(item.data("required")) ? JSON.parse(item.data("required")) === true  : false,
                    field: Utils.isValue(item.data("field")) ? item.data("field") : "input",
                    fieldType: Utils.isValue(item.data("field-type")) ? item.data("field-type") : "text",
                    validator: Utils.isValue(item.data("validator")) ? item.data("validator") : null,

                    template: Utils.isValue(item.data("template")) ? item.data("template") : null
                };
                that.heads.push(head_item);
            });
        },

        _createFootsFromHTML: function(){
            var that = this, element = this.element;
            var foot = element.find("tfoot");

            if (foot.length > 0) $.each(foot.find("tr > *"), function(){
                var item = $(this);
                var foot_item;

                foot_item = {
                    title: item.html(),
                    name: Utils.isValue(item.data("name")) ? item.data("name") : false,
                    cls: item[0].className,
                    colspan: item.attr("colspan")
                };

                that.foots.push(foot_item);
            });
        },

        _createItemsFromHTML: function(){
            var that = this, element = this.element;
            var body = element.find("tbody");

            if (body.length > 0) $.each(body.find("tr"), function(){
                var row = $(this);
                var tr = [];
                $.each(row.children("td"), function(){
                    var td = $(this);
                    tr.push(td.html());
                });
                that.items.push(tr);
            });

            this._createHeadsFromHTML();
            this._createFootsFromHTML();
        },

        _createItemsFromJSON: function(source){
            var that = this;

            if (typeof source === "string") {
                source = JSON.parse(source);
            }

            if (source.header !== undefined) {
                that.heads = source.header;
            } else {
                this._createHeadsFromHTML();
            }

            if (source.data !== undefined) {
                $.each(source.data, function(){
                    var row = this;
                    var tr = [];
                    $.each(row, function(){
                        var td = this;
                        tr.push(td);
                    });
                    that.items.push(tr);
                });
            }

            if (source.footer !== undefined) {
                this.foots = source.footer;
            } else {
                this._createFootsFromHTML();
            }
        },

        _createTableHeader: function(){
            var element = this.element, o = this.options;
            var head = $("<thead>").html('');
            var tr, th, tds = [], j, cells;
            var view = o.staticView ? this._createView() : this.view;

            element.find("thead").remove();

            head.addClass(o.clsHead);

            if (this.heads.length === 0) {
                return head;
            }

            tr = $("<tr>").addClass(o.clsHeadRow).appendTo(head);

            $.each(this.service, function(){
                var item = this, classes = [];
                th = $("<th>").appendTo(tr);
                if (Utils.isValue(item.title)) {th.html(item.title);}
                if (Utils.isValue(item.size)) {th.css({width: item.size});}
                if (Utils.isValue(item.cls)) {classes.push(item.cls);}
                classes.push(o.clsHeadCell);
                th.addClass(classes.join(" "));
            });

            cells = this.heads;

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(cell_index){
                var item = this;
                var classes = [];

                th = $("<th>");
                th.data("index", cell_index);

                if (Utils.isValue(item.title)) {th.html(item.title);}
                if (Utils.isValue(item.format)) {th.attr("data-format", item.format);}
                if (Utils.isValue(item.name)) {th.attr("data-name", item.name);}
                if (Utils.isValue(item.colspan)) {th.attr("colspan", item.colspan);}
                if (Utils.isValue(view[cell_index]['size'])) {th.css({width: view[cell_index]['size']});}
                if (item.sortable === true) {
                    classes.push("sortable-column");

                    if (Utils.isValue(item.sortDir)) {
                        classes.push("sort-" + item.sortDir);
                    }
                }
                if (Utils.isValue(item.cls)) {
                    $.each(item.cls.toArray(), function () {
                        classes.push(this);
                    });
                }
                if (Utils.bool(view[cell_index]['show']) === false) {
                    if (classes.indexOf('hidden') === -1) classes.push("hidden");
                }

                classes.push(o.clsHeadCell);

                if (Utils.bool(view[cell_index]['show'])) {
                    Utils.arrayDelete(classes, "hidden");
                }

                th.addClass(classes.join(" "));

                tds[view[cell_index]['index-view']] = th;
            });

            for (j = 0; j < cells.length; j++){
                tds[j].appendTo(tr);
            }

            element.prepend(head);
        },

        _createTableBody: function(){
            var body, head, element = this.element;

            head  = element.find("thead");
            element.find("tbody").remove();
            body = $("<tbody>").addClass(this.options.clsBody);
            body.insertAfter(head);
        },

        _createTableFooter: function(){
            var element = this.element, o = this.options;
            var foot = $("<tfoot>").addClass(o.clsFooter);
            var tr, th;

            element.find("tfoot").remove();

            if (this.foots.length === 0) {
                element.append(foot);
                return;
            }

            tr = $("<tr>").addClass(o.clsHeadRow).appendTo(foot);
            $.each(this.foots, function(){
                var item = this;
                th = $("<th>").appendTo(tr);

                if (item.title !== undefined) {
                    th.html(item.title);
                }

                if (item.name !== undefined) {
                    th.addClass("foot-column-name-" + item.name);
                }

                if (item.cls !== undefined) {
                    th.addClass(item.cls);
                }

                if (Utils.isValue(item.colspan)) {
                    th.attr("colspan", item.colspan);
                }

                th.appendTo(tr);
            });

            element.append(foot);
        },

        _createTopBlock: function (){
            var that = this, element = this.element, o = this.options;
            var top_block = $("<div>").addClass("table-top").addClass(o.clsTableTop).insertBefore(element.parent());
            var search_block, search_input, rows_block, rows_select;

            search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $("<div>").addClass("table-search-block").addClass(o.clsSearch).appendTo(top_block);
            search_block.addClass(o.clsSearch);

            search_input = $("<input>").attr("type", "text").appendTo(search_block);
            Metro.makePlugin(search_input, "input", {
                prepend: o.tableSearchTitle
            });

            if (o.showSearch !== true) {
                search_block.hide();
            }

            rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $("<div>").addClass("table-rows-block").appendTo(top_block);
            rows_block.addClass(o.clsRowsCount);

            rows_select = $("<select>").appendTo(rows_block);
            $.each(o.rowsSteps.toArray(), function () {
                var val = parseInt(this);
                var option = $("<option>").attr("value", val).text(val === -1 ? o.allRecordsTitle : val).appendTo(rows_select);
                if (val === parseInt(o.rows)) {
                    option.attr("selected", "selected");
                }
            });
            Metro.makePlugin(rows_select, "select",{
                filter: false,
                prepend: o.tableRowsCountTitle,
                onChange: function (val) {
                    val = parseInt(val);
                    if (val === parseInt(o.rows)) {
                        return;
                    }
                    o.rows = val;
                    that.currentPage = 1;
                    that._draw();

                    that._fireEvent("rows-count-change", {
                        val: val
                    });
                }
            });

            if (o.showRowsSteps !== true) {
                rows_block.hide();
            }

            return top_block;
        },

        _createBottomBlock: function (){
            var element = this.element, o = this.options;
            var bottom_block = $("<div>").addClass("table-bottom").addClass(o.clsTableBottom).insertAfter(element.parent());
            var info, pagination, skip;

            info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : $("<div>").addClass("table-info").appendTo(bottom_block);
            info.addClass(o.clsTableInfo);
            if (o.showTableInfo !== true) {
                info.hide();
            }

            pagination = Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : $("<div>").addClass("table-pagination").appendTo(bottom_block);
            pagination.addClass(o.clsTablePagination);
            if (o.showPagination !== true) {
                pagination.hide();
            }

            skip = Utils.isValue(this.wrapperSkip) ? this.wrapperSkip : $("<div>").addClass("table-skip").appendTo(bottom_block);
            skip.addClass(o.clsTableSkip);

            $("<input type='text'>").addClass("input table-skip-input").addClass(o.clsTableSkipInput).appendTo(skip);
            $("<button>").addClass("button table-skip-button").addClass(o.clsTableSkipButton).html(o.tableSkipTitle).appendTo(skip);

            if (o.showSkip !== true) {
                skip.hide();
            }

            return bottom_block;
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var columns;
            var w_search = $(o.searchWrapper),
                w_info = $(o.infoWrapper),
                w_rows = $(o.rowsWrapper),
                w_paging = $(o.paginationWrapper),
                w_skip = $(o.skipWrapper);

            if (w_search.length > 0) {this.wrapperSearch = w_search;}
            if (w_info.length > 0) {this.wrapperInfo = w_info;}
            if (w_rows.length > 0) {this.wrapperRows = w_rows;}
            if (w_paging.length > 0) {this.wrapperPagination = w_paging;}
            if (w_skip.length > 0) {this.wrapperSkip = w_skip;}

            element.html("").addClass(o.clsTable);

            this._createTableHeader();
            this._createTableBody();
            this._createTableFooter();

            this._createTopBlock();
            this._createBottomBlock();

            var need_sort = false;
            if (this.heads.length > 0) $.each(this.heads, function(i){
                var item = this;
                if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
                    need_sort = true;
                    that.sort.colIndex = i;
                    that.sort.dir = item.sortDir;
                }
            });

            if (need_sort) {
                columns = element.find("thead th");
                this._resetSortClass(columns);
                $(columns.get(this.sort.colIndex + that.service.length)).addClass("sort-"+this.sort.dir);
                this.sorting();
            }

            var filter_func;

            if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                $.each(o.filters.toArray(), function(){
                    filter_func = Utils.isFunc(this);
                    if (filter_func !== false) {
                        that.filtersIndexes.push(that.addFilter(filter_func));
                    }
                });
            }

            this.currentPage = 1;

            this._draw();
        },

        _resetSortClass: function(el){
            $(el).removeClass("sort-asc sort-desc");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var component = element.closest(".table-component");
            var table_container = component.find(".table-container");
            var search = component.find(".table-search-block input");
            var skip_button = o.skipWrapper ? $(o.skipWrapper).find('.table-skip-button') : component.find(".table-skip-button");
            var skip_input = o.skipWrapper ? $(o.skipWrapper).find('.table-skip-input') : component.find(".table-skip-input");
            var customSearch;
            var id = element.attr("id");

            skip_button.on(Metro.events.click, function(){
                var skipTo = parseInt(skip_input.val().trim());

                if (isNaN(skipTo) || skipTo <=0 || skipTo > that.pagesCount) {
                    skip_input.val('');
                    return false;
                }

                skip_input.val('');

                that._fireEvent("skip", {
                    skipTo: skipTo,
                    skipFrom: that.currentPage
                });

                that.page(skipTo);
            });

            $(window).on(Metro.events.resize, function(){
                if (o.horizontalScroll === true) {
                    if (!Utils.isNull(o.horizontalScrollStop) && Utils.mediaExist(o.horizontalScrollStop)) {
                        table_container.removeClass("horizontal-scroll");
                    } else {
                        table_container.addClass("horizontal-scroll");
                    }
                }
            }, {ns: this.id});

            element.on(Metro.events.click, ".sortable-column", function(){

                if (o.muteTable === true) element.addClass("disabled");

                if (that.busy) {
                    return false;
                }
                that.busy = true;

                var col = $(this);

                that.activity.show(function(){
                    setImmediate(function(){
                        that.currentPage = 1;
                        that.sort.colIndex = col.data("index");
                        if (!col.hasClass("sort-asc") && !col.hasClass("sort-desc")) {
                            that.sort.dir = o.sortDir;
                        } else {
                            if (col.hasClass("sort-asc")) {
                                that.sort.dir = "desc";
                            } else {
                                that.sort.dir = "asc";
                            }
                        }
                        that._resetSortClass(element.find(".sortable-column"));
                        col.addClass("sort-"+that.sort.dir);
                        that.sorting();
                        that._draw(function(){
                            that.busy = false;
                            if (o.muteTable === true) element.removeClass("disabled");
                        });
                    });
                });
            });

            element.on(Metro.events.click, ".table-service-check input", function(){
                var check = $(this);
                var status = check.is(":checked");
                var val = ""+check.val();
                var store_key = o.checkStoreKey.replace("$1", id);
                var storage = Metro.storage;
                var data = storage.getItem(store_key);
                var is_radio = check.attr('type') === 'radio';

                if (is_radio) {
                    data = [];
                }

                if (status) {
                    if (!Utils.isValue(data)) {
                        data = [val];
                    } else {
                        if (Array(data).indexOf(val) === -1) {
                            data.push(val);
                        }
                    }
                } else {
                    if (Utils.isValue(data)) {
                        Utils.arrayDelete(data, val);
                    } else {
                        data = [];
                    }
                }

                storage.setItem(store_key, data);

                that._fireEvent("check-click", {
                    check: this,
                    status: status,
                    data: data
                });
            });

            element.on(Metro.events.click, ".table-service-check-all input", function(){
                var status = $(this).is(":checked");
                var store_key = o.checkStoreKey.replace("$1", id);
                var data = [];
                var storage = Metro.storage;

                if (status) {
                    $.each(that.filteredItems, function(){
                        if (data.indexOf(this[o.checkColIndex]) !== -1) return ;
                        data.push(""+this[o.checkColIndex]);
                    });
                } else {
                    data = [];
                }

                storage.setItem(store_key, data);

                that._draw();

                that._fireEvent("check-click-all", {
                    check: this,
                    status: status,
                    data: data
                });
            });

            var _search = function(){
                that.searchString = this.value.trim().toLowerCase();

                clearInterval(that.input_interval); that.input_interval = false;
                if (!that.input_interval) that.input_interval = setTimeout(function(){
                    that.currentPage = 1;
                    that._draw();
                    clearInterval(that.input_interval); that.input_interval = false;
                }, o.searchThreshold);
            };

            search.on(Metro.events.inputchange, _search);

            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.on(Metro.events.inputchange, _search);
                }
            }

            function pageLinkClick(l){
                var link = $(l);
                var item = link.parent();
                if (that.filteredItems.length === 0) {
                    return ;
                }

                if (item.hasClass("active")) {
                    return ;
                }

                if (item.hasClass("service")) {
                    if (link.data("page") === "prev") {
                        that.currentPage--;
                        if (that.currentPage === 0) {
                            that.currentPage = 1;
                        }
                    } else {
                        that.currentPage++;
                        if (that.currentPage > that.pagesCount) {
                            that.currentPage = that.pagesCount;
                        }
                    }
                } else {
                    that.currentPage = link.data("page");
                }

                that._draw();
            }

            component.on(Metro.events.click, ".pagination .page-link", function(){
                pageLinkClick(this)
            });

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.on(Metro.events.click, ".pagination .page-link", function(){
                    pageLinkClick(this)
                });
            }

            this._createInspectorEvents();

            element.on(Metro.events.click, ".js-table-crud-button", function(){

            });
        },

        _createInspectorEvents: function(){
            var that = this, inspector = this.inspector;
            // Inspector event

            this._removeInspectorEvents();

            inspector.on(Metro.events.click, ".js-table-inspector-field-up", function(){
                var button = $(this), tr = button.closest("tr");
                var tr_prev = tr.prev("tr");
                var index = tr.data("index");
                var index_view;
                if (tr_prev.length === 0) {
                    return ;
                }
                tr.insertBefore(tr_prev);
                tr.addClass("flash");
                setTimeout(function(){
                    tr.removeClass("flash");
                }, 1000);
                index_view = tr.index();

                tr.data("index-view", index_view);
                that.view[index]['index-view'] = index_view;

                $.each(tr.nextAll(), function(){
                    var t = $(this);
                    index_view++;
                    t.data("index-view", index_view);
                    that.view[t.data("index")]['index-view'] = index_view;
                });

                that._createTableHeader();
                that._draw();
            });

            inspector.on(Metro.events.click, ".js-table-inspector-field-down", function(){
                var button = $(this), tr = button.closest("tr");
                var tr_next = tr.next("tr");
                var index = tr.data("index");
                var index_view;
                if (tr_next.length === 0) {
                    return ;
                }
                tr.insertAfter(tr_next);
                tr.addClass("flash");
                setTimeout(function(){
                    tr.removeClass("flash");
                }, 1000);
                index_view = tr.index();

                tr.data("index-view", index_view);
                that.view[index]['index-view'] = index_view;

                $.each(tr.prevAll(), function(){
                    var t = $(this);
                    index_view--;
                    t.data("index-view", index_view);
                    that.view[t.data("index")]['index-view'] = index_view;
                });

                that._createTableHeader();
                that._draw();
            });

            inspector.on(Metro.events.click, "input[type=checkbox]", function(){
                var check = $(this);
                var status = check.is(":checked");
                var index = check.val();
                var op = ['cls', 'clsColumn'];

                if (status) {
                    $.each(op, function(){
                        var a;
                        a = Utils.isValue(that.heads[index][this]) ? (that.heads[index][this]).toArray(" ") : [];
                        Utils.arrayDelete(a, "hidden");
                        that.heads[index][this] = a.join(" ");
                        that.view[index]['show'] = true;
                    });
                } else {
                    $.each(op, function(){
                        var a;

                        a = Utils.isValue(that.heads[index][this]) ? (that.heads[index][this]).toArray(" ") : [];
                        if (a.indexOf("hidden") === -1) {
                            a.push("hidden");
                        }
                        that.heads[index][this] = a.join(" ");
                        that.view[index]['show'] = false;
                    });
                }

                that._createTableHeader();
                that._draw();
            });

            inspector.find("input[type=number]").on(Metro.events.inputchange, function(){
                var input = $(this);
                var index = input.attr("data-index");
                var val = parseInt(input.val());

                that.view[index]['size'] = val === 0 ? "" : val;

                that._createTableHeader();
            });

            inspector.on(Metro.events.click, ".js-table-inspector-save", function(){
                that._saveTableView();
                that.openInspector(false);
            });

            inspector.on(Metro.events.click, ".js-table-inspector-cancel", function(){
                that.openInspector(false);
            });

            inspector.on(Metro.events.click, ".js-table-inspector-reset", function(){
                that.resetView();
            });
        },

        _removeInspectorEvents: function(){
            var inspector = this.inspector;
            inspector.off(Metro.events.click, ".js-table-inspector-field-up");
            inspector.off(Metro.events.click, ".js-table-inspector-field-down");
            inspector.off(Metro.events.click, "input[type=checkbox]");
            inspector.off(Metro.events.click, ".js-table-inspector-save");
            inspector.off(Metro.events.click, ".js-table-inspector-cancel");
            inspector.off(Metro.events.click, ".js-table-inspector-reset");
            inspector.find("input[type=number]").off(Metro.events.inputchange);
        },

        _saveTableView: function(){
            var that = this, element = this.element, o = this.options;
            var view = this.view;
            var id = element.attr("id");
            var viewPath = o.viewSavePath.replace("$1", id);
            var storage = Metro.storage;

            if (o.viewSaveMode.toLowerCase() === "client") {
                storage.setItem(viewPath, view);

                this._fireEvent("view-save", {
                    target: "client",
                    path: o.viewSavePath,
                    view: view
                });
            } else {
                var post_data = {
                    id : element.attr("id"),
                    view : view
                };
                $.post(viewPath, post_data)
                    .then(function(data){

                        that._fireEvent("view-save", {
                            target: "server",
                            path: o.viewSavePath,
                            view: view,
                            post_data: post_data,
                            response: data
                        });

                    }, function(xhr){

                        that._fireEvent("data-save-error", {
                            source: o.viewSavePath,
                            xhr: xhr,
                            post_data: post_data
                        });

                    });
            }
        },

        _info: function(start, stop, length){
            var element = this.element, o = this.options;
            var component = element.closest(".table-component");
            var info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".table-info");
            var text;

            if (info.length === 0) {
                return ;
            }

            if (stop > length) {
                stop = length;
            }

            if (this.items.length === 0) {
                start = stop = length = 0;
            }

            text = o.tableInfoTitle;
            text = text.replace("$1", start);
            text = text.replace("$2", stop);
            text = text.replace("$3", length);
            info.html(text);
        },

        _paging: function(length){
            var element = this.element, o = this.options;
            var component = element.closest(".table-component");
            this.pagesCount = Math.ceil(length / o.rows); // Костыль
            Metro.pagination({
                length: length,
                rows: o.rows,
                current: this.currentPage,
                target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".table-pagination"),
                claPagination: o.clsPagination,
                prevTitle: o.paginationPrevTitle,
                nextTitle: o.paginationNextTitle,
                distance: o.paginationShortMode === true ? o.paginationDistance : 0
            });
        },

        _filter: function(){
            var that = this, o = this.options;
            var items;
            if ((Utils.isValue(this.searchString) && that.searchString.length >= o.searchMinLength) || this.filters.length > 0) {
                items = this.items.filter(function(row){

                    var row_data = "", result, search_result, i, j = 0;

                    if (that.filters.length > 0) {

                        result = o.filtersOperator.toLowerCase() === "and";
                        for (i = 0; i < that.filters.length; i++) {
                            if (Utils.isNull(that.filters[i])) continue;
                            j++;
                            result = o.filtersOperator.toLowerCase() === "and" ?
                                result && Utils.exec(that.filters[i], [row, that.heads]) :
                                result || Utils.exec(that.filters[i], [row, that.heads])
                            ;
                        }

                        if (j === 0) result = true;
                    } else {
                        result = true;
                    }

                    if (that.searchFields.length > 0) {
                        $.each(that.heads, function(i, v){
                            if (that.searchFields.indexOf(v.name) > -1) {
                                row_data += "•"+row[i];
                            }
                        })
                    } else {
                        row_data = row.join("•");
                    }

                    row_data = row_data.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim().toLowerCase();
                    search_result = Utils.isValue(that.searchString) && that.searchString.length >= o.searchMinLength ? ~row_data.indexOf(that.searchString) : true;

                    result = result && search_result;

                    if (result) {
                        that._fireEvent("filter-row-accepted", {
                            row: row
                        });
                    } else {
                        that._fireEvent("filter-row-declined", {
                            row: row
                        });
                    }

                    return result;
                });

            } else {
                items = this.items;
            }

            this._fireEvent("search", {
                search: that.searchString,
                items: items
            });

            this.filteredItems = items;

            return items;
        },

        _draw: function(cb){
            var that = this, element = this.element, o = this.options;
            var body = element.find("tbody");
            var i, j, tr, td, check, cells, tds, is_even_row;
            var start = parseInt(o.rows) === -1 ? 0 : o.rows * (this.currentPage - 1),
                stop = parseInt(o.rows) === -1 ? this.items.length - 1 : start + o.rows - 1;
            var items;
            var stored_keys = Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr('id')));

            var view = o.staticView ? this.viewDefault : this.view;

            body.html("");

            if (!this.heads.length) {
                console.warn("Heads is not defined for table ID " + element.attr("id"));
                return ;
            }

            items = this._filter();

            if (items.length > 0) {
                for (i = start; i <= stop; i++) {
                    cells = items[i];
                    tds = [];
                    if (!Utils.isValue(cells)) {continue;}
                    tr = $("<tr>").addClass(o.clsBodyRow);
                    tr.data('original', cells);

                    // Rownum

                    is_even_row = i % 2 === 0;

                    td = $("<td>").html(i + 1);
                    if (that.service[0].clsColumn !== undefined) {
                        td.addClass(that.service[0].clsColumn);
                    }
                    td.appendTo(tr);

                    // Checkbox
                    td = $("<td>");
                    if (o.checkType === "checkbox") {
                        check = $("<input type='checkbox' data-style='"+o.checkStyle+"' data-role='checkbox' name='" + (Utils.isValue(o.checkName) ? o.checkName : 'table_row_check') + "[]' value='" + items[i][o.checkColIndex] + "'>");
                    } else {
                        check = $("<input type='radio' data-style='"+o.checkStyle+"' data-role='radio' name='" + (Utils.isValue(o.checkName) ? o.checkName : 'table_row_check') + "' value='" + items[i][o.checkColIndex] + "'>");
                    }

                    if (Utils.isValue(stored_keys) && Array.isArray(stored_keys) && stored_keys.indexOf(""+items[i][o.checkColIndex]) > -1) {
                        check.prop("checked", true);
                    }

                    check.addClass("table-service-check");

                    this._fireEvent("check-draw", {
                        check: check
                    });

                    check.appendTo(td);
                    if (that.service[1].clsColumn !== undefined) {
                        td.addClass(that.service[1].clsColumn);
                    }
                    td.appendTo(tr);

                    for (j = 0; j < cells.length; j++){
                        tds[j] = null;
                    }

                    $.each(cells, function(cell_index){
                        var val = this;
                        var td = $("<td>");

                        if (Utils.isValue(that.heads[cell_index].template)) {
                            val = that.heads[cell_index].template.replace(/%VAL%/g, val);
                        }

                        td.html(val);

                        td.addClass(o.clsBodyCell);
                        if (Utils.isValue(that.heads[cell_index].clsColumn)) {
                            td.addClass(that.heads[cell_index].clsColumn);
                        }

                        if (Utils.bool(view[cell_index].show) === false) {
                            td.addClass("hidden");
                        }

                        if (Utils.bool(view[cell_index].show)) {
                            td.removeClass("hidden");
                        }

                        td.data('original',this);

                        tds[view[cell_index]['index-view']] = td;

                        that._fireEvent("draw-cell", {
                            td: td,
                            val: val,
                            cellIndex: cell_index,
                            head: that.heads[cell_index],
                            items: cells
                        });

                        if (o.cellWrapper === true) {
                            val = $("<div>").addClass("data-wrapper").addClass(o.clsCellWrapper).html(td.html());
                            td.html('').append(val);
                        }
                    });

                    for (j = 0; j < cells.length; j++){
                        tds[j].appendTo(tr);

                        that._fireEvent("append-cell", {
                            td: tds[j],
                            tr: tr,
                            index: j
                        });
                    }

                    that._fireEvent("draw-row", {
                        tr: tr,
                        view: that.view,
                        heads: that.heads,
                        items: cells
                    });

                    tr.addClass(o.clsRow).addClass(is_even_row ? o.clsEvenRow : o.clsOddRow).appendTo(body);

                    that._fireEvent("append-row", {
                        tr: tr
                    });
                }

            } else {
                j = 0;
                $.each(view, function(){
                    if (this.show) j++;
                });
                if (o.check === true) {
                    j++;
                }
                if (o.rownum === true) {
                    j++;
                }
                tr = $("<tr>").addClass(o.clsBodyRow).appendTo(body);
                td = $("<td>").attr("colspan", j).addClass("text-center").html($("<span>").addClass(o.clsEmptyTableTitle).html(o.emptyTableTitle));
                td.appendTo(tr);
            }

            this._info(start + 1, stop + 1, items.length);
            this._paging(items.length);

            if (this.activity) this.activity.hide();

            this._fireEvent("draw");

            if (cb !== undefined) {
                Utils.exec(cb, null, element[0])
            }
        },

        _getItemContent: function(row){
            var o = this.options;
            var result, col = row[this.sort.colIndex];
            var format = this.heads[this.sort.colIndex].format;
            var formatMask = !Utils.isNull(this.heads) && !Utils.isNull(this.heads[this.sort.colIndex]) && Utils.isValue(this.heads[this.sort.colIndex]['formatMask']) ? this.heads[this.sort.colIndex]['formatMask'] : "%Y-%m-%d";
            var thousandSeparator = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["thousandSeparator"] ? this.heads[this.sort.colIndex]["thousandSeparator"] : o.thousandSeparator;
            var decimalSeparator  = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["decimalSeparator"] ? this.heads[this.sort.colIndex]["decimalSeparator"] : o.decimalSeparator;

            result = (""+col).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(result) && Utils.isValue(format)) {

                if (['number', 'int', 'float', 'money'].indexOf(format) !== -1) {
                    result = Utils.parseNumber(result, thousandSeparator, decimalSeparator);
                }

                switch (format) {
                    case "date": result = Utils.isValue(formatMask) ? result.toDate(formatMask) : new Date(result); break;
                    case "number": result = Number(result); break;
                    case "int": result = parseInt(result); break;
                    case "float": result = parseFloat(result); break;
                    case "money": result = Utils.parseMoney(result); break;
                    case "card": result = Utils.parseCard(result); break;
                    case "phone": result = Utils.parsePhone(result); break;
                }
            }

            return result;
        },

        addItem: function(item, redraw){
            if (!Array.isArray(item)) {
                console.warn("Item is not an array and can't be added");
                return this;
            }
            this.items.push(item);
            if (redraw !== false) this.draw();
        },

        addItems: function(items, redraw){
            if (!Array.isArray(items)) {
                console.warn("Items is not an array and can't be added");
                return this;
            }
            items.forEach(function(item){
                if (Array.isArray(item))
                    this.items.push(item, false);
            });
            this.draw();
            if (redraw !== false) this.draw();
        },

        updateItem: function(key, field, value){
            var item = this.items[this.index[key]];
            var fieldIndex = null;
            if (Utils.isNull(item)) {
                console.warn('Item is undefined for update');
                return this;
            }
            if (isNaN(field)) {
                this.heads.forEach(function(v, i){
                    if (v['name'] === field) {
                        fieldIndex = i;
                    }
                });
            }
            if (Utils.isNull(fieldIndex)) {
                console.warn('Item is undefined for update. Field ' + field + ' not found in data structure');
                return this;
            }

            item[fieldIndex] = value;
            this.items[this.index[key]] = item;
            return this;
        },

        getItem: function(key){
            return this.items[this.index[key]];
        },

        deleteItem: function(fieldIndex, value){
            var i, deleteIndexes = [];
            var is_func = Utils.isFunc(value);
            for(i = 0; i < this.items.length; i++) {
                if (is_func) {
                    if (Utils.exec(value, [this.items[i][fieldIndex]])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (this.items[i][fieldIndex] === value) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        deleteItemByName: function(fieldName, value){
            var i, fieldIndex, deleteIndexes = [];
            var is_func = Utils.isFunc(value);

            for(i = 0; i < this.heads.length; i++) {
                if (this.heads[i]['name'] === fieldName) {
                    fieldIndex = i;
                    break;
                }
            }

            for(i = 0; i < this.items.length; i++) {
                if (is_func) {
                    if (Utils.exec(value, [this.items[i][fieldIndex]])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (this.items[i][fieldIndex] === value) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        draw: function(){
            this._draw();
            return this;
        },

        sorting: function(dir){
            var that = this;

            if (Utils.isValue(dir)) {
                this.sort.dir = dir;
            }

            this._fireEvent("sort-start", {
                items: this.items
            });

            this.items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2) {
                    result = that.sort.dir === "asc" ? -1 : 1;
                }
                if (c1 > c2) {
                    result = that.sort.dir === "asc" ? 1 : -1;
                }

                if (result !== 0) {

                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            this._fireEvent("sort-stop", {
                items: this.items
            });

            return this;
        },

        search: function(val){
            this.searchString = val.trim().toLowerCase();
            this.currentPage = 1;
            this._draw();
            return this;
        },

        _rebuild: function(review){
            var that = this, element = this.element;
            var need_sort = false, sortable_columns;

            this._createIndex();

            if (review === true) {
                this.view = this._createView();
            }

            this._createTableHeader();
            this._createTableBody();
            this._createTableFooter();

            if (this.heads.length > 0) $.each(this.heads, function(i){
                var item = this;
                if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
                    need_sort = true;
                    that.sort.colIndex = i;
                    that.sort.dir = item.sortDir;
                }
            });

            if (need_sort) {
                sortable_columns = element.find(".sortable-column");
                this._resetSortClass(sortable_columns);
                $(sortable_columns.get(that.sort.colIndex)).addClass("sort-"+that.sort.dir);
                this.sorting();
            }

            that.currentPage = 1;

            that._draw();
        },

        setHeads: function(data){
            this.heads = data;
            return this;
        },

        setHeadItem: function(name, data){
            var i, index;
            for(i = 0; i < this.heads.length; i++) {
                if (this.heads[i].name === name) {
                    index = i;
                    break;
                }
            }
            this.heads[index] = data;
            return this;
        },

        setItems: function(data){
            this.items = data;
            return this;
        },

        setData: function(/*obj*/ data){
            var o = this.options;

            this.items = [];
            this.heads = [];
            this.foots = [];

            if (Array.isArray(o.head)) {
                this.heads = o.head;
            }

            if (Array.isArray(o.body)) {
                this.items = o.body;
            }

            this._createItemsFromJSON(data);

            this._rebuild(true);

            return this;
        },

        loadData: function(source, review){
            var that = this, element = this.element, o = this.options;

            if (!Utils.isValue(review)) {
                review = true;
            }

            element.html("");

            if (!Utils.isValue(source)) {

                this._rebuild(review);

            } else {
                o.source = source;

                this._fireEvent("data-load", {
                    source: o.source
                });

                that.activity.show(function(){
                    $.json(o.source).then(function(data){
                        that.activity.hide();
                        that.items = [];
                        that.heads = [];
                        that.foots = [];

                        that._fireEvent("data-loaded", {
                            source: o.source,
                            data: data
                        });

                        if (Array.isArray(o.head)) {
                            that.heads = o.head;
                        }

                        if (Array.isArray(o.body)) {
                            that.items = o.body;
                        }

                        that._createItemsFromJSON(data);
                        that._rebuild(review);
                    }, function(xhr){
                        that.activity.hide();
                        that._fireEvent("data-load-error", {
                            source: o.source,
                            xhr: xhr
                        });
                    });
                });

            }
        },

        reload: function(review){
            this.loadData(this.options.source, review);
        },

        clear: function(){
            this.items = [];
            return this.draw();
        },

        next: function(){
            if (this.items.length === 0) return ;
            this.currentPage++;
            if (this.currentPage > this.pagesCount) {
                this.currentPage = this.pagesCount;
                return ;
            }
            this._draw();
            return this;
        },

        prev: function(){
            if (this.items.length === 0) return ;
            this.currentPage--;
            if (this.currentPage === 0) {
                this.currentPage = 1;
                return ;
            }
            this._draw();
            return this;
        },

        first: function(){
            if (this.items.length === 0) return ;
            this.currentPage = 1;
            this._draw();
            return this;
        },

        last: function(){
            if (this.items.length === 0) return ;
            this.currentPage = this.pagesCount;
            this._draw();
            return this;
        },

        page: function(num){
            if (num <= 0) {
                num = 1;
            }

            if (num > this.pagesCount) {
                num = this.pagesCount;
            }

            this.currentPage = num;
            this._draw();
            return this;
        },

        addFilter: function(f, redraw){
            var filterIndex = null, i, func = Utils.isFunc(f);
            if (func === false) {
                return ;
            }

            for(i = 0; i < this.filters.length; i++) {
                if (Utils.isNull(this.filters[i])) {
                    filterIndex = i;
                    this.filters[i] = func;
                    break;
                }
            }

            if (Utils.isNull(filterIndex)) {
                this.filters.push(func);
                filterIndex = this.filters.length - 1;
            }

            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }

            return filterIndex
        },

        removeFilter: function(key, redraw){
            this.filters[key] = null;
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        removeFilters: function(redraw){
            this.filters = [];
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        getItems: function(){
            return this.items;
        },

        getHeads: function(){
            return this.heads;
        },

        getView: function(){
            return this.view;
        },

        getFilteredItems: function(){
            return this.filteredItems.length > 0 ? this.filteredItems : this.items;
        },

        getSelectedItems: function(){
            var element = this.element, o = this.options;
            var stored_keys = Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr("id")));
            var selected = [];

            if (!Utils.isValue(stored_keys)) {
                return [];
            }

            $.each(this.items, function(){
                if (stored_keys.indexOf(""+this[o.checkColIndex]) !== -1) {
                    selected.push(this);
                }
            });
            return selected;
        },

        getStoredKeys: function(){
            var element = this.element, o = this.options;
            return Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr("id")), []);
        },

        clearSelected: function(redraw){
            var element = this.element, o = this.options;
            Metro.storage.setItem(o.checkStoreKey.replace("$1", element.attr("id")), []);
            element.find("table-service-check-all input").prop("checked", false);
            if (redraw === true) this._draw();
        },

        getFilters: function(){
            return this.filters;
        },

        getFiltersIndexes: function(){
            return this.filtersIndexes;
        },

        openInspector: function(mode){
            var ins = this.inspector;
            if (mode) {
                ins.show(0, function(){
                    ins.css({
                        top: ($(window).height()  - ins.outerHeight(true)) / 2 + pageYOffset,
                        left: ($(window).width() - ins.outerWidth(true)) / 2 + pageXOffset
                    }).data("open", true);
                });
            } else {
                ins.hide().data("open", false);
            }
        },

        closeInspector: function(){
            this.openInspector(false);
        },

        toggleInspector: function(){
            this.openInspector(!this.inspector.data("open"));
        },

        resetView: function(){

            this.view = this._createView();

            this._createTableHeader();
            this._createTableFooter();
            this._draw();

            this._resetInspector();
            this._saveTableView();
        },

        rebuildIndex: function(){
            this._createIndex();
        },

        getIndex: function(){
            return this.index;
        },

        export: function(to, mode, filename, options){
            var that = this, o = this.options;
            var table = document.createElement("table");
            var head = $("<thead>").appendTo(table);
            var body = $("<tbody>").appendTo(table);
            var i, j, cells, tds = [], items, tr, td;
            var start, stop;

            if (typeof Export.tableToCSV !== 'function') {
                return ;
            }

            mode = Utils.isValue(mode) ? mode.toLowerCase() : "all-filtered";
            filename = Utils.isValue(filename) ? filename : Utils.elementId("table")+"-export.csv";

            // Create table header
            tr = $("<tr>");
            cells = this.heads;

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(cell_index){
                var item = this;
                if (Utils.bool(that.view[cell_index]['show']) === false) {
                    return ;
                }
                td = $("<th>");
                if (Utils.isValue(item.title)) {
                    td.html(item.title);
                }
                tds[that.view[cell_index]['index-view']] = td;
            });

            for (j = 0; j < cells.length; j++){
                if (Utils.isValue(tds[j])) tds[j].appendTo(tr);
            }
            tr.appendTo(head);

            // Create table data
            if (mode === "checked") {
                items = this.getSelectedItems();
                start = 0; stop = items.length - 1;
            } else if (mode === "view") {
                items = this._filter();
                start = parseInt(o.rows) === -1 ? 0 : o.rows * (this.currentPage - 1);
                stop = parseInt(o.rows) === -1 ? items.length - 1 : start + o.rows - 1;
            } else if (mode === "all") {
                items = this.items;
                start = 0; stop = items.length - 1;
            } else {
                items = this._filter();
                start = 0; stop = items.length - 1;
            }

            for (i = start; i <= stop; i++) {
                if (Utils.isValue(items[i])) {
                    tr = $("<tr>");

                    cells = items[i];

                    for (j = 0; j < cells.length; j++){
                        tds[j] = null;
                    }

                    $.each(cells, function(cell_index){
                        if (Utils.bool(that.view[cell_index].show) === false) {
                            return ;
                        }
                        td = $("<td>").html(this);
                        tds[that.view[cell_index]['index-view']] = td;
                    });

                    for (j = 0; j < cells.length; j++){
                        if (Utils.isValue(tds[j])) tds[j].appendTo(tr);
                    }

                    tr.appendTo(body);
                }
            }

            // switch (to) {
            //     default: Export.tableToCSV(table, filename, options);
            // }
            Export.tableToCSV(table, filename, options);
            table.remove();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            function dataCheck(){
                o.check = Utils.bool(element.attr("data-check"));
                that._service();
                that._createTableHeader();
                that._draw();
            }

            function dataRownum(){
                o.rownum = Utils.bool(element.attr("data-rownum"));
                that._service();
                that._createTableHeader();
                that._draw();
            }

            switch (attributeName) {
                case "data-check": dataCheck(); break;
                case "data-rownum": dataRownum(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var component = element.closest(".table-component");
            var search_input = component.find("input");
            var rows_select = component.find("select");

            search_input.data("input").destroy();
            rows_select.data("select").destroy();

            $(window).off(Metro.events.resize, {ns: this.id});

            element.off(Metro.events.click, ".sortable-column");

            element.off(Metro.events.click, ".table-service-check input");

            element.off(Metro.events.click, ".table-service-check-all input");

            search_input.off(Metro.events.inputchange);

            if (Utils.isValue(this.wrapperSearch)) {
                var customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.off(Metro.events.inputchange);
                }
            }

            component.off(Metro.events.click, ".pagination .page-link");
            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.off(Metro.events.click, ".pagination .page-link");
            }
            element.off(Metro.events.click, ".js-table-crud-button");

            this._removeInspectorEvents();

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Colors = Metro.colors;
    var TabsDefaultConfig = {
        tabsDeferred: 0,
        expand: false,
        expandPoint: null,
        tabsPosition: "top",
        tabsType: "default",

        clsTabs: "",
        clsTabsList: "",
        clsTabsListItem: "",
        clsTabsListItemActive: "",

        onTab: Metro.noop,
        onBeforeTab: Metro.noop_true,
        onTabsCreate: Metro.noop
    };

    Metro.tabsSetup = function (options) {
        TabsDefaultConfig = $.extend({}, TabsDefaultConfig, options);
    };

    if (typeof window["metroTabsSetup"] !== undefined) {
        Metro.tabsSetup(window["metroTabsSetup"]);
    }

    Metro.Component('tabs', {
        init: function( options, elem ) {
            this._super(elem, options, TabsDefaultConfig, {
                _targets: [],
                id: Utils.elementId('tabs')
            });

            return this;
        },

        _create: function(){
            var element = this.element;
            var tab = element.find(".active").length > 0 ? $(element.find(".active")[0]) : undefined;

            this._createStructure();
            this._createEvents();
            this._open(tab);

            this._fireEvent("tabs-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var parent = element.parent();
            var right_parent = parent.hasClass("tabs");
            var container = right_parent ? parent : $("<div>").addClass("tabs tabs-wrapper");
            var expandTitle, hamburger;

            container.addClass(o.tabsPosition.replace(["-", "_", "+"], " "));

            element.addClass("tabs-list");
            if (o.tabsType !== "default") {
                element.addClass("tabs-"+o.tabsType);
            }
            if (!right_parent) {
                container.insertBefore(element);
                element.appendTo(container);
            }

            element.data('expanded', false);

            expandTitle = $("<div>").addClass("expand-title"); container.prepend(expandTitle);
            hamburger = container.find(".hamburger");
            if (hamburger.length === 0) {
                hamburger = $("<button>").attr("type", "button").addClass("hamburger menu-down").appendTo(container);
                for(var i = 0; i < 3; i++) {
                    $("<span>").addClass("line").appendTo(hamburger);
                }

                if (Colors.isLight(Utils.computedRgbToHex(Utils.getStyleOne(container, "background-color"))) === true) {
                    hamburger.addClass("dark");
                }
            }

            container.addClass(o.clsTabs);
            element.addClass(o.clsTabsList);
            element.children("li").addClass(o.clsTabsListItem);

            if (o.expand === true && !o.tabsPosition.contains("vertical")) {
                container.addClass("tabs-expand");
            } else {
                if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint) && !o.tabsPosition.contains("vertical")) {
                    container.addClass("tabs-expand");
                }
            }

            if (o.tabsPosition.contains("vertical")) {
                container.addClass("tabs-expand");
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.parent();

            $(window).on(Metro.events.resize, function(){

                if (o.tabsPosition.contains("vertical")) {
                    return ;
                }

                if (o.expand === true && !o.tabsPosition.contains("vertical")) {
                    container.addClass("tabs-expand");
                } else {
                    if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint) && !o.tabsPosition.contains("vertical")) {
                        if (!container.hasClass("tabs-expand")) container.addClass("tabs-expand");
                    } else {
                        if (container.hasClass("tabs-expand")) container.removeClass("tabs-expand");
                    }
                }
            }, {ns: this.id});

            container.on(Metro.events.click, ".hamburger, .expand-title", function(){
                if (element.data('expanded') === false) {
                    element.addClass("expand");
                    element.data('expanded', true);
                    container.find(".hamburger").addClass("active");
                } else {
                    element.removeClass("expand");
                    element.data('expanded', false);
                    container.find(".hamburger").removeClass("active");
                }
            });

            element.on(Metro.events.click, "a", function(e){
                var link = $(this);
                var href = link.attr("href").trim();
                var tab = link.parent("li");

                if (tab.hasClass("active")) {
                    e.preventDefault();
                }

                if (element.data('expanded') === true) {
                    element.removeClass("expand");
                    element.data('expanded', false);
                    container.find(".hamburger").removeClass("active");
                }

                if (Utils.exec(o.onBeforeTab, [tab, element], tab[0]) !== true) {
                    return false;
                }

                if (Utils.isValue(href) && href[0] === "#") {
                    that._open(tab);
                    e.preventDefault();
                }
            });
        },

        _collectTargets: function(){
            var that = this, element = this.element;
            var tabs = element.find("li");

            this._targets = [];

            $.each(tabs, function(){
                var target = $(this).find("a").attr("href").trim();
                if (target.length > 1 && target[0] === "#") {
                    that._targets.push(target);
                }
            });
        },

        _open: function(tab){
            var element = this.element, o = this.options;
            var tabs = element.find("li");
            var expandTitle = element.siblings(".expand-title");


            if (tabs.length === 0) {
                return;
            }

            this._collectTargets();

            if (tab === undefined) {
                tab = $(tabs[0]);
            }

            var target = tab.find("a").attr("href");

            if (target === undefined) {
                return;
            }

            tabs.removeClass("active").removeClass(o.clsTabsListItemActive);
            if (tab.parent().hasClass("d-menu")) {
                tab.parent().parent().addClass("active");
            } else {
                tab.addClass("active");
            }

            $.each(this._targets, function(){
                var t = $(this);
                if (t.length > 0) t.hide();
            });

            if (target !== "#" && target[0] === "#") {
                $(target).show();
            }

            expandTitle.html(tab.find("a").html());

            tab.addClass(o.clsTabsListItemActive);

            this._fireEvent("tab", {
                tab: tab[0]
            });
        },

        next: function(){
            var element = this.element;
            var next, active_tab = element.find("li.active");

            next = active_tab.next("li");
            if (next.length > 0) {
                this._open(next);
            }
        },

        prev: function(){
            var element = this.element;
            var next, active_tab = element.find("li.active");

            next = active_tab.prev("li");
            if (next.length > 0) {
                this._open(next);
            }
        },

        open: function(tab){
            var element = this.element;
            var tabs = element.find("li");

            if (!Utils.isValue(tab)) {
                tab = 1;
            }

            if (Utils.isInt(tab)) {
                if (Utils.isValue(tabs[tab-1])) this._open($(tabs[tab-1]));
            } else {
                this._open($(tab));
            }
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            var container = element.parent();

            $(window).off(Metro.events.resize,{ns: this.id});

            container.off(Metro.events.click, ".hamburger, .expand-title");

            element.off(Metro.events.click, "a");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Colors = Metro.colors;
    var Utils = Metro.utils;
    var TagInputDefaultConfig = {
        label: "",
        size: "normal",
        taginputDeferred: 0,
        static: false,
        clearButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",

        randomColor: false,
        maxTags: 0,
        tagSeparator: ",",
        tagTrigger: "Enter, Space, Comma",
        backspace: true,

        clsComponent: "",
        clsInput: "",
        clsClearButton: "",
        clsTag: "",
        clsTagTitle: "",
        clsTagRemover: "",
        clsLabel: "",

        onBeforeTagAdd: Metro.noop_true,
        onTagAdd: Metro.noop,
        onBeforeTagRemove: Metro.noop_true,
        onTagRemove: Metro.noop,
        onTag: Metro.noop,
        onClear: Metro.noop,
        onTagTrigger: Metro.noop,
        onTagInputCreate: Metro.noop
    };

    Metro.tagInputSetup = function (options) {
        TagInputDefaultConfig = $.extend({}, TagInputDefaultConfig, options);
    };

    if (typeof window["metroTagInputSetup"] !== undefined) {
        Metro.tagInputSetup(window["metroTagInputSetup"]);
    }

    Metro.Component('tag-input', {
        init: function( options, elem ) {
            this._super(elem, options, TagInputDefaultConfig, {
                values: [],
                triggers: []
            });

            return this;
        },

        _create: function(){
            this.triggers = (""+this.options.tagTrigger).toArray(",");

            if (this.triggers.contains("Space") || this.triggers.contains("Spacebar")) {
                this.triggers.push(" ");
                this.triggers.push("Spacebar");
            }

            if (this.triggers.contains("Comma")) {
                this.triggers.push(",");
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("tag-input-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container, input, clearButton;
            var values = element.val().trim();

            container = $("<div>").addClass("tag-input "  + element[0].className).addClass(o.clsComponent).insertBefore(element);
            element.appendTo(container);

            container.addClass("input-" + o.size)

            element[0].className = "";

            element.addClass("original-input");
            input = $("<input type='text'>").addClass("input-wrapper").addClass(o.clsInput).attr("size", 1);
            input.appendTo(container);

            if (o.clearButton !== false && !element[0].readOnly) {
                container.addClass("padding-for-clear");
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(container);
            }

            if (Utils.isValue(values)) {
                $.each(values.toArray(o.tagSeparator), function(){
                    that._addTag(this);
                })
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            if (o.static === true || element.attr("readonly") !== undefined) {
                container.addClass("static-mode");
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");

            input.on(Metro.events.focus, function(){
                container.addClass("focused");
            });

            input.on(Metro.events.blur, function(){
                container.removeClass("focused");
            });

            input.on(Metro.events.inputchange, function(){
                input.attr("size", Math.ceil(input.val().length / 2) + 2);
            });

            input.on(Metro.events.keydown, function(e){
                var val = input.val().trim();
                var key = e.key;

                if (key === "Enter") e.preventDefault();

                if (o.backspace === true && key === "Backspace" && val.length === 0) {
                    if (that.values.length > 0) {
                        that.values.splice(-1,1);
                        element.siblings(".tag").last().remove();
                        element.val(that.values.join(o.tagSeparator));
                    }
                    return ;
                }

                if (val === "") {return ;}

                if (!that.triggers.contains(key)) {
                    return ;
                }

                that._fireEvent("tag-trigger", {
                    key: key
                });

                input.val("");
                that._addTag(val);
                input.attr("size", 1);
            });

            input.on(Metro.events.keyup, function(e){
                var val = input.val();
                var key = e.key;

                if (that.triggers.contains(key) && val[val.length - 1] === key) {
                    input.val(val.slice(0, -1));
                }
            });

            container.on(Metro.events.click, ".tag .remover", function(){
                var tag = $(this).closest(".tag");
                that._delTag(tag);
            });

            container.on(Metro.events.click, function(){
                input.focus();
            });

            container.on(Metro.events.click, ".input-clear-button", function(){
                var val = element.val();
                that.clear();

                that._fireEvent("clear", {
                    val: val
                });
            });
        },

        _addTag: function(val){
            var element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");
            var tag, title, remover;
            var tagSize, tagStatic;

            if (container.hasClass("input-large")) {
                tagSize = "large";
            } else if (container.hasClass("input-small")) {
                tagSize = "small"
            }

            if (o.maxTags > 0 && this.values.length === o.maxTags) {
                return ;
            }

            if ((""+val).trim() === "") {
                return ;
            }

            if (!Utils.exec(o.onBeforeTagAdd, [val, this.values], element[0])) {
                return ;
            }


            tag = $("<span>")
                .addClass("tag")
                .addClass(tagSize)
                .addClass(o.clsTag)
                .insertBefore(input);
            tag.data("value", val);

            tagStatic = o.static || container.hasClass("static-mode") || element.readonly || element.disabled || container.hasClass("disabled");
            if (tagStatic) {
                tag.addClass("static");
            }

            title = $("<span>").addClass("title").addClass(o.clsTagTitle).html(val);
            remover = $("<span>").addClass("remover").addClass(o.clsTagRemover).html("&times;");

            title.appendTo(tag);
            remover.appendTo(tag);

            if (o.randomColor === true) {
                var colors = Colors.colors(Colors.PALETTES.ALL), bg, fg, bg_r;

                bg = colors[$.random(0, colors.length - 1)];
                bg_r = Colors.darken(bg, 15);
                fg = Colors.isDark(bg) ? "#ffffff" : "#000000";

                tag.css({
                    backgroundColor: bg,
                    color: fg
                });
                remover.css({
                    backgroundColor: bg_r,
                    color: fg
                });
            }

            this.values.push(val);
            element.val(this.values.join(o.tagSeparator));

            this._fireEvent("tag-add", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            this._fireEvent("tag", {
                tag: tag[0],
                val: val,
                values: this.values
            });
        },

        _delTag: function(tag) {
            var element = this.element, o = this.options;
            var val = tag.data("value");

            if (!Utils.exec(o.onBeforeTagRemove, [tag, val, this.values], element[0])) {
                return ;
            }

            Utils.arrayDelete(this.values, val);
            element.val(this.values.join(o.tagSeparator));

            this._fireEvent("tag-remove", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            this._fireEvent("tag", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            tag.remove();
        },

        tags: function(){
            return this.values;
        },

        val: function(v){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var newValues = [];

            if (!Utils.isValue(v)) {
                return this.tags();
            }

            this.values = [];
            container.find(".tag").remove();

            if (typeof v === "string") {
                newValues = (""+v).toArray(o.tagSeparator);
            } else {
                if (Array.isArray(v)) {
                    newValues = v;
                }
            }

            $.each(newValues, function(){
                that._addTag(this);
            });

            return this;
        },

        append: function(v){
            var that = this, o = this.options;
            var newValues = this.values;

            if (typeof v === "string") {
                newValues = (""+v).toArray(o.tagSeparator);
            } else {
                if (Array.isArray(v)) {
                    newValues = v;
                }
            }

            $.each(newValues, function(){
                that._addTag(this);
            });

            return this;
        },

        clear: function(){
            var element = this.element;
            var container = element.closest(".tag-input");

            this.values = [];

            element.val("").trigger("change");

            container.find(".tag").remove();

            return this;
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggleStatic: function(val){
            var container = this.element.closest(".tag-input");
            var staticMode;

            if (Utils.isValue(val)) {
                staticMode = Utils.bool(val);
            } else {
                staticMode = !container.hasClass("static-mode");
            }

            if (staticMode) {
                container.addClass("static-mode");
            } else {
                container.removeClass("static-mode");
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeValue = function(){
                var val = element.attr("value").trim();
                that.clear();
                if (!Utils.isValue(val)) {
                    return ;
                }
                that.val(val.toArray(o.tagSeparator));
            };

            switch (attributeName) {
                case "value": changeValue(); break;
                case "disabled": this.toggleState(); break;
                case "static": this.toggleStatic(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");

            input.off(Metro.events.focus);
            input.off(Metro.events.blur);
            input.off(Metro.events.keydown);
            container.off(Metro.events.click, ".tag .remover");
            container.off(Metro.events.click);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;

    var Engine = function(html, options, conf) {
        var ReEx, re = '<%(.+?)%>',
            reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g,
            code = 'with(obj) { var r=[];\n',
            cursor = 0,
            result,
            match;
        var add = function(line, js) {
            /* jshint -W030 */
            js? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :
                (code += line !== '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');
            return add;
        };

        if (Utils.isValue(conf)) {
            if (($.hasProp(conf, 'beginToken'))) {
                re = re.replace('<%', conf.beginToken);
            }
            if (($.hasProp(conf,'endToken'))) {
                re = re.replace('%>', conf.endToken);
            }
        }

        ReEx = new RegExp(re, 'g');
        match = ReEx.exec(html);

        while(match) {
            add(html.slice(cursor, match.index))(match[1], true);
            cursor = match.index + match[0].length;
            match = ReEx.exec(html);
        }
        add(html.substr(cursor, html.length - cursor));
        code = (code + 'return r.join(""); }').replace(/[\r\t\n]/g, ' ');
        /* jshint -W054 */
        try { result = new Function('obj', code).apply(options, [options]); }
        catch(err) { console.error("'" + err.message + "'", " in \n\nCode:\n", code, "\n"); }
        return result;
    };

    var TemplateDefaultConfig = {
        templateData: null,
        onTemplateCompile: Metro.noop,
        onTemplateCreate: Metro.noop
    };

    Metro.templateSetup = function (options) {
        TemplateDefaultConfig = $.extend({}, TemplateDefaultConfig, options);
    };

    if (typeof window["metroTemplateSetup"] !== undefined) {
        Metro.templateSetup(window["metroTemplateSetup"]);
    }

    Metro.Component('template', {
        init: function( options, elem ) {
            this._super(elem, options, TemplateDefaultConfig, {
                template: null,
                data: {}
            });
            return this;
        },

        _compile: function(){
            var element = this.element;
            var template, compiled;

            template = this.template
                .replace(/(&lt;%)/gm, "<%")
                .replace(/(%&gt;)/gm, "%>")
                .replace(/(&lt;)/gm, "<")
                .replace(/(&gt;)/gm, ">");

            compiled = Engine(template, this.data);
            element.html(compiled);

            this._fireEvent('template-compile', {
                template: template,
                compiled: compiled,
                element: element
            });
        },

        _create: function(){
            var element = this.element, o = this.options;
            this.template = element.html();
            this.data = Utils.isObject(o.templateData) || {};
            this._compile();
            this._fireEvent('template-create', {
                element: element
            });
        },

        buildWith: function(obj){
            var data = Utils.isObject(obj);
            if (!data) {
                return;
            }
            this.data = data;
            this._compile();
        },

        changeAttribute: function(a, v){
            if (a === "data-template-data") {
                this.options.templateData = v;
                this.data = Utils.isObject(v) || {};
                this._compile();
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro.template = Engine;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TextareaDefaultConfig = {
        label: "",
        textareaDeferred: 0,
        charsCounter: null,
        charsCounterTemplate: "$1",
        defaultValue: "",
        prepend: "",
        append: "",
        copyInlineStyles: false,
        clearButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        autoSize: true,
        maxHeight: 0,
        clsPrepend: "",
        clsAppend: "",
        clsComponent: "",
        clsTextarea: "",
        clsLabel: "",
        onChange: Metro.noop,
        onTextareaCreate: Metro.noop
    };

    Metro.textareaSetup = function (options) {
        TextareaDefaultConfig = $.extend({}, TextareaDefaultConfig, options);
    };

    if (typeof window["metroTextareaSetup"] !== undefined) {
        Metro.textareaSetup(window["metroTextareaSetup"]);
    }

    Metro.Component('textarea', {
        init: function( options, elem ) {
            this._super(elem, options, TextareaDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("textarea-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, elem = this.elem, o = this.options;
            var container = $("<div>").addClass("textarea " + element[0].className);
            var fakeTextarea = $("<textarea>").addClass("fake-textarea");
            var clearButton;

            container.insertBefore(element);
            element.appendTo(container);
            fakeTextarea.appendTo(container);

            if (o.clearButton !== false && !element[0].readOnly) {
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(container);
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            if (o.prepend !== "") {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (o.append !== "") {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
                clearButton.css({
                    right: append.outerWidth() + 4
                });
            }

            elem.className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = elem.style.length; i < l; i++) {
                    container.css(elem.style[i], element.css(elem.style[i]));
                }
            }

            if (Utils.isValue(o.defaultValue) && element.val().trim() === "") {
                element.val(o.defaultValue);
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsTextarea);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

            fakeTextarea.val(element.val());

            if (o.autoSize === true) {
                container.addClass("autosize no-scroll-vertical");

                setTimeout(function(){
                    that.resize();
                }, 100);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var textarea = element.closest(".textarea");
            var fakeTextarea = textarea.find(".fake-textarea");
            var chars_counter = $(o.charsCounter);

            textarea.on(Metro.events.click, ".input-clear-button", function(){
                element.val(Utils.isValue(o.defaultValue) ? o.defaultValue : "").trigger('change').trigger('keyup').focus();
            });

            if (o.autoSize) {
                element.on(Metro.events.inputchange + " " + Metro.events.keyup, function(){
                    fakeTextarea.val(this.value);
                    that.resize();
                });
            }

            element.on(Metro.events.blur, function(){textarea.removeClass("focused");});
            element.on(Metro.events.focus, function(){textarea.addClass("focused");});

            element.on(Metro.events.keyup, function(){
                if (Utils.isValue(o.charsCounter) && chars_counter.length > 0) {
                    if (chars_counter[0].tagName === "INPUT") {
                        chars_counter.val(that.length());
                    } else {
                        chars_counter.html(o.charsCounterTemplate.replace("$1", that.length()));
                    }
                }

                that._fireEvent("change", {
                    val: element.val(),
                    length: that.length()
                });

            })
        },

        resize: function(){
            var element = this.element, o = this.options,
                textarea = element.closest(".textarea"),
                fakeTextarea = textarea.find(".fake-textarea"),
                currentHeight = fakeTextarea[0].scrollHeight;

            if (o.maxHeight && currentHeight >= o.maxHeight) {
                textarea.removeClass("no-scroll-vertical");
                return ;
            }

            if (o.maxHeight && currentHeight < o.maxHeight) {
                textarea.addClass("no-scroll-vertical");
            }

            fakeTextarea[0].style.cssText = 'height:auto;';
            fakeTextarea[0].style.cssText = 'height:' + fakeTextarea[0].scrollHeight + 'px';
            element[0].style.cssText = 'height:' + fakeTextarea[0].scrollHeight + 'px';
        },

        clear: function(){
            this.element.val("").trigger('change').trigger('keyup').focus();
        },

        toDefault: function(){
            this.element.val(Utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "").trigger('change').trigger('keyup').focus();
        },

        length: function(){
            var characters = this.elem.value.split('');
            return characters.length;
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var textarea = element.closest(".textarea");

            textarea.off(Metro.events.click, ".input-clear-button");

            if (o.autoSize) {
                element.off(Metro.events.inputchange + " " + Metro.events.keyup);
            }

            element.off(Metro.events.blur);
            element.off(Metro.events.focus);

            element.off(Metro.events.keyup);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var effects = [
        "slide-up", "slide-down", "slide-left", "slide-right", "fade", "zoom", "swirl", "switch"
    ];
    var TileDefaultConfig = {
        tileDeferred: 0,
        size: "medium",
        cover: "",
        coverPosition: "center",
        effect: "", // slide-up, slide-down, slide-left, slide-right, fade, zoom, swirl, switch
        effectInterval: 3000,
        effectDuration: 500,
        target: null,
        canTransform: true,
        onTileClick: Metro.noop,
        onTileCreate: Metro.noop
    };

    Metro.tileSetup = function (options) {
        TileDefaultConfig = $.extend({}, TileDefaultConfig, options);
    };

    if (typeof window["metroTileSetup"] !== undefined) {
        Metro.tileSetup(window["metroTileSetup"]);
    }

    Metro.Component('tile', {
        init: function( options, elem ) {
            this._super(elem, options, TileDefaultConfig, {
                effectInterval: false,
                images: [],
                slides: [],
                currentSlide: -1,
                unload: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createTile();
            this._createEvents();

            this._fireEvent("tile-create", {
                element: element
            });
        },

        _createTile: function(){
            function switchImage(el, img_src, i){
                $.setTimeout(function(){
                    el.fadeOut(500, function(){
                        el.css("background-image", "url(" + img_src + ")");
                        el.fadeIn();
                    });
                }, i * 300);
            }

            var that = this, element = this.element, o = this.options;
            var slides = element.find(".slide");
            var slides2 = element.find(".slide-front, .slide-back");

            element.addClass("tile-" + o.size);

            if (o.effect.indexOf("hover-") > -1) {
                element.addClass("effect-" + o.effect);
                $.each(slides2, function(){
                    var slide = $(this);

                    if (slide.data("cover") !== undefined) {
                        that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
                    }
                })
            }

            if (effects.includes(o.effect) && slides.length > 1) {
                $.each(slides, function(i){
                    var slide = $(this);

                    that.slides.push(this);

                    if (slide.data("cover") !== undefined) {
                        that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
                    }

                    if (i > 0) {
                        if (["slide-up", "slide-down"].indexOf(o.effect) > -1) slide.css("top", "100%");
                        if (["slide-left", "slide-right"].indexOf(o.effect) > -1) slide.css("left", "100%");
                        if (["fade", "zoom", "swirl", "switch"].indexOf(o.effect) > -1) slide.css("opacity", 0);
                    }
                });

                this.currentSlide = 0;

                this._runEffects();
            }

            if (o.cover !== "") {
                this._setCover(element, o.cover);
            }

            if (o.effect === "image-set") {
                element.addClass("image-set");

                $.each(element.children("img"), function(){
                    that.images.push(this);
                    $(this).remove();
                });

                var temp = this.images.slice();

                for(var i = 0; i < 5; i++) {
                    var rnd_index = $.random(0, temp.length - 1);
                    var div = $("<div>").addClass("img -js-img-"+i).css("background-image", "url("+temp[rnd_index].src+")");
                    element.prepend(div);
                    temp.splice(rnd_index, 1);
                }

                var a = [0, 1, 4, 3, 2];

                $.setInterval(function(){
                    var temp = that.images.slice();
                    var bg = Utils.randomColor();

                    element.css("background-color", bg);

                    for(var i = 0; i < a.length; i++) {
                        var rnd_index = $.random(0, temp.length - 1);
                        var div = element.find(".-js-img-"+a[i]);
                        switchImage(div, temp[rnd_index].src, i);
                        temp.splice(rnd_index, 1);
                    }

                    a = a.reverse();
                }, 5000);
            }
        },

        _runEffects: function(){
            var that = this, o = this.options;

            if (this.effectInterval === false) this.effectInterval = $.setInterval(function(){
                var current, next;

                current = $(that.slides[that.currentSlide]);

                that.currentSlide++;
                if (that.currentSlide === that.slides.length) {
                    that.currentSlide = 0;
                }

                next = that.slides[that.currentSlide];

                if (effects.includes(o.effect)) {
                    Metro.animations[o.effect.camelCase()]($(current), $(next), {duration: o.effectDuration});
                }

            }, o.effectInterval);
        },

        _stopEffects: function(){
            $.clearInterval(this.effectInterval);
            this.effectInterval = false;
        },

        _setCover: function(to, src, pos){
            if (!Utils.isValue(pos)) {
                pos = this.options.coverPosition;
            }
            to.css({
                backgroundImage: "url("+src+")",
                backgroundSize: "cover",
                backgroundRepeat: "no-repeat",
                backgroundPosition: pos
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.startAll, function(e){
                var tile = $(this);
                var dim = {w: element.width(), h: element.height()};
                var X = Utils.pageXY(e).x - tile.offset().left,
                    Y = Utils.pageXY(e).y - tile.offset().top;
                var side;

                if (Utils.isRightMouse(e) === false) {

                    if (X < dim.w * 1 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                        side = 'left';
                    } else if (X > dim.w * 2 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                        side = 'right';
                    } else if (X > dim.w * 1 / 3 && X < dim.w * 2 / 3 && Y > dim.h / 2) {
                        side = 'bottom';
                    } else {
                        side = "top";
                    }

                    if (o.canTransform === true) tile.addClass("transform-" + side);

                    if (o.target !== null) {
                        setTimeout(function(){
                            document.location.href = o.target;
                        }, 100);
                    }

                    that._fireEvent("tile-click", {
                        side: side
                    });
                }
            });

            element.on([Metro.events.stopAll, Metro.events.leave].join(" "), function(){
                $(this)
                    .removeClass("transform-left")
                    .removeClass("transform-right")
                    .removeClass("transform-top")
                    .removeClass("transform-bottom");
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.startAll);

            element.off([Metro.events.stopAll, Metro.events.leave].join(" "));

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TimePickerDefaultConfig = {
        label: "",
        timepickerDeferred: 0,
        hoursStep: 1,
        minutesStep: 1,
        secondsStep: 1,
        value: null,
        locale: METRO_LOCALE,
        distance: 3,
        hours: true,
        minutes: true,
        seconds: true,
        showLabels: true,
        scrollSpeed: 4,
        copyInlineStyles: false,
        clsPicker: "",
        clsPart: "",
        clsHours: "",
        clsMinutes: "",
        clsSeconds: "",
        clsLabel: "",
        okButtonIcon: "<span class='default-icon-check'></span>",
        cancelButtonIcon: "<span class='default-icon-cross'></span>",
        onSet: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onScroll: Metro.noop,
        onTimePickerCreate: Metro.noop
    };

    Metro.timePickerSetup = function (options) {
        TimePickerDefaultConfig = $.extend({}, TimePickerDefaultConfig, options);
    };

    if (typeof window["metroTimePickerSetup"] !== undefined) {
        Metro.timePickerSetup(window["metroTimePickerSetup"]);
    }

    Metro.Component('time-picker', {
        init: function( options, elem ) {
            this._super(elem, options, TimePickerDefaultConfig, {
                picker: null,
                isOpen: false,
                value: [],
                locale: Metro.locales[METRO_LOCALE]['calendar'],
                listTimer: {
                    hours: null,
                    minutes: null,
                    seconds: null
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i;

            if (o.distance < 1) {
                o.distance = 1;
            }

            if (o.hoursStep < 1) {o.hoursStep = 1;}
            if (o.hoursStep > 23) {o.hoursStep = 23;}

            if (o.minutesStep < 1) {o.minutesStep = 1;}
            if (o.minutesStep > 59) {o.minutesStep = 59;}

            if (o.secondsStep < 1) {o.secondsStep = 1;}
            if (o.secondsStep > 59) {o.secondsStep = 59;}

            if (element.val() === "" && (!Utils.isValue(o.value))) {
                o.value = (new Date()).format("%H:%M:%S");
            }

            this.value = (element.val() !== "" ? element.val() : ""+o.value).toArray(":");

            for(i = 0; i < 3; i++) {
                if (this.value[i] === undefined || this.value[i] === null) {
                    this.value[i] = 0;
                } else {
                    this.value[i] = parseInt(this.value[i]);
                }
            }

            this._normalizeValue();

            if (Metro.locales[o.locale] === undefined) {
                o.locale = METRO_LOCALE;
            }

            this.locale = Metro.locales[o.locale]['calendar'];

            this._createStructure();
            this._createEvents();
            this._set();

            this._fireEvent("time-picker-create", {
                element: element
            });
        },

        _normalizeValue: function(){
            var o = this.options;

            if (o.hoursStep > 1) {
                this.value[0] = Utils.nearest(this.value[0], o.hoursStep, true);
            }
            if (o.minutesStep > 1) {
                this.value[1] = Utils.nearest(this.value[1], o.minutesStep, true);
            }
            if (o.minutesStep > 1) {
                this.value[2] = Utils.nearest(this.value[2], o.secondsStep, true);
            }
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var picker, hours, minutes, seconds, i;
            var timeWrapper, selectWrapper, selectBlock, actionBlock;

            var id = Utils.elementId("time-picker");

            picker = $("<div>").attr("id", id).addClass("wheel-picker time-picker " + element[0].className).addClass(o.clsPicker);

            picker.insertBefore(element);
            element.attr("readonly", true).appendTo(picker);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(picker);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            timeWrapper = $("<div>").addClass("time-wrapper").appendTo(picker);

            if (o.hours === true) {
                hours = $("<div>").attr("data-title", this.locale['time']['hours']).addClass("hours").addClass(o.clsPart).addClass(o.clsHours).appendTo(timeWrapper);
            }
            if (o.minutes === true) {
                minutes = $("<div>").attr("data-title", this.locale['time']['minutes']).addClass("minutes").addClass(o.clsPart).addClass(o.clsMinutes).appendTo(timeWrapper);
            }
            if (o.seconds === true) {
                seconds = $("<div>").attr("data-title", this.locale['time']['seconds']).addClass("seconds").addClass(o.clsPart).addClass(o.clsSeconds).appendTo(timeWrapper);
            }

            selectWrapper = $("<div>").addClass("select-wrapper").appendTo(picker);

            selectBlock = $("<div>").addClass("select-block").appendTo(selectWrapper);
            if (o.hours === true) {
                hours = $("<ul>").addClass("sel-hours").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
                for (i = 0; i < 24; i = i + o.hoursStep) {
                    $("<li>").addClass("js-hours-"+i).html(i < 10 ? "0"+i : i).data("value", i).appendTo(hours);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
            }
            if (o.minutes === true) {
                minutes = $("<ul>").addClass("sel-minutes").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
                for (i = 0; i < 60; i = i + o.minutesStep) {
                    $("<li>").addClass("js-minutes-"+i).html(i < 10 ? "0"+i : i).data("value", i).appendTo(minutes);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
            }
            if (o.seconds === true) {
                seconds = $("<ul>").addClass("sel-seconds").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
                for (i = 0; i < 60; i = i + o.secondsStep) {
                    $("<li>").addClass("js-seconds-"+i).html(i < 10 ? "0"+i : i).data("value", i).appendTo(seconds);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
            }

            selectBlock.height((o.distance * 2 + 1) * 40);

            actionBlock = $("<div>").addClass("action-block").appendTo(selectWrapper);
            $("<button>").attr("type", "button").addClass("button action-ok").html(o.okButtonIcon).appendTo(actionBlock);
            $("<button>").attr("type", "button").addClass("button action-cancel").html(o.cancelButtonIcon).appendTo(actionBlock);


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    picker.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.showLabels === true) {
                picker.addClass("show-labels");
            }

            if (element.prop("disabled")) {
                picker.addClass("disabled");
            }

            this.picker = picker;
        },

        _createEvents: function(){
            var that = this, o = this.options;
            var picker = this.picker;

            picker.on(Metro.events.start, ".select-block ul", function(e){

                if (e.changedTouches) {
                    return ;
                }

                var target = this;
                var pageY = Utils.pageXY(e).y;

                $(document).on(Metro.events.move, function(e){

                    target.scrollTop -= o.scrollSpeed * (pageY  > Utils.pageXY(e).y ? -1 : 1);

                    pageY = Utils.pageXY(e).y;
                }, {ns: picker.attr("id")});

                $(document).on(Metro.events.stop, function(){
                    $(document).off(Metro.events.move, {ns: picker.attr("id")});
                    $(document).off(Metro.events.stop, {ns: picker.attr("id")});
                }, {ns: picker.attr("id")});
            });

            picker.on(Metro.events.click, function(e){
                if (that.isOpen === false) that.open();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-ok", function(e){
                var h, m, s;
                var sh = picker.find(".sel-hours li.active"),
                    sm = picker.find(".sel-minutes li.active"),
                    ss = picker.find(".sel-seconds li.active");

                h = sh.length === 0 ? 0 : sh.data("value");
                m = sm.length === 0 ? 0 : sm.data("value");
                s = ss.length === 0 ? 0 : ss.data("value");

                that.value = [h, m, s];
                that._normalizeValue();
                that._set();

                that.close();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-cancel", function(e){
                that.close();
                e.stopPropagation();
            });

            var scrollLatency = 150;
            $.each(['hours', 'minutes', 'seconds'], function(){
                var part = this, list = picker.find(".sel-"+part);

                list.on("scroll", function(){
                    if (that.isOpen) {
                        if (that.listTimer[part]) {
                            clearTimeout(that.listTimer[part]);
                            that.listTimer[part] = null;
                        }

                        if (!that.listTimer[part]) that.listTimer[part] = setTimeout(function () {

                            var target, targetElement, scrollTop;

                            that.listTimer[part] = null;

                            target = Math.round((Math.ceil(list.scrollTop()) / 40));

                            targetElement = list.find(".js-" + part + "-" + target);
                            scrollTop = targetElement.position().top - (o.distance * 40);

                            list.find(".active").removeClass("active");

                            list[0].scrollTop = scrollTop;
                            targetElement.addClass("active");
                            Utils.exec(o.onScroll, [targetElement, list, picker], list[0]);

                        }, scrollLatency);
                    }
                })
            });
        },

        _set: function(){
            var element = this.element, o = this.options;
            var picker = this.picker;
            var h = "00", m = "00", s = "00";

            if (o.hours === true) {
                h = parseInt(this.value[0]);
                if (h < 10) {
                    h = "0"+h;
                }
                picker.find(".hours").html(h);
            }
            if (o.minutes === true) {
                m = parseInt(this.value[1]);
                if (m < 10) {
                    m = "0"+m;
                }
                picker.find(".minutes").html(m);
            }
            if (o.seconds === true) {
                s = parseInt(this.value[2]);
                if (s < 10) {
                    s = "0"+s;
                }
                picker.find(".seconds").html(s);
            }

            element.val([h, m, s].join(":")).trigger("change");

            this._fireEvent("set", {
                val: this.value,
                elementVal: element.val()
            });

        },

        open: function(){
            var o = this.options;
            var picker = this.picker;
            var h, m, s;
            var h_list, m_list, s_list;
            var items = picker.find("li");
            var select_wrapper = picker.find(".select-wrapper");
            var select_wrapper_in_viewport, select_wrapper_rect;
            var h_item, m_item, s_item;

            select_wrapper.parent().removeClass("for-top for-bottom");
            select_wrapper.show(0);
            items.removeClass("active");

            select_wrapper_in_viewport = Utils.inViewport(select_wrapper[0]);
            select_wrapper_rect = Utils.rect(select_wrapper[0]);

            if (!select_wrapper_in_viewport && select_wrapper_rect.top > 0) {
                select_wrapper.parent().addClass("for-bottom");
            }

            if (!select_wrapper_in_viewport && select_wrapper_rect.top < 0) {
                select_wrapper.parent().addClass("for-top");
            }

            var animateList = function(list, item){
                list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: item.position().top - (o.distance * 40) + list.scrollTop()
                        },
                        dur: 100
                    });
            };

            if (o.hours === true) {
                h = parseInt(this.value[0]);
                h_list = picker.find(".sel-hours");
                h_item = h_list.find("li.js-hours-" + h).addClass("active");
                animateList(h_list, h_item);
            }
            if (o.minutes === true) {
                m = parseInt(this.value[1]);
                m_list = picker.find(".sel-minutes");
                m_item = m_list.find("li.js-minutes-" + m).addClass("active");
                animateList(m_list, m_item);
            }
            if (o.seconds === true) {
                s = parseInt(this.value[2]);
                s_list = picker.find(".sel-seconds");
                s_item = s_list.find("li.js-seconds-" + s).addClass("active");
                animateList(s_list, s_item);
            }

            this.isOpen = true;

            this._fireEvent("open", {
                val: this.value
            });

        },

        close: function(){
            var picker = this.picker;
            picker.find(".select-wrapper").hide(0);
            this.isOpen = false;

            this._fireEvent("close", {
                val: this.value
            });
        },

        _convert: function(t){
            var result;

            if (Array.isArray(t)) {
                result = t;
            } else if (typeof  t.getMonth === 'function') {
                result = [t.getHours(), t.getMinutes(), t.getSeconds()];
            } else if (Utils.isObject(t)) {
                result = [t.h, t.m, t.s];
            } else {
                result = t.toArray(":");
            }

            return result;
        },

        val: function(t){
            if (t === undefined) {
                return this.element.val();
            }
            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        time: function(t){
            if (t === undefined) {
                return {
                    h: this.value[0],
                    m: this.value[1],
                    s: this.value[2]
                }
            }

            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        date: function(t){
            if (t === undefined || typeof t.getMonth !== 'function') {
                var ret = new Date();
                ret.setHours(this.value[0]);
                ret.setMinutes(this.value[1]);
                ret.setSeconds(this.value[2]);
                ret.setMilliseconds(0);
                return ret;
            }

            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attr, newValue){
            switch (attr) {
                case "data-value":
                    this.val(newValue);
                    break;
                case "disabled":
                    this.toggleState();
                    break;
            }
        },

        destroy: function(){
            var element = this.element;
            var picker = this.picker;

            $.each(['hours', 'minutes', 'seconds'], function(){
                picker.find(".sel-"+this).off("scroll");
            });

            picker.off(Metro.events.start, ".select-block ul");
            picker.off(Metro.events.click);
            picker.off(Metro.events.click, ".action-ok");
            picker.off(Metro.events.click, ".action-cancel");

            return element;
        }

    });

    $(document).on(Metro.events.click, function(){
        $.each($(".time-picker"), function(){
            $(this).find("input").each(function(){
                Metro.getPlugin(this, "timepicker").close();
            });
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ToastDefaultConfig = {
        callback: Metro.noop,
        timeout: METRO_TIMEOUT,
        distance: 20,
        showTop: false,
        clsToast: ""
    };

    Metro.toastSetup = function(options){
        ToastDefaultConfig = $.extend({}, ToastDefaultConfig, options);
    };

    if (typeof window["metroToastSetup"] !== undefined) {
        Metro.toastSetup(window["metroToastSetup"]);
    }

    var Toast = {
        create: function(message, /*callback, timeout, cls, */options){
            var o, toast, width;
            var args = Array.from(arguments);
            var timeout, callback, cls;

            if (!$.isPlainObject(options)) {
                options = args[4];
                callback = args[1];
                timeout = args[2];
                cls = args[3];
            }

            o = $.extend({}, ToastDefaultConfig, options);

            toast = $("<div>").addClass("toast").html(message).appendTo($("body"));
            width = toast.outerWidth();
            toast.hide();

            timeout = timeout || o.timeout;
            callback = callback || o.callback;
            cls = cls || o.clsToast;

            if (o.showTop === true) {
                toast.addClass("show-top").css({
                    top: o.distance
                });
            } else {
                toast.css({
                    bottom: o.distance
                })
            }

            toast
                .css({
                    'left': '50%',
                    'margin-left': -(width / 2)
                })
                .addClass(o.clsToast)
                .addClass(cls)
                .fadeIn(METRO_ANIMATION_DURATION, function(){
                    setTimeout(function(){
                        Toast.remove(toast, callback);
                    }, timeout);
                });
        },

        remove: function(toast, cb){
            if (!toast) return ;

            toast.fadeOut(METRO_ANIMATION_DURATION, function(){
                toast.remove();
                Utils.exec(cb, null, toast[0]);
            });
        }
    };

    Metro['toast'] = Toast;
    Metro['createToast'] = Toast.create;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var TokenizerDefaultConfig = {
        textToTokenize: "",
        spaceSymbol: "",
        spaceClass: "space",
        tokenClass: "",
        splitter: "",
        tokenElement: "span",
        useTokenSymbol: true,
        useTokenIndex: true,
        clsTokenizer: "",
        clsToken: "",
        clsTokenOdd: "",
        clsTokenEven: "",
        onTokenCreate: Metro.noop,
        onTokenize: Metro.noop,
        onTokenizerCreate: Metro.noop
    };

    Metro.tokenizerSetup = function (options) {
        TokenizerDefaultConfig = $.extend({}, TokenizerDefaultConfig, options);
    };

    if (typeof window["metroTokenizerSetup"] !== undefined) {
        Metro.tokenizerSetup(window["metroTokenizerSetup"]);
    }

    Metro.Component('tokenizer', {
        init: function( options, elem ) {
            this._super(elem, options, TokenizerDefaultConfig, {
                // define instance vars here
                originalText: ""
            });
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            this.originalText = o.textToTokenize ? o.textToTokenize.trim() : element.text().trim().replace(/[\r\n\t]/gi, '').replace(/\s\s+/g, " ");

            this._createStructure();
            this._fireEvent('tokenizer-create');
        },

        _tokenize: function(){
            var that = this, element = this.element, o = this.options;
            var index = 0, append, prepend;

            element.clear().attr("aria-label", this.originalText);

            $.each(this.originalText.split(o.splitter), function(i){
                var symbol = this;
                var isSpace = symbol === " ";
                var token;

                token = $("<"+o.tokenElement+">")
                    .html(isSpace ? o.spaceSymbol : symbol)
                    .attr("aria-hidden", true)
                    .addClass(isSpace ? o.spaceClass : "")
                    .addClass(isSpace && o.useTokenSymbol ? "" : "ts-"+symbol.replace(" ", "_"))
                    .addClass(isSpace && o.useTokenIndex ? "" : "ti-" + (i + 1))
                    .addClass(o.tokenClass ? o.tokenClass : "")
                    .addClass(!isSpace ? o.clsToken : "");

                if (!isSpace) {
                    index++;
                    token.addClass(index % 2 === 0 ? "te-even" : "te-odd");
                    token.addClass(index % 2 === 0 ? o.clsTokenEven : o.clsTokenOdd);
                }

                if (o.prepend) {
                    prepend = $.isSelector(o.prepend) ? $(o.prepend) : $("<span>").html(o.prepend);
                    token.prepend(prepend);
                }

                if (o.append) {
                    append = $.isSelector(o.append) ? $(o.append) : $("<span>").html(o.append);
                    token.append(append);
                }

                element.append(token);

                that._fireEvent("token-create", {
                    token: token[0]
                });
            });

            that._fireEvent("tokenize", {
                tokens: element.children().items(),
                originalText: this.originalText
            });
        },

        _createStructure: function(){
            var element = this.element,  o = this.options;
            element.addClass(o.clsTokenizer);
            this._tokenize();
        },

        tokenize: function(v){
            this.originalText = v;
            this._tokenize();
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TouchConst = {
        LEFT : "left",
        RIGHT : "right",
        UP : "up",
        DOWN : "down",
        IN : "in",
        OUT : "out",
        NONE : "none",
        AUTO : "auto",
        SWIPE : "swipe",
        PINCH : "pinch",
        TAP : "tap",
        DOUBLE_TAP : "doubletap",
        LONG_TAP : "longtap",
        HOLD : "hold",
        HORIZONTAL : "horizontal",
        VERTICAL : "vertical",
        ALL_FINGERS : "all",
        DOUBLE_TAP_THRESHOLD : 10,
        PHASE_START : "start",
        PHASE_MOVE : "move",
        PHASE_END : "end",
        PHASE_CANCEL : "cancel",
        SUPPORTS_TOUCH : 'ontouchstart' in window,
        SUPPORTS_POINTER_IE10 : window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !('ontouchstart' in window),
        SUPPORTS_POINTER : (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !('ontouchstart' in window),
        IN_TOUCH: "intouch"
    };

    var TouchDefaultConfig = {
        touchDeferred: 0,
        fingers: 1,
        threshold: 75,
        cancelThreshold: null,
        pinchThreshold: 20,
        maxTimeThreshold: null,
        fingerReleaseThreshold: 250,
        longTapThreshold: 500,
        doubleTapThreshold: 200,
        triggerOnTouchEnd: true,
        triggerOnTouchLeave: false,
        allowPageScroll: "auto",
        fallbackToMouseEvents: true,
        excludedElements: ".no-swipe",
        preventDefaultEvents: true,

        onSwipe: Metro.noop,
        onSwipeLeft: Metro.noop,
        onSwipeRight: Metro.noop,
        onSwipeUp: Metro.noop,
        onSwipeDown: Metro.noop,
        onSwipeStatus: Metro.noop_true, // params: phase, direction, distance, duration, fingerCount, fingerData, currentDirection
        onPinchIn: Metro.noop,
        onPinchOut: Metro.noop,
        onPinchStatus: Metro.noop_true,
        onTap: Metro.noop,
        onDoubleTap: Metro.noop,
        onLongTap: Metro.noop,
        onHold: Metro.noop,

        onTouchCreate: Metro.noop
    };

    Metro.touchSetup = function (options) {
        TouchDefaultConfig = $.extend({}, TouchDefaultConfig, options);
    };

    if (typeof window["metroTouchSetup"] !== undefined) {
        Metro.touchSetup(window["metroTouchSetup"]);
    }

    Metro.Component('touch', {
        init: function( options, elem ) {
            this._super(elem, options, TouchDefaultConfig, {
                useTouchEvents: null,
                START_EV: null,
                MOVE_EV: null,
                END_EV: null,
                LEAVE_EV: null,
                CANCEL_EV: null,

                distance: 0,
                direction: null,
                currentDirection: null,
                duration: 0,
                startTouchesDistance: 0,
                endTouchesDistance: 0,
                pinchZoom: 1,
                pinchDistance: 0,
                pinchDirection: 0,
                maximumsMap: null,

                phase: "start",

                fingerCount: 0,

                fingerData: {},

                startTime: 0,
                endTime: 0,
                previousTouchEndTime: 0,
                fingerCountAtRelease: 0,
                doubleTapStartTime: 0,

                singleTapTimeout: null,
                holdTimeout: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;

            this.useTouchEvents = (TouchConst.SUPPORTS_TOUCH || TouchConst.SUPPORTS_POINTER || !this.options.fallbackToMouseEvents);
            this.START_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerDown' : 'pointerdown') : 'touchstart') : 'mousedown';
            this.MOVE_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerMove' : 'pointermove') : 'touchmove') : 'mousemove';
            this.END_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerUp' : 'pointerup') : 'touchend') : 'mouseup';
            this.LEAVE_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? 'mouseleave' : null) : 'mouseleave'; //we manually detect leave on touch devices, so null event here
            this.CANCEL_EV = (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerCancel' : 'pointercancel') : 'touchcancel');

            if (o.allowPageScroll === undefined && (o.onSwipe !== Metro.noop || o.onSwipeStatus !== Metro.noop)) {
                o.allowPageScroll = TouchConst.NONE;
            }

            try {
                element.on(this.START_EV, $.proxy(this.touchStart, that));
                element.on(this.CANCEL_EV, $.proxy(this.touchCancel, that));
            } catch (e) {
                throw new Error('Events not supported ' + this.START_EV + ',' + this.CANCEL_EV + ' on Swipe');
            }

            this._fireEvent("touch-create", {
                element: element
            });
        },

        touchStart: function(e) {
            var element = this.element, options = this.options;

            //If we already in a touch event (a finger already in use) then ignore subsequent ones..
            if (this.getTouchInProgress()) {
                return;
            }

            //Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe
            if ($(e.target).closest(options.excludedElements).length > 0) {
                return;
            }

            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e;

            var ret,
                touches = event.touches,
                evt = touches ? touches[0] : event;

            this.phase = TouchConst.PHASE_START;

            //If we support touches, get the finger count
            if (touches) {
                // get the total number of fingers touching the screen
                this.fingerCount = touches.length;
            }
            //Else this is the desktop, so stop the browser from dragging content
            else if (options.preventDefaultEvents !== false) {
                e.preventDefault(); //call this on jq event so we are cross browser
            }

            //clear vars..
            this.distance = 0;
            this.direction = null;
            this.currentDirection=null;
            this.pinchDirection = null;
            this.duration = 0;
            this.startTouchesDistance = 0;
            this.endTouchesDistance = 0;
            this.pinchZoom = 1;
            this.pinchDistance = 0;
            this.maximumsMap = this.createMaximumsData();
            this.cancelMultiFingerRelease();

            //Create the default finger data
            this.createFingerData(0, evt);

            // check the number of fingers is what we are looking for, or we are capturing pinches
            if (!touches || (this.fingerCount === options.fingers || options.fingers === TouchConst.ALL_FINGERS) || this.hasPinches()) {
                // get the coordinates of the touch
                this.startTime = this.getTimeStamp();

                if (this.fingerCount === 2) {
                    //Keep track of the initial pinch distance, so we can calculate the diff later
                    //Store second finger data as start
                    this.createFingerData(1, touches[1]);
                    this.startTouchesDistance = this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].start, this.fingerData[1].start);
                }

                if (options.onSwipeStatus !== Metro.noop || options.onPinchStatus !== Metro.noop) {
                    ret = this.triggerHandler(event, this.phase);
                }
            } else {
                //A touch with more or less than the fingers we are looking for, so cancel
                ret = false;
            }

            //If we have a return value from the users handler, then return and cancel
            if (ret === false) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
                return ret;
            } else {
                if (options.onHold !== Metro.noop) {
                    this.holdTimeout = setTimeout($.proxy(function() {
                        //Trigger the event
                        element.trigger('hold', [event.target]);
                        //Fire the callback
                        if (options.onHold !== Metro.noop) { // TODO Remove this if
                            ret = Utils.exec(options.onHold, [event, event.target], element[0]);
                            element.fire("hold", {
                                event: event,
                                target: event.target
                            });
                        }
                    }, this), options.longTapThreshold);
                }

                this.setTouchInProgress(true);
            }

            return null;
        },

        touchMove: function(e) {
            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e;

            //If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..
            if (this.phase === TouchConst.PHASE_END || this.phase === TouchConst.PHASE_CANCEL || this.inMultiFingerRelease())
                return;

            var ret,
                touches = event.touches,
                evt = touches ? touches[0] : event;

            //Update the  finger data
            var currentFinger = this.updateFingerData(evt);
            this.endTime = this.getTimeStamp();

            if (touches) {
                this.fingerCount = touches.length;
            }

            if (this.options.onHold !== Metro.noop) {
                clearTimeout(this.holdTimeout);
            }

            this.phase = TouchConst.PHASE_MOVE;

            //If we have 2 fingers get Touches distance as well
            if (this.fingerCount === 2) {

                //Keep track of the initial pinch distance, so we can calculate the diff later
                //We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
                if (this.startTouchesDistance === 0) {
                    //Create second finger if this is the first time...
                    this.createFingerData(1, touches[1]);

                    this.startTouchesDistance = this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].start, this.fingerData[1].start);
                } else {
                    //Else just update the second finger
                    this.updateFingerData(touches[1]);

                    this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].end, this.fingerData[1].end);
                    this.pinchDirection = this.calculatePinchDirection(this.fingerData[0].end, this.fingerData[1].end);
                }

                this.pinchZoom = this.calculatePinchZoom(this.startTouchesDistance, this.endTouchesDistance);
                this.pinchDistance = Math.abs(this.startTouchesDistance - this.endTouchesDistance);
            }

            if ((this.fingerCount === this.options.fingers || this.options.fingers === TouchConst.ALL_FINGERS) || !touches || this.hasPinches()) {

                //The overall direction of the swipe. From start to now.
                this.direction = this.calculateDirection(currentFinger.start, currentFinger.end);

                //The immediate direction of the swipe, direction between the last movement and this one.
                this.currentDirection = this.calculateDirection(currentFinger.last, currentFinger.end);

                //Check if we need to prevent default event (page scroll / pinch zoom) or not
                this.validateDefaultEvent(e, this.currentDirection);

                //Distance and duration are all off the main finger
                this.distance = this.calculateDistance(currentFinger.start, currentFinger.end);
                this.duration = this.calculateDuration();

                //Cache the maximum distance we made in this direction
                this.setMaxDistance(this.direction, this.distance);

                //Trigger status handler
                ret = this.triggerHandler(event, this.phase);


                //If we trigger end events when threshold are met, or trigger events when touch leaves element
                if (!this.options.triggerOnTouchEnd || this.options.triggerOnTouchLeave) {

                    var inBounds = true;

                    //If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)
                    if (this.options.triggerOnTouchLeave) {
                        var bounds = this.getBounds(this);
                        inBounds = this.isInBounds(currentFinger.end, bounds);
                    }

                    //Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..
                    if (!this.options.triggerOnTouchEnd && inBounds) {
                        this.phase = this.getNextPhase(TouchConst.PHASE_MOVE);
                    }
                    //We end if out of bounds here, so set current phase to END, and check if its modified
                    else if (this.options.triggerOnTouchLeave && !inBounds) {
                        this.phase = this.getNextPhase(TouchConst.PHASE_END);
                    }

                    if (this.phase === TouchConst.PHASE_CANCEL || this.phase === TouchConst.PHASE_END) {
                        this.triggerHandler(event, this.phase);
                    }
                }
            } else {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }

            if (ret === false) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }
        },

        touchEnd: function(e) {
            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e,
                touches = event.touches;

            //If we are still in a touch with the device wait a fraction and see if the other finger comes up
            //if it does within the threshold, then we treat it as a multi release, not a single release and end the touch / swipe
            if (touches) {
                if (touches.length && !this.inMultiFingerRelease()) {
                    this.startMultiFingerRelease(event);
                    return true;
                } else if (touches.length && this.inMultiFingerRelease()) {
                    return true;
                }
            }

            //If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
            //This is used to allow 2 fingers to release fractionally after each other, whilst maintaining the event as containing 2 fingers, not 1
            if (this.inMultiFingerRelease()) {
                this.fingerCount = this.fingerCountAtRelease;
            }

            //Set end of swipe
            this.endTime = this.getTimeStamp();

            //Get duration incase move was never fired
            this.duration = this.calculateDuration();

            //If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase
            if (this.didSwipeBackToCancel() || !this.validateSwipeDistance()) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            } else if (this.options.triggerOnTouchEnd || (this.options.triggerOnTouchEnd === false && this.phase === TouchConst.PHASE_MOVE)) {
                //call this on jq event so we are cross browser
                if (this.options.preventDefaultEvents !== false) {
                    e.preventDefault();
                }
                this.phase = TouchConst.PHASE_END;
                this.triggerHandler(event, this.phase);
            }
            //Special cases - A tap should always fire on touch end regardless,
            //So here we manually trigger the tap end handler by itself
            //We dont run trigger handler as it will re-trigger events that may have fired already
            else if (!this.options.triggerOnTouchEnd && this.hasTap()) {
                //Trigger the pinch events...
                this.phase = TouchConst.PHASE_END;
                this.triggerHandlerForGesture(event, this.phase, TouchConst.TAP);
            } else if (this.phase === TouchConst.PHASE_MOVE) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }

            this.setTouchInProgress(false);

            return null;
        },

        touchCancel: function() {
            // reset the variables back to default values
            this.fingerCount = 0;
            this.endTime = 0;
            this.startTime = 0;
            this.startTouchesDistance = 0;
            this.endTouchesDistance = 0;
            this.pinchZoom = 1;

            //If we were in progress of tracking a possible multi touch end, then re set it.
            this.cancelMultiFingerRelease();

            this.setTouchInProgress(false);
        },

        touchLeave: function(e) {
            if (this.options.triggerOnTouchLeave) {
                this.phase = this.getNextPhase(TouchConst.PHASE_END);
                this.triggerHandler(e, this.phase);
            }
        },

        getNextPhase: function(currentPhase) {
            var options  = this.options;
            var nextPhase = currentPhase;

            // Ensure we have valid swipe (under time and over distance  and check if we are out of bound...)
            var validTime = this.validateSwipeTime();
            var validDistance = this.validateSwipeDistance();
            var didCancel = this.didSwipeBackToCancel();

            //If we have exceeded our time, then cancel
            if (!validTime || didCancel) {
                nextPhase = TouchConst.PHASE_CANCEL;
            }
            //Else if we are moving, and have reached distance then end
            else if (validDistance && currentPhase === TouchConst.PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave)) {
                nextPhase = TouchConst.PHASE_END;
            }
            //Else if we have ended by leaving and didn't reach distance, then cancel
            else if (!validDistance && currentPhase === TouchConst.PHASE_END && options.triggerOnTouchLeave) {
                nextPhase = TouchConst.PHASE_CANCEL;
            }

            return nextPhase;
        },

        triggerHandler: function(event, phase) {
            var ret,
                touches = event.touches;

            // SWIPE GESTURES
            if (this.didSwipe() || this.hasSwipes()) {
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.SWIPE);
            }

            // PINCH GESTURES (if the above didn't cancel)
            if ((this.didPinch() || this.hasPinches()) && ret !== false) {
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.PINCH);
            }

            // CLICK / TAP (if the above didn't cancel)
            if (this.didDoubleTap() && ret !== false) {
                //Trigger the tap events...
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.DOUBLE_TAP);
            }

            // CLICK / TAP (if the above didn't cancel)
            else if (this.didLongTap() && ret !== false) {
                //Trigger the tap events...
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.LONG_TAP);
            }

            // CLICK / TAP (if the above didn't cancel)
            else if (this.didTap() && ret !== false) {
                //Trigger the tap event..
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.TAP);
            }

            // If we are cancelling the gesture, then manually trigger the reset handler
            if (phase === TouchConst.PHASE_CANCEL) {
                this.touchCancel(event);
            }

            // If we are ending the gesture, then manually trigger the reset handler IF all fingers are off
            if (phase === TouchConst.PHASE_END) {
                //If we support touch, then check that all fingers are off before we cancel
                if (touches) {
                    if (!touches.length) {
                        this.touchCancel(event);
                    }
                } else {
                    this.touchCancel(event);
                }
            }

            return ret;
        },

        triggerHandlerForGesture: function(event, phase, gesture) {

            var ret, element = this.element, options = this.options;

            //SWIPES....
            if (gesture === TouchConst.SWIPE) {
                //Trigger status every time..
                element.trigger('swipeStatus', [phase, this.direction || null, this.distance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.currentDirection]);

                ret = Utils.exec(options.onSwipeStatus, [event, phase, this.direction || null, this.distance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                element.fire("swipestatus", {
                    event: event,
                    phase: phase,
                    direction: this.direction,
                    distance: this.distance,
                    duration: this.duration,
                    fingerCount: this.fingerCount,
                    fingerData: this.fingerData,
                    currentDirection: this.currentDirection
                });
                if (ret === false) return false;

                if (phase === TouchConst.PHASE_END && this.validateSwipe()) {

                    //Cancel any taps that were in progress...
                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);

                    element.trigger('swipe', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);

                    ret = Utils.exec(options.onSwipe, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                    element.fire("swipe", {
                        event: event,
                        direction: this.direction,
                        distance: this.distance,
                        duration: this.duration,
                        fingerCount: this.fingerCount,
                        fingerData: this.fingerData,
                        currentDirection: this.currentDirection
                    });

                    if (ret === false) return false;

                    //trigger direction specific event handlers
                    switch (this.direction) {
                        case TouchConst.LEFT:
                            element.trigger('swipeLeft', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeLeft, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipeleft", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.RIGHT:
                            element.trigger('swipeRight', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeRight, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swiperight", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.UP:
                            element.trigger('swipeUp', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeUp, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipeup", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.DOWN:
                            element.trigger('swipeDown', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeDown, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipedown", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;
                    }
                }
            }


            //PINCHES....
            if (gesture === TouchConst.PINCH) {
                element.trigger('pinchStatus', [phase, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);

                ret = Utils.exec(options.onPinchStatus, [event, phase, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                element.fire("pinchstatus", {
                    event: event,
                    phase: phase,
                    direction: this.pinchDirection,
                    distance: this.pinchDistance,
                    duration: this.duration,
                    fingerCount: this.fingerCount,
                    fingerData: this.fingerData,
                    zoom: this.pinchZoom
                });
                if (ret === false) return false;

                if (phase === TouchConst.PHASE_END && this.validatePinch()) {

                    switch (this.pinchDirection) {
                        case TouchConst.IN:
                            element.trigger('pinchIn', [this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);
                            ret = Utils.exec(options.onPinchIn, [event, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                            element.fire("pinchin", {
                                event: event,
                                direction: this.pinchDirection,
                                distance: this.pinchDistance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                zoom: this.pinchZoom
                            });
                            break;

                        case TouchConst.OUT:
                            element.trigger('pinchOut', [this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);
                            ret = Utils.exec(options.onPinchOut, [event, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                            element.fire("pinchout", {
                                event: event,
                                direction: this.pinchDirection,
                                distance: this.pinchDistance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                zoom: this.pinchZoom
                            });
                            break;
                    }
                }
            }

            if (gesture === TouchConst.TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {

                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);

                    //If we are also looking for doubelTaps, wait incase this is one...
                    if (this.hasDoubleTap() && !this.inDoubleTap()) {
                        this.doubleTapStartTime = this.getTimeStamp();

                        //Now wait for the double tap timeout, and trigger this single tap
                        //if its not cancelled by a double tap
                        this.singleTapTimeout = setTimeout($.proxy(function() {
                            this.doubleTapStartTime = null;
                            ret = Utils.exec(options.onTap, [event, event.target], element[0]);
                            element.fire("tap", {
                                event: event,
                                target: event.target
                            });
                        }, this), options.doubleTapThreshold);

                    } else {
                        this.doubleTapStartTime = null;
                        ret = Utils.exec(options.onTap, [event, event.target], element[0]);
                        element.fire("tap", {
                            event: event,
                            target: event.target
                        });
                    }
                }
            } else if (gesture === TouchConst.DOUBLE_TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {
                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);
                    this.doubleTapStartTime = null;

                    ret = Utils.exec(options.onDoubleTap, [event, event.target], element[0]);
                    element.fire("doubletap", {
                        event: event,
                        target: event.target
                    });
                }
            } else if (gesture === TouchConst.LONG_TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {
                    clearTimeout(this.singleTapTimeout);
                    this.doubleTapStartTime = null;

                    ret = Utils.exec(options.onLongTap, [event, event.target], element[0]);
                    element.fire("longtap", {
                        event: event,
                        target: event.target
                    });
                }
            }

            return ret;
        },

        validateSwipeDistance: function() {
            var valid = true;
            //If we made it past the min swipe distance..
            if (this.options.threshold !== null) {
                valid = this.distance >= this.options.threshold;
            }

            return valid;
        },

        didSwipeBackToCancel: function() {
            var options = this.options;
            var cancelled = false;
            if (options.cancelThreshold !== null && this.direction !== null) {
                cancelled = (this.getMaxDistance(this.direction) - this.distance) >= options.cancelThreshold;
            }

            return cancelled;
        },

        validatePinchDistance: function() {
            if (this.options.pinchThreshold !== null) {
                return this.pinchDistance >= this.options.pinchThreshold;
            }
            return true;
        },

        validateSwipeTime: function() {
            var result, options = this.options;

            if (options.maxTimeThreshold) {
                result = this.duration < options.maxTimeThreshold;
            } else {
                result = true;
            }

            return result;
        },

        validateDefaultEvent: function(e, direction) {
            var options = this.options;

            //If the option is set, allways allow the event to bubble up (let user handle weirdness)
            if (options.preventDefaultEvents === false) {
                return;
            }

            if (options.allowPageScroll === TouchConst.NONE) {
                e.preventDefault();
            } else {
                var auto = options.allowPageScroll === TouchConst.AUTO;

                switch (direction) {
                    case TouchConst.LEFT:
                        if ((options.onSwipeLeft !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.HORIZONTAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.RIGHT:
                        if ((options.onSwipeRight !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.HORIZONTAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.UP:
                        if ((options.onSwipeUp !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.VERTICAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.DOWN:
                        if ((options.onSwipeDown !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.VERTICAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.NONE:

                        break;
                }
            }
        },

        validatePinch: function() {
            var hasCorrectFingerCount = this.validateFingers();
            var hasEndPoint = this.validateEndPoint();
            var hasCorrectDistance = this.validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
        },

        hasPinches: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.options.onPinchStatus || this.options.onPinchIn || this.options.onPinchOut);
        },

        didPinch: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validatePinch() && this.hasPinches());
        },

        validateSwipe: function() {
            //Check validity of swipe
            var hasValidTime = this.validateSwipeTime();
            var hasValidDistance = this.validateSwipeDistance();
            var hasCorrectFingerCount = this.validateFingers();
            var hasEndPoint = this.validateEndPoint();
            var didCancel = this.didSwipeBackToCancel();

            // if the user swiped more than the minimum length, perform the appropriate action
            // hasValidDistance is null when no distance is set
            return !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
        },

        hasSwipes: function() {
            var o = this.options;
            //Enure we dont return 0 or null for false values
            return !!(
                o.onSwipe !== Metro.noop
                || o.onSwipeStatus  !== Metro.noop
                || o.onSwipeLeft  !== Metro.noop
                || o.onSwipeRight  !== Metro.noop
                || o.onSwipeUp  !== Metro.noop
                || o.onSwipeDown !== Metro.noop
            );
        },

        didSwipe: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateSwipe() && this.hasSwipes());
        },

        validateFingers: function() {
            //The number of fingers we want were matched, or on desktop we ignore
            return ((this.fingerCount === this.options.fingers || this.options.fingers === TouchConst.ALL_FINGERS) || !TouchConst.SUPPORTS_TOUCH);
        },

        validateEndPoint: function() {
            //We have an end value for the finger
            return this.fingerData[0].end.x !== 0;
        },

        hasTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onTap !== Metro.noop;
        },

        hasDoubleTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onDoubleTap !== Metro.noop;
        },

        hasLongTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onLongTap !== Metro.noop;
        },

        validateDoubleTap: function() {
            if (this.doubleTapStartTime == null) {
                return false;
            }
            var now = this.getTimeStamp();
            return (this.hasDoubleTap() && ((now - this.doubleTapStartTime) <= this.options.doubleTapThreshold));
        },

        inDoubleTap: function() {
            return this.validateDoubleTap();
        },

        validateTap: function() {
            return ((this.fingerCount === 1 || !TouchConst.SUPPORTS_TOUCH) && (isNaN(this.distance) || this.distance < this.options.threshold));
        },

        validateLongTap: function() {
            var options = this.options;
            //slight threshold on moving finger
            return ((this.duration > options.longTapThreshold) && (this.distance < TouchConst.DOUBLE_TAP_THRESHOLD)); // check double_tab_threshold where from
        },

        didTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateTap() && this.hasTap());
        },

        didDoubleTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateDoubleTap() && this.hasDoubleTap());
        },

        didLongTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateLongTap() && this.hasLongTap());
        },

        startMultiFingerRelease: function(event) {
            this.previousTouchEndTime = this.getTimeStamp();
            this.fingerCountAtRelease = event.touches.length + 1;
        },

        cancelMultiFingerRelease: function() {
            this.previousTouchEndTime = 0;
            this.fingerCountAtRelease = 0;
        },

        inMultiFingerRelease: function() {
            var withinThreshold = false;

            if (this.previousTouchEndTime) {
                var diff = this.getTimeStamp() - this.previousTouchEndTime;
                if (diff <= this.options.fingerReleaseThreshold) {
                    withinThreshold = true;
                }
            }

            return withinThreshold;
        },

        getTouchInProgress: function() {
            var element = this.element;
            //strict equality to ensure only true and false are returned
            return (element.data('intouch') === true);
        },

        setTouchInProgress: function(val) {
            var element = this.element;

            //If destroy is called in an event handler, we have no el, and we have already cleaned up, so return.
            if(!element) { return; }

            //Add or remove event listeners depending on touch status
            if (val === true) {
                element.on(this.MOVE_EV, $.proxy(this.touchMove, this));
                element.on(this.END_EV, $.proxy(this.touchEnd, this));

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (this.LEAVE_EV) {
                    element.on(this.LEAVE_EV, $.proxy(this.touchLeave, this));
                }
            } else {

                element.off(this.MOVE_EV);
                element.off(this.END_EV);

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (this.LEAVE_EV) {
                    element.off(this.LEAVE_EV);
                }
            }

            //strict equality to ensure only true and false can update the value
            element.data('intouch', val === true);
        },

        createFingerData: function(id, evt) {
            var f = {
                start: {
                    x: 0,
                    y: 0
                },
                last: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                }
            };
            f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX;
            f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY;
            this.fingerData[id] = f;
            return f;
        },

        updateFingerData: function(evt) {
            var id = evt.identifier !== undefined ? evt.identifier : 0;
            var f = this.getFingerData(id);

            if (f === null) {
                f = this.createFingerData(id, evt);
            }

            f.last.x = f.end.x;
            f.last.y = f.end.y;

            f.end.x = evt.pageX || evt.clientX;
            f.end.y = evt.pageY || evt.clientY;

            return f;
        },

        getFingerData: function(id) {
            return this.fingerData[id] || null;
        },

        setMaxDistance: function(direction, distance) {
            if (direction === TouchConst.NONE) return;
            distance = Math.max(distance, this.getMaxDistance(direction));
            this.maximumsMap[direction].distance = distance;
        },

        getMaxDistance: function(direction) {
            return (this.maximumsMap[direction]) ? this.maximumsMap[direction].distance : undefined;
        },

        createMaximumsData: function() {
            var maxData = {};
            maxData[TouchConst.LEFT] = this.createMaximumVO(TouchConst.LEFT);
            maxData[TouchConst.RIGHT] = this.createMaximumVO(TouchConst.RIGHT);
            maxData[TouchConst.UP] = this.createMaximumVO(TouchConst.UP);
            maxData[TouchConst.DOWN] = this.createMaximumVO(TouchConst.DOWN);

            return maxData;
        },

        createMaximumVO: function(dir) {
            return {
                direction: dir,
                distance: 0
            }
        },

        calculateDuration: function(){
            return this.endTime - this.startTime;
        },

        calculateTouchesDistance: function(startPoint, endPoint){
            var diffX = Math.abs(startPoint.x - endPoint.x);
            var diffY = Math.abs(startPoint.y - endPoint.y);

            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
        },

        calculatePinchZoom: function(startDistance, endDistance){
            var percent = (endDistance / startDistance) * 100; // 1 ? 100
            return percent.toFixed(2);
        },

        calculatePinchDirection: function(){
            if (this.pinchZoom < 1) {
                return TouchConst.OUT;
            } else {
                return TouchConst.IN;
            }
        },

        calculateDistance: function(startPoint, endPoint){
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
        },

        calculateAngle: function(startPoint, endPoint){
            var x = startPoint.x - endPoint.x;
            var y = endPoint.y - startPoint.y;
            var r = Math.atan2(y, x); //radians
            var angle = Math.round(r * 180 / Math.PI); //degrees

            //ensure value is positive
            if (angle < 0) {
                angle = 360 - Math.abs(angle);
            }

            return angle;
        },

        calculateDirection: function(startPoint, endPoint){
            if( this.comparePoints(startPoint, endPoint) ) {
                return TouchConst.NONE;
            }

            var angle = this.calculateAngle(startPoint, endPoint);

            if ((angle <= 45) && (angle >= 0)) {
                return TouchConst.LEFT;
            } else if ((angle <= 360) && (angle >= 315)) {
                return TouchConst.LEFT;
            } else if ((angle >= 135) && (angle <= 225)) {
                return TouchConst.RIGHT;
            } else if ((angle > 45) && (angle < 135)) {
                return TouchConst.DOWN;
            } else {
                return TouchConst.UP;
            }
        },

        getTimeStamp: function(){
            return (new Date()).getTime();
        },

        getBounds: function (el) {
            el = $(el);
            var offset = el.offset();

            return {
                left: offset.left,
                right: offset.left + el.outerWidth(),
                top: offset.top,
                bottom: offset.top + el.outerHeight()
            };
        },

        isInBounds: function(point, bounds){
            return (point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom);
        },

        comparePoints: function(pointA, pointB) {
            return (pointA.x === pointB.x && pointA.y === pointB.y);
        },

        removeListeners: function() {
            var element = this.element;

            element.off(this.START_EV);
            element.off(this.CANCEL_EV);
            element.off(this.MOVE_EV);
            element.off(this.END_EV);

            //we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit
            if (this.LEAVE_EV) {
                element.off(this.LEAVE_EV);
            }

            this.setTouchInProgress(false);
        },

        enable: function(){
            this.disable();
            this.element.on(this.START_EV, this.touchStart);
            this.element.on(this.CANCEL_EV, this.touchCancel);
            return this.element;
        },

        disable: function(){
            this.removeListeners();
            return this.element;
        },

        changeAttribute: function(){
        },

        destroy: function(){
            this.removeListeners();
        }
    });

    Metro['touch'] = TouchConst;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TreeViewDefaultConfig = {
        treeviewDeferred: 0,
        showChildCount: false,
        duration: 100,
        onNodeClick: Metro.noop,
        onNodeDblClick: Metro.noop,
        onNodeDelete: Metro.noop,
        onNodeInsert: Metro.noop,
        onNodeClean: Metro.noop,
        onCheckClick: Metro.noop,
        onRadioClick: Metro.noop,
        onExpandNode: Metro.noop,
        onCollapseNode: Metro.noop,
        onTreeViewCreate: Metro.noop
    };

    Metro.treeViewSetup = function (options) {
        TreeViewDefaultConfig = $.extend({}, TreeViewDefaultConfig, options);
    };

    if (typeof window["metroTreeViewSetup"] !== undefined) {
        Metro.treeViewSetup(window["metroTreeViewSetup"]);
    }

    Metro.Component('tree-view', {
        init: function( options, elem ) {
            this._super(elem, options, TreeViewDefaultConfig);
            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._createTree();
            this._createEvents();

            $.each(element.find("input"), function(){
                if (!$(this).is(":checked")) return;
                that._recheck(this);
            });

            this._fireEvent("tree-view-create", {
                element: element
            });
        },

        _createIcon: function(data){
            var icon, src;

            src = Utils.isTag(data) ? $(data) : $("<img src='' alt=''>").attr("src", data);
            icon = $("<span>").addClass("icon");
            icon.html(src.outerHTML());

            return icon;
        },

        _createCaption: function(data){
            return $("<span>").addClass("caption").html(data);
        },


        _createToggle: function(){
            return $("<span>").addClass("node-toggle");
        },


        _createNode: function(data){
            var node;

            node = $("<li>");

            if (data.caption !== undefined) {
                node.prepend(this._createCaption(data.caption));
            }

            if (data.icon !== undefined) {
                node.prepend(this._createIcon(data.icon));
            }

            if (data.html !== undefined) {
                node.append(data.html);
            }

            return node;
        },

        _createTree: function(){
            var that = this, element = this.element, o = this.options;
            var nodes = element.find("li");

            element.addClass("treeview");

            $.each(nodes, function(){
                var node = $(this);
                var caption, icon;

                caption = node.data("caption");
                icon = node.data("icon");

                if (caption !== undefined) {
                    if (node.children("ul").length > 0 && o.showChildCount === true) {
                        caption += " ("+node.children("ul").children("li").length+")"
                    }
                    node.prepend(that._createCaption(caption));
                }

                if (icon !== undefined) {
                    node.prepend(that._createIcon(icon));
                }

                if (node.children("ul").length > 0) {

                    node.addClass("tree-node");

                    node.append(that._createToggle());

                    if (Utils.bool(node.attr("data-collapsed")) !== true) {
                        node.addClass("expanded");
                    } else {
                        node.children("ul").hide();
                    }
                }

            });
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".node-toggle", function(e){
                var toggle = $(this);
                var node = toggle.parent();

                that.toggleNode(node);

                e.preventDefault();
            });

            element.on(Metro.events.click, "li > .caption", function(e){
                var node = $(this).parent();

                that.current(node);

                that._fireEvent("node-click", {
                    node: node[0]
                });

                e.preventDefault();
            });

            element.on(Metro.events.dblclick, "li > .caption", function(e){
                var node = $(this).closest("li");
                var toggle = node.children(".node-toggle");
                var subtree = node.children("ul");

                if (toggle.length > 0 || subtree.length > 0) {
                    that.toggleNode(node);
                }

                that._fireEvent("node-dbl-click", {
                    node: node[0]
                })

                e.preventDefault();
            });

            element.on(Metro.events.click, "input[type=radio]", function(){
                var check = $(this);
                var checked = check.is(":checked");
                var node = check.closest("li");

                that.current(node);

                that._fireEvent("radio-click", {
                    checked: checked,
                    check: check[0],
                    node: node[0]
                });
            });

            element.on(Metro.events.click, "input[type=checkbox]", function(){
                var check = $(this);
                var checked = check.is(":checked");
                var node = check.closest("li");

                that._recheck(check);

                that._fireEvent("check-click", {
                    checked: checked,
                    check: check[0],
                    node: node[0]
                });
            });
        },

        _recheck: function(check){
            var element = this.element;
            var checked, node, checks, all_checks;

            check = $(check);

            checked = check.is(":checked");
            node = check.closest("li");

            this.current(node);

            // down
            checks = check.closest("li").find("ul input[type=checkbox]");
            checks.attr("data-indeterminate", false);
            checks.prop("checked", checked);
            checks.trigger('change');

            all_checks = [];

            $.each(element.find("input[type=checkbox]"), function(){
                all_checks.push(this);
            });

            $.each(all_checks.reverse(), function(){
                var ch = $(this);
                var children = ch.closest("li").children("ul").find("input[type=checkbox]").length;
                var children_checked = ch.closest("li").children("ul").find("input[type=checkbox]").filter(function(el){
                    return el.checked;
                }).length;

                if (children > 0 && children_checked === 0) {
                    ch.attr("data-indeterminate", false);
                    ch.prop("checked", false);
                    ch.trigger('change');
                }

                if (children_checked === 0) {
                    ch.attr("data-indeterminate", false);
                } else {
                    if (children_checked > 0 && children > children_checked) {
                        ch.attr("data-indeterminate", true);
                    } else if (children === children_checked) {
                        ch.attr("data-indeterminate", false);
                        ch.prop("checked", true);
                        ch.trigger('change');
                    }
                }
            });
        },

        current: function(node){
            var element = this.element;

            if (node === undefined) {
                return element.find("li.current")
            }

            element.find("li").removeClass("current");
            node.addClass("current");
        },

        toggleNode: function(n){
            var node = $(n);
            var o = this.options;
            var func;
            var toBeExpanded = !node.data("collapsed");//!node.hasClass("expanded");

            node.toggleClass("expanded");
            node.data("collapsed", toBeExpanded);

            func = toBeExpanded === true ? "slideUp" : "slideDown";

            if (!toBeExpanded) {

                this._fireEvent("expand-node", {
                    node: node[0]
                });

            } else {

                this._fireEvent("collapse-node", {
                    node: node[0]
                });

            }

            node.children("ul")[func](o.duration);
        },

        addTo: function(node, data){
            var element = this.element;
            var target;
            var new_node;
            var toggle;

            if (node === null) {
                target = element;
            } else {
                node = $(node);
                target = node.children("ul");
                if (target.length === 0) {
                    target = $("<ul>").appendTo(node);
                    toggle = this._createToggle();
                    toggle.appendTo(node);
                    node.addClass("expanded");
                }
            }

            new_node = this._createNode(data);

            new_node.appendTo(target);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node ? node[0] : null
            });

            return new_node;
        },

        insertBefore: function(node, data){
            var new_node = this._createNode(data);

            if (Utils.isNull(node)) {
                return this.addTo(node, data);
            }

            node = $(node);
            new_node.insertBefore(node);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node ? node[0] : null
            });

            return new_node;
        },

        insertAfter: function(node, data){
            var new_node = this._createNode(data);

            if (Utils.isNull(node)) {
                return this.addTo(node, data);
            }

            node = $(node);
            new_node.insertAfter(node);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node[0]
            });

            return new_node;
        },

        del: function(node){
            var element = this.element;
            node = $(node);
            var parent_list = node.closest("ul");
            var parent_node = parent_list.closest("li");

            this._fireEvent("node-delete", {
                node: node[0]
            });

            node.remove();

            if (parent_list.children().length === 0 && !parent_list.is(element)) {
                parent_list.remove();
                parent_node.removeClass("expanded");
                parent_node.children(".node-toggle").remove();
            }
        },

        clean: function(node){
            node = $(node);
            node.children("ul").remove();
            node.removeClass("expanded");
            node.children(".node-toggle").remove();

            this._fireEvent("node-clean", {
                node: node[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".node-toggle");
            element.off(Metro.events.click, "li > .caption");
            element.off(Metro.events.dblclick, "li > .caption");
            element.off(Metro.events.click, "input[type=radio]");
            element.off(Metro.events.click, "input[type=checkbox]");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Colors = Metro.colors;
    var ValidatorFuncs = {
        required: function(val){
            if (Array.isArray(val)) {
                return val.length > 0 ? val : false;
            } else {
                return Utils.isValue(val) ? val.trim() : false;
            }
        },
        length: function(val, len){
            if (Array.isArray(val)) {return val.length === parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length === parseInt(len);
        },
        minlength: function(val, len){
            if (Array.isArray(val)) {return val.length >= parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length >= parseInt(len);
        },
        maxlength: function(val, len){
            if (Array.isArray(val)) {return val.length <= parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length <= parseInt(len);
        },
        min: function(val, min_value){
            if (!Utils.isValue(min_value) || isNaN(min_value)) {
                return false;
            }
            if (!this.number(val)) {
                return false;
            }
            if (isNaN(val)) {
                return false;
            }
            return Number(val) >= Number(min_value);
        },
        max: function(val, max_value){
            if (!Utils.isValue(max_value) || isNaN(max_value)) {
                return false;
            }
            if (!this.number(val)) {
                return false;
            }
            if (isNaN(val)) {
                return false;
            }
            return Number(val) <= Number(max_value);
        },
        email: function(val){
            /* eslint-disable-next-line */
            return /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i.test(val);
        },
        domain: function(val){
            /* eslint-disable-next-line */
            return /^((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/.test(val);
        },
        url: function(val){
            /* eslint-disable-next-line */
            return /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(val);
        },
        date: function(val, format, locale){
            if (Utils.isNull(format)) {
                return String(new Date(val)).toLowerCase() !== "invalid date";
            } else {
                return String(val.toDate(format, locale)).toLowerCase() !== "invalid date";
            }
        },
        number: function(val){
            return !isNaN(val);
        },
        integer: function(val){
            return Utils.isInt(val);
        },
        float: function(val){
            return Utils.isFloat(val);
        },
        digits: function(val){
            return /^\d+$/.test(val);
        },
        hexcolor: function(val){
            /* eslint-disable-next-line */
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(val);
        },
        color: function(val){
            if (!Utils.isValue(val)) return false;
            return Colors.color(val, Colors.PALETTES.STANDARD) !== false;
        },
        pattern: function(val, pat){
            if (!Utils.isValue(val)) return false;
            if (!Utils.isValue(pat)) return false;
            var reg = new RegExp(pat);
            return reg.test(val);
        },
        compare: function(val, val2){
            return val === val2;
        },
        not: function(val, not_this){
            return val !== not_this;
        },
        notequals: function(val, val2){
            if (Utils.isNull(val)) return false;
            if (Utils.isNull(val2)) return false;
            return val.trim() !== val2.trim();
        },
        equals: function(val, val2){
            if (Utils.isNull(val)) return false;
            if (Utils.isNull(val2)) return false;
            return val.trim() === val2.trim();
        },
        custom: function(val, func){
            if (Utils.isFunc(func) === false) {
                return false;
            }
            return Utils.exec(func, [val]);
        },

        is_control: function(el){
            return el.parent().hasClass("input")
                || el.parent().hasClass("select")
                || el.parent().hasClass("textarea")
                || el.parent().hasClass("checkbox")
                || el.parent().hasClass("switch")
                || el.parent().hasClass("radio")
                || el.parent().hasClass("spinner")
                ;
        },

        reset_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().removeClass("invalid valid");
            } else {
                input.removeClass("invalid valid");
            }
        },

        set_valid_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().addClass("valid");
            } else {
                input.addClass("valid");
            }
        },

        set_invalid_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().addClass("invalid");
            } else {
                input.addClass("invalid");
            }
        },

        reset: function(form){
            var that = this;
            $.each($(form).find("[data-validate]"), function(){
                that.reset_state(this);
            });

            return this;
        },

        validate: function(el, result, cb_ok, cb_error, required_mode){
            var this_result = true;
            var input = $(el);
            var funcs = input.data('validate') !== undefined ? String(input.data('validate')).split(" ").map(function(s){return s.trim();}) : [];
            var errors = [];
            var hasForm = input.closest('form').length > 0;
            var attr_name, radio_checked;

            if (funcs.length === 0) {
                return true;
            }

            this.reset_state(input);

            if (input.attr('type') && input.attr('type').toLowerCase() === "checkbox") {
                if (funcs.indexOf('required') === -1) {
                    this_result = true;
                } else {
                    this_result = input.is(":checked");
                }

                if (this_result === false) {
                    errors.push('required');
                }

                if (result !== undefined) {
                    result.val += this_result ? 0 : 1;
                }
            } else if (input.attr('type') && input.attr('type').toLowerCase() === "radio") {
                attr_name = input.attr('name');
                if (typeof attr_name  === undefined) {
                    this_result = true;
                } else {
                    /*
                    * Fix with escaped name by nlared https://github.com/nlared
                    * */
                    radio_checked = $("input[name=" + attr_name.replace("[", "\\\[").replace("]", "\\\]") + "]:checked"); // eslint-disable-line
                    this_result = radio_checked.length > 0;
                }
                if (result !== undefined) {
                    result.val += this_result ? 0 : 1;
                }
            } else {
                $.each(funcs, function(){
                    if (this_result === false) return;
                    var rule = this.split("=");
                    var f, a, b;

                    f = rule[0]; rule.shift();
                    a = rule.join("=");

                    if (['compare', 'equals', 'notequals'].indexOf(f) > -1) {
                        a = hasForm ? input[0].form.elements[a].value : $("[name="+a+"]").val();
                    }

                    if (f === 'date') {
                        a = input.attr("data-value-format");
                        b = input.attr("data-value-locale");
                    }

                    if (Utils.isFunc(ValidatorFuncs[f]) === false)  {
                        this_result = true;
                    } else {
                        if (required_mode === true || f === "required") {
                            this_result = ValidatorFuncs[f](input.val(), a, b);
                        } else {
                            if (input.val().trim() !== "") {
                                this_result = ValidatorFuncs[f](input.val(), a, b);
                            } else {
                                this_result = true;
                            }
                        }
                    }

                    if (this_result === false) {
                        errors.push(f);
                    }

                    if (result !== undefined) {
                        result.val += this_result ? 0 : 1;
                    }
                });
            }

            if (this_result === false) {
                this.set_invalid_state(input);

                if (result !== undefined) {
                    result.log.push({
                        input: input[0],
                        name: input.attr("name"),
                        value: input.val(),
                        funcs: funcs,
                        errors: errors
                    });
                }

                if (cb_error !== undefined) Utils.exec(cb_error, [input, input.val()], input[0]);

            } else {
                this.set_valid_state(input);

                if (cb_ok !== undefined) Utils.exec(cb_ok, [input, input.val()], input[0]);
            }

            return this_result;
        }
    };

    Metro['validator'] = ValidatorFuncs;

    var ValidatorDefaultConfig = {
        validatorDeferred: 0,
        submitTimeout: 200,
        interactiveCheck: false,
        clearInvalid: 0,
        requiredMode: true,
        useRequiredClass: true,
        onBeforeSubmit: Metro.noop_true,
        onSubmit: Metro.noop,
        onError: Metro.noop,
        onValidate: Metro.noop,
        onErrorForm: Metro.noop,
        onValidateForm: Metro.noop,
        onValidatorCreate: Metro.noop
    };

    Metro.validatorSetup = function (options) {
        ValidatorDefaultConfig = $.extend({}, ValidatorDefaultConfig, options);
    };

    if (typeof window["metroValidatorSetup"] !== undefined) {
        Metro.validatorSetup(window["metroValidatorSetup"]);
    }

    Metro.Component('validator', {
        name: "Validator",

        init: function( options, elem ) {
            this._super(elem, options, ValidatorDefaultConfig, {
                _onsubmit: null,
                _onreset: null,
                result: []
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var inputs = element.find("[data-validate]");

            element
                .attr("novalidate", 'novalidate');

            $.each(inputs, function(){
                var input = $(this);
                var funcs = input.data("validate");
                var required = funcs.indexOf("required") > -1;
                if (required && o.useRequiredClass === true) {
                    if (ValidatorFuncs.is_control(input)) {
                        input.parent().addClass("required");
                    } else {
                        input.addClass("required");
                    }
                }
                if (o.interactiveCheck === true) {
                    input.on(Metro.events.inputchange, function () {
                        ValidatorFuncs.validate(this, undefined, undefined, undefined, o.requiredMode);
                    });
                }
            });

            this._onsubmit = null;
            this._onreset = null;

            if (element[0].onsubmit !== null) {
                this._onsubmit = element[0].onsubmit;
                element[0].onsubmit = null;
            }

            if (element[0].onreset !== null) {
                this._onreset = element[0].onreset;
                element[0].onreset = null;
            }

            element[0].onsubmit = function(){
                return that._submit();
            };

            element[0].onreset = function(){
                return that._reset();
            };

            this._fireEvent("validator-create", {
                element: element
            });
        },

        _reset: function(){
            ValidatorFuncs.reset(this.element);
            if (this._onsubmit !==  null) Utils.exec(this._onsubmit, null, this.element[0]);
        },

        _submit: function(){
            var that = this, element = this.element, o = this.options;
            var form = this.elem;
            var inputs = element.find("[data-validate]");
            var submit = element.find("input[type=submit], button[type=submit]");
            var result = {
                val: 0,
                log: []
            };
            var formData = $.serializeToArray(element);

            if (submit.length > 0) {
                submit.attr('disabled', 'disabled').addClass('disabled');
            }

            $.each(inputs, function(){
                ValidatorFuncs.validate(this, result, o.onValidate, o.onError, o.requiredMode);
            });

            submit.removeAttr("disabled").removeClass("disabled");

            result.val += Utils.exec(o.onBeforeSubmit, [formData], this.elem) === false ? 1 : 0;

            if (result.val === 0) {

                this._fireEvent("validate-form", {
                    data: formData
                });

                setTimeout(function(){
                    // TODO need fix event name to equivalent
                    Utils.exec(o.onSubmit, [formData], form);
                    element.fire("formsubmit", {
                        data: formData
                    });
                    if (that._onsubmit !==  null) Utils.exec(that._onsubmit, null, form);
                }, o.submitTimeout);
            } else {

                this._fireEvent("error-form", {
                    log: result.log,
                    data: formData
                });

                if (o.clearInvalid > 0) {
                    setTimeout(function(){
                        $.each(inputs, function(){
                            var inp  = $(this);
                            if (ValidatorFuncs.is_control(inp)) {
                                inp.parent().removeClass("invalid");
                            } else {
                                inp.removeClass("invalid");
                            }
                        })
                    }, o.clearInvalid);
                }
            }

            return result.val === 0;
        },

        changeAttribute: function(){
        }
    });
}(Metro, m4q));

/**
 * Component Vegas based on Vegas by Jay Salvat (http://jaysalvat.com/)
 * Original code https://github.com/jaysalvat/vegas
 * MIT License, Copyright 2018 Jay Salvat
 *
 * Adaptation for Metro 4 by Serhii Pimenov,
 * Copyright 2020 Serhii Pimenov
 */

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var VegasDefaultConfig = {
        duration: 4000,
        animationDuration: null,
        transitionDuration: null,
        transition: "fade",
        animation: null,
        slides: [],
        shuffle: false,
        align: "center",
        valign: "center",
        loop: true,
        autoplay: true,
        mute: true,
        cover: true,
        preload: true,
        timer: true,
        overlay: 2,
        color: null,
        volume: 1,
        onPlay: Metro.noop,
        onPause: Metro.noop,
        onEnd: Metro.noop,
        onWalk: Metro.noop,
        onNext: Metro.noop,
        onPrev: Metro.noop,
        onJump: Metro.noop,
        onVegasCreate: Metro.noop
    };

    Metro.vegasSetup = function (options) {
        VegasDefaultConfig = $.extend({}, VegasDefaultConfig, options);
    };

    if (typeof window["metroVegasSetup"] !== undefined) {
        Metro.vegasSetup(window["metroVegasSetup"]);
    }

    Metro.Component('vegas', {

        videoCache: {},

        init: function( options, elem ) {
            this.transitions = [
                "fade", "fade2",
                "slideLeft", "slideLeft2",
                "slideRight", "slideRight2",
                "slideUp", "slideUp2",
                "slideDown", "slideDown2",
                "zoomIn", "zoomIn2",
                "zoomOut", "zoomOut2",
                "swirlLeft", "swirlLeft2",
                "swirlRight", "swirlRight2"
            ];
            this.animations = [
                "kenburns",
                "kenburnsUp",
                "kenburnsDown",
                "kenburnsRight",
                "kenburnsLeft",
                "kenburnsUpLeft",
                "kenburnsUpRight",
                "kenburnsDownLeft",
                "kenburnsDownRight"
            ];

            this.support = {
                objectFit:  'objectFit'  in document.body.style,
                video: !/(Android|webOS|Phone|iPad|iPod|BlackBerry|Windows Phone)/i.test(navigator.userAgent)
            }

            this._super(elem, options, VegasDefaultConfig, {
                slide: 0,
                slides: null,
                total: 0,
                noshow: false,
                paused: false,
                ended: false,
                timer: null,
                overlay: null,
                first: true,
                timeout: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this.slides = Utils.isObject(this.options.slides) || [];
            this.total = this.slides.length;
            this.noshow = this.total < 2;
            this.paused = !this.options.autoplay || this.noshow;

            if (this.options.shuffle) {
                this.slides.shuffle();
            }

            if (this.options.preload) {
                this._preload();
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("vegas-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var isBody = element[0].tagName === 'BODY';
            var wrapper;

            if (!isBody) {
                element.css('height', element.css('height')); // it is not clear why this line

                wrapper = $('<div class="vegas-wrapper">')
                    .css('overflow', element.css('overflow'))
                    .css('padding',  element.css('padding'));

                if (!element.css('padding')) {
                    wrapper
                        .css('padding-top',    element.css('padding-top'))
                        .css('padding-bottom', element.css('padding-bottom'))
                        .css('padding-left',   element.css('padding-left'))
                        .css('padding-right',  element.css('padding-right'));
                }

                element.children().appendTo(wrapper);
                element.clear();
            }

            element.addClass("vegas-container");

            if (!isBody) {
                element.append(wrapper);
            }

            if (o.timer) {
                this.timer = $('<div class="vegas-timer"><div class="vegas-timer-progress">');
                element.append(this.timer);
            }

            if (o.overlay) {
                this.overlay = $('<div class="vegas-overlay">').addClass('overlay' + (typeof o.overlay === 'boolean' || isNaN(o.overlay) ? 2 : +o.overlay));
                element.append(this.overlay);
            }

            setTimeout(function(){
                Utils.exec(o.onPlay, null, element[0]);
                that._goto(that.slide);
            },1)
        },

        _createEvents: function(){
        },

        _preload: function(){
            var img, i;

            for (i = 0; i < this.slides.length; i++) {

                var obj = this.slides[i];

                if (obj.src) {
                    img = new Image();
                    img.src = this.slides[i].src;
                }

                if (obj.video) {
                    if (obj.video instanceof Array) {
                        this._video(obj.video);
                    } else {
                        this._video(obj.video.src);
                    }
                }
            }
        },

        _slideShow: function () {
            var that = this, o = this.options;

            if (this.total > 1 && !this.ended && !this.paused && !this.noshow) {
                this.timeout = setTimeout(function () {
                    that.next();
                }, o.duration);
            }
        },

        _timer: function (state) {
            var that = this, o = this.options;

            clearTimeout(this.timeout);

            if (!this.timer) {
                return;
            }

            this.timer
                .removeClass('vegas-timer-running')
                .find('div')
                .css('transition-duration', '0ms');

            if (this.ended || this.paused || this.noshow) {
                return;
            }

            if (state) {
                setTimeout(function () {
                    that.timer
                        .addClass('vegas-timer-running')
                        .find('div')
                        .css('transition-duration', +o.duration - 100 + 'ms');
                }, 100);
            }
        },

        _fadeSoundIn: function(video, duration){
            var o = this.options;

            $.animate({
                el: video,
                draw: {
                    volume: +o.volume
                },
                dur: duration
            })
        },

        _fadeSoundOut: function(video, duration){
            $.animate({
                el: video,
                draw: {
                    volume: 0
                },
                dur: duration
            })
        },

        _video: function(sources){
            var video, source;
            var cacheKey = sources.toString();

            if (this.videoCache[cacheKey]) {
                return this.videoCache[cacheKey];
            }

            if (!Array.isArray(sources)) {
                sources = [sources];
            }

            video = document.createElement("video");
            video.preload = true;

            sources.forEach(function(src){
                source = document.createElement("source");
                source.src = src;
                video.appendChild(source);
            });

            this.videoCache[cacheKey] = video;

            return video;
        },

        _goto: function(n){
            var that = this, element = this.element, o = this.options;

            if (typeof this.slides[n] === 'undefined') {
                n = 0;
            }

            this.slide = n;

            var $slide, $inner, video, img, $video;
            var slides = element.children(".vegas-slide");
            var obj = this.slides[n];
            var cover = o.cover;
            var transition, animation;
            var transitionDuration, animationDuration;

            if (this.first) {
                this.first = false;
            }

            if (cover !== 'repeat') {
                if (cover === true) {
                    cover = 'cover';
                } else if (cover === false) {
                    cover = 'contain';
                }
            }

            if (o.transition === 'random') {
                transition = $.random(this.transitions);
            } else {
                transition = o.transition ? o.transition : this.transitions[0];
            }

            if (o.animation === 'random') {
                animation = $.random(this.animations);
            } else {
                animation = o.animation ? o.animation : this.animations[0];
            }

            if (!o.transitionDuration) {
                transitionDuration = +o.duration;
            } else if (o.transitionDuration === 'auto' || +o.transitionDuration > +o.duration) {
                transitionDuration = +o.duration;
            } else {
                transitionDuration = +o.transitionDuration;
            }

            if (!o.animationDuration) {
                animationDuration = +o.duration;
            } else if (o.animationDuration === 'auto' || +o.animationDuration > +o.duration) {
                animationDuration = +o.duration;
            } else {
                animationDuration = +o.animationDuration;
            }

            $slide = $("<div>").addClass("vegas-slide").addClass('vegas-transition-' + transition);

            if (this.support.video && obj.video) {
                video = obj.video instanceof Array ? this._video(obj.video) : this._video(obj.video.src);
                video.loop = obj.video.loop ? obj.video.loop : o.loop;
                video.muted = obj.video.mute ? obj.video.mute : o.mute;

                if (!video.muted) {
                    this._fadeSoundIn(video, transitionDuration);
                } else {
                    video.pause();
                }

                $video = $(video)
                    .addClass('vegas-video')
                    .css('background-color', o.color || '#000000');

                if (this.support.objectFit) {
                    $video
                        .css('object-position', o.align + ' ' + o.valign)
                        .css('object-fit', cover)
                        .css('width',  '100%')
                        .css('height', '100%');
                } else if (cover === 'contain') {
                    $video
                        .css('width',  '100%')
                        .css('height', '100%');
                }

                $slide.append($video);
            } else {
                img = new Image();
                $inner = $("<div>").addClass('vegas-slide-inner')
                    .css({
                        backgroundImage: 'url("'+obj.src+'")',
                        backgroundColor: o.color || '#000000',
                        backgroundPosition: o.align + ' ' + o.valign
                    });

                if (cover === 'repeat') {
                    $inner.css('background-repeat', 'repeat');
                } else {
                    $inner.css('background-size', cover);
                }

                if (animation) {
                    $inner
                        .addClass('vegas-animation-' + animation)
                        .css('animation-duration',  animationDuration + 'ms');
                }

                $slide.append($inner);
            }

            if (slides.length) {
                slides.eq(slides.length - 1).after($slide);
            } else {
                element.prepend($slide);
            }

            slides
                .css('transition', 'all 0ms')
                .each(function(){
                    this.className  = 'vegas-slide';

                    if (this.tagName === 'VIDEO') {
                        this.className += ' vegas-video';
                    }

                    if (transition) {
                        this.className += ' vegas-transition-' + transition;
                        this.className += ' vegas-transition-' + transition + '-in';
                    }
                }
            );

            this._timer(false);

            function go(){
                that._timer(true);
                setTimeout(function () {
                    slides
                        .css('transition', 'all ' + transitionDuration + 'ms')
                        .addClass('vegas-transition-' + transition + '-out');

                    slides.each(function () {
                        var video = slides.find('video').get(0);

                        if (video) {
                            video.volume = 1;
                            that._fadeSoundOut(video, transitionDuration);
                        }
                    });

                    $slide
                        .css('transition', 'all ' + transitionDuration + 'ms')
                        .addClass('vegas-transition-' + transition + '-in');

                    for (var i = 0; i < slides.length - 1; i++) {
                        slides.eq(i).remove();
                    }

                    that._fireEvent("walk", {
                        slide: that.current(true)
                    });

                    that._slideShow();
                }, 100);
            }

            if (video) {
                if (video.readyState === 4) {
                    video.currentTime = 0;
                }

                video.play();
                go();
            } else {
                img.src = obj.src;

                if (img.complete) {
                    go();
                } else {
                    img.onload = go;
                }
            }
        },

        _end: function(){
            this.ended = this.options.autoplay;
            this._timer(false);

            this._fireEvent("end", {
                slide: this.current(true)
            });
        },

        play: function(){
            if (!this.paused) {
                return ;
            }

            this._fireEvent("play", {
                slide: this.current(true)
            });

            this.paused = false;
            this.next();
        },

        pause: function(){
            this._timer(false);
            this.paused = true;

            this._fireEvent("pause", {
                slide: this.current(true)
            });
        },

        toggle: function(){
            this.paused ? this.play() : this.pause();
        },

        playing: function(){
            return !this.paused && !this.noshow;
        },

        current: function (advanced) {
            if (advanced) {
                return {
                    slide: this.slide,
                    data:  this.slides[this.slide]
                };
            }
            return this.slide;
        },

        jump: function(n){
            if (n <= 0 || n > this.slides.length || n === this.slide + 1) {
                return this;
            }

            this.slide = n - 1;

            this._fireEvent("jump", {
                slide: this.current(true)
            })

            this._goto(this.slide);
        },

        next: function(){
            var o = this.options;

            this.slide++;

            if (this.slide >= this.slides.length) {
                if (!o.loop) {
                    return this._end();
                }

                this.slide = 0;
            }

            this._fireEvent("next", {
                slide: this.current(true)
            });

            this._goto(this.slide);
        },

        prev: function(){
            var o = this.options;

            this.slide--;

            if (this.slide < 0) {
                if (!o.loop) {
                    this.slide++;
                    return this._end();
                }

                this.slide = this.slides.length - 1;
            }

            this._fireEvent("prev", {
                slide: this.current(true)
            });

            this._goto(this.slide);
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var propName = $.camelCase(attributeName.replace("data-", ""));

            if (propName === 'slides') {
                o.slides = element.attr('data-slides');
                this.slides = Utils.isObject(o.slides) || [];
                this.total = this.slides.length;
                this.noshow = this.total < 2;
                this.paused = !this.options.autoplay || this.noshow;
            } else {
                if (typeof VegasDefaultConfig[propName] !== 'undefined')
                    o[propName] = JSON.parse(element.attr(attributeName));
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            clearTimeout(this.timeout);
            element.removeClass('vegas-container');
            element.find('> .vegas-slide').remove();
            element.find('> .vegas-wrapper').children().appendTo(element);
            element.find('> .vegas-wrapper').remove();

            if (o.timer) {
                this.timer.remove();
            }

            if (o.overlay) {
                this.overlay.remove();
            }

            return element[0];
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var VideoPlayerDefaultConfig = {
        videoDeferred: 0,
        src: null,

        poster: "",
        logo: "",
        logoHeight: 32,
        logoWidth: "auto",
        logoTarget: "",

        volume: .5,
        loop: false,
        autoplay: false,

        fullScreenMode: Metro.fullScreenMode.DESKTOP,
        aspectRatio: Metro.aspectRatio.HD,

        controlsHide: 3000,

        showLoop: true,
        showPlay: true,
        showStop: true,
        showMute: true,
        showFull: true,
        showStream: true,
        showVolume: true,
        showInfo: true,

        loopIcon: "<span class='default-icon-loop'></span>",
        stopIcon: "<span class='default-icon-stop'></span>",
        playIcon: "<span class='default-icon-play'></span>",
        pauseIcon: "<span class='default-icon-pause'></span>",
        muteIcon: "<span class='default-icon-mute'></span>",
        volumeLowIcon: "<span class='default-icon-low-volume'></span>",
        volumeMediumIcon: "<span class='default-icon-medium-volume'></span>",
        volumeHighIcon: "<span class='default-icon-high-volume'></span>",
        screenMoreIcon: "<span class='default-icon-enlarge'></span>",
        screenLessIcon: "<span class='default-icon-shrink'></span>",

        onPlay: Metro.noop,
        onPause: Metro.noop,
        onStop: Metro.noop,
        onEnd: Metro.noop,
        onMetadata: Metro.noop,
        onTime: Metro.noop,
        onVideoPlayerCreate: Metro.noop
    };

    Metro.videoPlayerSetup = function (options) {
        VideoPlayerDefaultConfig = $.extend({}, VideoPlayerDefaultConfig, options);
    };

    if (typeof window["metroVideoPlayerSetup"] !== undefined) {
        Metro.videoPlayerSetup(window["metroVideoPlayerSetup"]);
    }

    Metro.Component('video-player', {
        init: function( options, elem ) {
            this._super(elem, options, VideoPlayerDefaultConfig, {
                fullscreen: false,
                preloader: null,
                player: null,
                video: elem,
                stream: null,
                volume: null,
                volumeBackup: 0,
                muted: false,
                fullScreenInterval: false,
                isPlaying: false,
                id: Utils.elementId('video-player')
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (Metro.fullScreenEnabled === false) {
                o.fullScreenMode = Metro.fullScreenMode.WINDOW;
            }

            this._createPlayer();
            this._createControls();
            this._createEvents();
            this._setAspectRatio();

            if (o.autoplay === true) {
                this.play();
            }

            this._fireEvent("video-player-create", {
                element: element,
                player: this.player
            });
        },

        _createPlayer: function(){
            var element = this.element, o = this.options, video = this.video;
            var player = $("<div>").addClass("media-player video-player " + element[0].className);
            var preloader = $("<div>").addClass("preloader").appendTo(player);
            var logo = $("<a>").attr("href", o.logoTarget).addClass("logo").appendTo(player);

            player.insertBefore(element);
            element.appendTo(player);

            $.each(['muted', 'autoplay', 'controls', 'height', 'width', 'loop', 'poster', 'preload'], function(){
                element.removeAttr(this);
            });

            element.attr("preload", "auto");

            if (o.poster !== "") {
                element.attr("poster", o.poster);
            }

            video.volume = o.volume;

            preloader.activity({
                type: "cycle",
                style: "color"
            });

            preloader.hide();

            this.preloader = preloader;

            if (o.logo !== "") {
                $("<img>")
                    .css({
                        height: o.logoHeight,
                        width: o.logoWidth
                    })
                    .attr("src", o.logo).appendTo(logo);
            }

            if (o.src !== null) {
                this._setSource(o.src);
            }

            element[0].className = "";

            this.player = player;
        },

        _setSource: function(src){
            var element = this.element;

            element.find("source").remove();
            element.removeAttr("src");
            if (Array.isArray(src)) {
                $.each(src, function(){
                    var item = this;
                    if (item.src === undefined) return ;
                    $("<source>").attr('src', item.src).attr('type', item.type !== undefined ? item.type : '').appendTo(element);
                });
            } else {
                element.attr("src", src);
            }
        },

        _createControls: function(){
            var that = this, element = this.element, o = this.options, video = this.elem;

            var controls = $("<div>").addClass("controls").addClass(o.clsControls).insertAfter(element);

            var stream = $("<div>").addClass("stream").appendTo(controls);
            var streamSlider = $("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);

            var volume = $("<div>").addClass("volume").appendTo(controls);
            var volumeSlider = $("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);

            var infoBox = $("<div>").addClass("info-box").appendTo(controls);

            if (o.showInfo !== true) {
                infoBox.hide();
            }

            Metro.makePlugin(streamSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                clsComplete: "bg-cyan",
                hint: true,
                onStart: function(){
                    if (!video.paused) video.pause();
                },
                onStop: function(val){
                    if (video.seekable.length > 0) {
                        video.currentTime = (that.duration * val / 100).toFixed(0);
                    }
                    if (video.paused && video.currentTime > 0) {
                        video.play();
                    }
                }
            });

            this.stream = streamSlider;

            if (o.showStream !== true) {
                stream.hide();
            }

            Metro.makePlugin(volumeSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                hint: true,
                value: o.volume * 100,
                onChangeValue: function(val){
                    video.volume = val / 100;
                }
            });

            this.volume = volumeSlider;

            if (o.showVolume !== true) {
                volume.hide();
            }

            var loop;

            if (o.showLoop === true) loop = $("<button>").attr("type", "button").addClass("button square loop").html(o.loopIcon).appendTo(controls);
            if (o.showPlay === true) $("<button>").attr("type", "button").addClass("button square play").html(o.playIcon).appendTo(controls);
            if (o.showStop === true) $("<button>").attr("type", "button").addClass("button square stop").html(o.stopIcon).appendTo(controls);
            if (o.showMute === true) $("<button>").attr("type", "button").addClass("button square mute").html(o.muteIcon).appendTo(controls);
            if (o.showFull === true) $("<button>").attr("type", "button").addClass("button square full").html(o.screenMoreIcon).appendTo(controls);

            if (o.loop === true) {
                loop.addClass("active");
                element.attr("loop", "loop");
            }

            this._setVolume();

            if (o.muted) {
                that.volumeBackup = video.volume;
                Metro.getPlugin(that.volume, 'slider').val(0);
                video.volume = 0;
            }

            infoBox.html("00:00 / 00:00");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options, video = this.elem, player = this.player;

            element.on("loadstart", function(){
                that.preloader.show();
            });

            element.on("loadedmetadata", function(){
                that.duration = video.duration.toFixed(0);
                that._setInfo(0, that.duration);
                Utils.exec(o.onMetadata, [video, player], element[0]);
            });

            element.on("canplay", function(){
                that._setBuffer();
                that.preloader.hide();
            });

            element.on("progress", function(){
                that._setBuffer();
            });

            element.on("timeupdate", function(){
                var position = Math.round(video.currentTime * 100 / that.duration);
                that._setInfo(video.currentTime, that.duration);
                Metro.getPlugin(that.stream, 'slider').val(position);
                Utils.exec(o.onTime, [video.currentTime, that.duration, video, player], element[0]);
            });

            element.on("waiting", function(){
                that.preloader.show();
            });

            element.on("loadeddata", function(){

            });

            element.on("play", function(){
                player.find(".play").html(o.pauseIcon);
                Utils.exec(o.onPlay, [video, player], element[0]);
                that._onMouse();
            });

            element.on("pause", function(){
                player.find(".play").html(o.playIcon);
                Utils.exec(o.onPause, [video, player], element[0]);
                that._offMouse();
            });

            element.on("stop", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onStop, [video, player], element[0]);
                that._offMouse();
            });

            element.on("ended", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onEnd, [video, player], element[0]);
                that._offMouse();
            });

            element.on("volumechange", function(){
                that._setVolume();
            });

            player.on(Metro.events.click, ".play", function(){
                if (video.paused) {
                    that.play();
                } else {
                    that.pause();
                }
            });

            player.on(Metro.events.click, ".stop", function(){
                that.stop();
            });

            player.on(Metro.events.click, ".mute", function(){
                that._toggleMute();
            });

            player.on(Metro.events.click, ".loop", function(){
                that._toggleLoop();
            });

            player.on(Metro.events.click, ".full", function(){
                that.fullscreen = !that.fullscreen;
                player.find(".full").html(that.fullscreen === true ? o.screenLessIcon : o.screenMoreIcon);
                if (o.fullScreenMode === Metro.fullScreenMode.WINDOW) {
                    if (that.fullscreen === true) {
                        player.addClass("full-screen");
                    } else {
                        player.removeClass("full-screen");
                    }
                } else {
                    if (that.fullscreen === true) {

                        Metro.requestFullScreen(video);

                        if (that.fullScreenInterval === false) that.fullScreenInterval = setInterval(function(){
                            if (Metro.inFullScreen() === false) {
                                that.fullscreen = false;
                                clearInterval(that.fullScreenInterval);
                                that.fullScreenInterval = false;
                                player.find(".full").html(o.screenMoreIcon);
                            }

                        }, 1000);
                    } else {
                        Metro.exitFullScreen();
                    }
                }

                // if (that.fullscreen === true) {
                //     $(document).on(Metro.events.keyup + ".video-player", function(e){
                //         if (e.keyCode === 27) {
                //             player.find(".full").click();
                //         }
                //     });
                // } else {
                //     $(document).off(Metro.events.keyup + ".video-player");
                // }
            });

            $(window).on(Metro.events.keyup, function(e){
                if (that.fullscreen && e.keyCode === 27) {
                    player.find(".full").click();
                }
            }, {ns: this.id});

            $(window).on(Metro.events.resize, function(){
                that._setAspectRatio();
            }, {ns: this.id});

        },

        _onMouse: function(){
            var o = this.options, player = this.player;

            player.on(Metro.events.enter, function(){
                var controls = player.find(".controls");
                if (o.controlsHide > 0 && controls.style('display') === 'none') {
                    controls.stop(true).fadeIn(500, function(){
                        controls.css("display", "flex");
                    });
                }
            });

            player.on(Metro.events.leave, function(){
                var controls = player.find(".controls");
                if (o.controlsHide > 0 && parseInt(controls.style('opacity')) === 1) {
                    setTimeout(function () {
                        controls.stop(true).fadeOut(500);
                    }, o.controlsHide);
                }
            });
        },

        _offMouse: function(){
            var player = this.player, o = this.options;
            var controls = player.find(".controls");

            player.off(Metro.events.enter);
            player.off(Metro.events.leave);

            if (o.controlsHide > 0 && controls.style('display') === 'none') {
                controls.stop(true).fadeIn(500, function(){
                    controls.css("display", "flex");
                });
            }
        },

        _toggleLoop: function(){
            var loop = this.player.find(".loop");
            if (loop.length === 0) return ;
            loop.toggleClass("active");
            if (loop.hasClass("active")) {
                this.element.attr("loop", "loop");
            } else {
                this.element.removeAttr("loop");
            }
        },

        _toggleMute: function(){
            this.muted = !this.muted;
            if (this.muted === false) {
                this.video.volume = this.volumeBackup;
            } else {
                this.volumeBackup = this.video.volume;
                this.video.volume = 0;
            }
            Metro.getPlugin(this.volume, 'slider').val(this.muted === false ? this.volumeBackup * 100 : 0);
        },

        _setInfo: function(a, b){
            this.player.find(".info-box").html(Utils.secondsToFormattedString(Math.round(a)) + " / " + Utils.secondsToFormattedString(Math.round(b)));
        },

        _setBuffer: function(){
            var buffer = this.video.buffered.length ? Math.round(Math.floor(this.video.buffered.end(0)) / Math.floor(this.video.duration) * 100) : 0;
            Metro.getPlugin(this.stream, 'slider').buff(buffer);
        },

        _setVolume: function(){
            var video = this.video, player = this.player, o = this.options;

            var volumeButton = player.find(".mute");
            var volume = video.volume * 100;
            if (volume > 1 && volume < 30) {
                volumeButton.html(o.volumeLowIcon);
            } else if (volume >= 30 && volume < 60) {
                volumeButton.html(o.volumeMediumIcon);
            } else if (volume >= 60 && volume <= 100) {
                volumeButton.html(o.volumeHighIcon);
            } else {
                volumeButton.html(o.muteIcon);
            }
        },

        _setAspectRatio: function(){
            var player = this.player, o = this.options;
            var width = player.outerWidth();
            var height;

            switch (o.aspectRatio) {
                case Metro.aspectRatio.SD: height = Utils.aspectRatioH(width, "4/3"); break;
                case Metro.aspectRatio.CINEMA: height = Utils.aspectRatioH(width, "21/9"); break;
                default: height = Utils.aspectRatioH(width, "16/9");
            }

            player.outerHeight(height);
        },

        aspectRatio: function(ratio){
            this.options.aspectRatio = ratio;
            this._setAspectRatio();
        },

        play: function(src){
            if (src !== undefined) {
                this._setSource(src);
            }

            if (this.element.attr("src") === undefined && this.element.find("source").length === 0) {
                return ;
            }

            this.isPlaying = true;

            this.video.play();
        },

        pause: function(){
            this.isPlaying = false;
            this.video.pause();
        },

        resume: function(){
            if (this.video.paused) {
                this.play();
            }
        },

        stop: function(){
            this.isPlaying = false;
            this.video.pause();
            this.video.currentTime = 0;
            Metro.getPlugin(this.stream, 'slider').val(0);
            this._offMouse();
        },

        setVolume: function(v){
            if (v === undefined) {
                return this.video.volume;
            }

            if (v > 1) {
                v /= 100;
            }

            this.video.volume = v;
            Metro.getPlugin(this.volume[0], 'slider').val(v*100);
        },

        loop: function(){
            this._toggleLoop();
        },

        mute: function(){
            this._toggleMute();
        },

        changeAspectRatio: function(){
            this.options.aspectRatio = this.element.attr("data-aspect-ratio");
            this._setAspectRatio();
        },

        changeSource: function(){
            var src = JSON.parse(this.element.attr('data-src'));
            this.play(src);
        },

        changeVolume: function(){
            var volume = this.element.attr("data-volume");
            this.setVolume(volume);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-aspect-ratio": this.changeAspectRatio(); break;
                case "data-src": this.changeSource(); break;
                case "data-volume": this.changeVolume(); break;
            }
        },

        destroy: function(){
            var element = this.element, player = this.player;

            Metro.getPlugin(this.stream, "slider").destroy();
            Metro.getPlugin(this.volume, "slider").destroy();

            element.off("loadstart");
            element.off("loadedmetadata");
            element.off("canplay");
            element.off("progress");
            element.off("timeupdate");
            element.off("waiting");
            element.off("loadeddata");
            element.off("play");
            element.off("pause");
            element.off("stop");
            element.off("ended");
            element.off("volumechange");

            player.off(Metro.events.click, ".play");
            player.off(Metro.events.click, ".stop");
            player.off(Metro.events.click, ".mute");
            player.off(Metro.events.click, ".loop");
            player.off(Metro.events.click, ".full");

            $(window).off(Metro.events.keyup,{ns: this.id});
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var ViewportCheckDefaultConfig = {
        onViewport: Metro.noop,
        onViewportEnter: Metro.noop,
        onViewportLeave: Metro.noop,
        onViewportCheckCreate: Metro.noop
    };

    Metro.viewportCheckSetup = function (options) {
        ViewportCheckDefaultConfig = $.extend({}, ViewportCheckDefaultConfig, options);
    };

    if (typeof window["metroViewportCheckSetup"] !== undefined) {
        Metro.viewportCheckSetup(window["metroViewportCheckSetup"]);
    }

    Metro.Component('viewport-check', {
        init: function( options, elem ) {
            this._super(elem, options, ViewportCheckDefaultConfig, {
                // define instance vars here
                inViewport: false,
                id: Utils.elementId("viewport-check")
            });
            return this;
        },

        _create: function(){
            this.inViewport = Utils.inViewport(this.elem);

            this._createEvents();

            this._fireEvent('viewport-check-create');
        },

        _createEvents: function(){
            var that = this, elem = this.elem;

            $(window).on(Metro.events.scroll, function(){
                var oldState = that.inViewport;

                that.inViewport = Utils.inViewport(elem);

                if (oldState !== that.inViewport) {
                    if (that.inViewport) {
                        that._fireEvent("viewport-enter");
                    } else {
                        that._fireEvent("viewport-leave");
                    }
                }

                that._fireEvent("viewport", {
                    state: that.inViewport
                });
            }, {ns: that.id});
        },

        state: function(){
            return this.inViewport;
        },

        destroy: function(){
            $(window).off(Metro.events.scroll, {ns: this.id});

            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var WindowDefaultConfig = {
        windowDeferred: 0,
        hidden: false,
        width: "auto",
        height: "auto",
        btnClose: true,
        btnMin: true,
        btnMax: true,
        draggable: true,
        dragElement: ".window-caption .icon, .window-caption .title",
        dragArea: "parent",
        shadow: false,
        icon: "",
        title: "Window",
        content: null,
        resizable: true,
        overlay: false,
        overlayColor: 'transparent',
        overlayAlpha: .5,
        modal: false,
        position: "absolute",
        checkEmbed: true,
        top: "auto",
        left: "auto",
        place: "auto",
        closeAction: Metro.actions.REMOVE,
        customButtons: null,

        clsCustomButton: "",
        clsCaption: "",
        clsContent: "",
        clsWindow: "",

        _runtime: false,

        minWidth: 0,
        minHeight: 0,
        maxWidth: 0,
        maxHeight: 0,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onCaptionDblClick: Metro.noop,
        onCloseClick: Metro.noop,
        onMaxClick: Metro.noop,
        onMinClick: Metro.noop,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResize: Metro.noop,
        onWindowCreate: Metro.noop,
        onShow: Metro.noop,
        onWindowDestroy: Metro.noop,
        onCanClose: Metro.noop_true,
        onClose: Metro.noop
    };

    Metro.windowSetup = function (options) {
        WindowDefaultConfig = $.extend({}, WindowDefaultConfig, options);
    };

    if (typeof window["metroWindowSetup"] !== undefined) {
        Metro.windowSetup(window["metroWindowSetup"]);
    }

    Metro.Component('window', {
        init: function( options, elem ) {
            this._super(elem, options, WindowDefaultConfig, {
                win: null,
                overlay: null,
                position: {
                    top: 0,
                    left: 0
                },
                hidden: false,
                content: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var win, overlay;
            var parent = o.dragArea === "parent" ? element.parent() : $(o.dragArea);

            if (o.modal === true) {
                o.btnMax = false;
                o.btnMin = false;
                o.resizable = false;
            }

            if (Utils.isNull(o.content)) {
                o.content = element;
            } else {
                if (Utils.isUrl(o.content) && Utils.isVideoUrl(o.content)) {
                    o.content = Utils.embedUrl(o.content);
                    element.css({
                        height: "100%"
                    });
                } else

                if (!Utils.isQ(o.content) && Utils.isFunc(o.content)) {
                    o.content = Utils.exec(o.content);
                }

                element.append(o.content);
                o.content = element;
            }

            if (o._runtime === true) {
                this._runtime(element, "window");
            }

            win = this._window(o);
            win.addClass("no-visible");

            parent.append(win);

            if (o.overlay === true) {
                overlay = this._overlay();
                overlay.appendTo(win.parent());
                this.overlay = overlay;
            }

            this.win = win;

            this._fireEvent("window-create", {
                win: this.win[0],
                element: element
            });

            setTimeout(function(){
                that._setPosition();

                if (o.hidden !== true) {
                    that.win.removeClass("no-visible");
                }

                that._fireEvent("show", {
                    win: that.win[0],
                    element: element
                });
            }, 100);
        },

        _setPosition: function(){
            var o = this.options;
            var win = this.win;
            var parent = o.dragArea === "parent" ? win.parent() : $(o.dragArea);
            var top_center = parent.height() / 2 - win[0].offsetHeight / 2;
            var left_center = parent.width() / 2 - win[0].offsetWidth / 2;
            var top, left, right, bottom;

            if (o.place !== 'auto') {

                switch (o.place.toLowerCase()) {
                    case "top-left": top = 0; left = 0; right = "auto"; bottom = "auto"; break;
                    case "top-center": top = 0; left = left_center; right = "auto"; bottom = "auto"; break;
                    case "top-right": top = 0; right = 0; left = "auto"; bottom = "auto"; break;
                    case "right-center": top = top_center; right = 0; left = "auto"; bottom = "auto"; break;
                    case "bottom-right": bottom = 0; right = 0; left = "auto"; top = "auto"; break;
                    case "bottom-center": bottom = 0; left = left_center; right = "auto"; top = "auto"; break;
                    case "bottom-left": bottom = 0; left = 0; right = "auto"; top = "auto"; break;
                    case "left-center": top = top_center; left = 0; right = "auto"; bottom = "auto"; break;
                    default: top = top_center; left = left_center; bottom = "auto"; right = "auto";
                }

                win.css({
                    top: top,
                    left: left,
                    bottom: bottom,
                    right: right
                });
            }
        },

        _window: function(o){
            var that = this;
            var win, caption, content, icon, title, buttons, btnClose, btnMin, btnMax, resizer, status;
            var width = o.width, height = o.height;

            win = $("<div>").addClass("window");

            if (o.modal === true) {
                win.addClass("modal");
            }

            caption = $("<div>").addClass("window-caption");
            content = $("<div>").addClass("window-content");

            win.append(caption);
            win.append(content);

            if (o.status === true) {
                status = $("<div>").addClass("window-status");
                win.append(status);
            }

            if (o.shadow === true) {
                win.addClass("win-shadow");
            }

            if (Utils.isValue(o.icon)) {
                icon = $("<span>").addClass("icon").html(o.icon);
                icon.appendTo(caption);
            }

            title = $("<span>").addClass("title").html(Utils.isValue(o.title) ? o.title : "&nbsp;");
            title.appendTo(caption);

            if (!Utils.isNull(o.content)) {

                if (Utils.isQ(o.content)) {
                    o.content.appendTo(content);
                } else {
                    content.html(o.content);
                }
            }

            buttons = $("<div>").addClass("buttons");
            buttons.appendTo(caption);

            if (o.btnMax === true) {
                btnMax = $("<span>").addClass("button btn-max sys-button");
                btnMax.appendTo(buttons);
            }

            if (o.btnMin === true) {
                btnMin = $("<span>").addClass("button btn-min sys-button");
                btnMin.appendTo(buttons);
            }

            if (o.btnClose === true) {
                btnClose = $("<span>").addClass("button btn-close sys-button");
                btnClose.appendTo(buttons);
            }

            if (Utils.isValue(o.customButtons)) {
                var customButtons = [];

                if (Utils.isObject(o.customButtons) !== false) {
                    o.customButtons = Utils.isObject(o.customButtons);
                }

                if (typeof o.customButtons === "string" && o.customButtons.indexOf("{") > -1) {
                    customButtons = JSON.parse(o.customButtons);
                } else if (typeof o.customButtons === "object" && Utils.objectLength(o.customButtons) > 0) {
                    customButtons = o.customButtons;
                } else {
                    console.warn("Unknown format for custom buttons");
                }

                $.each(customButtons, function(){
                    var item = this;
                    var customButton = $("<span>");

                    customButton
                        .addClass("button btn-custom")
                        .addClass(o.clsCustomButton)
                        .addClass(item.cls)
                        .attr("tabindex", -1)
                        .html(item.html);

                    if (item.attr && typeof item.attr === 'object') {
                        $.each(item.attr, function(k, v){
                            customButton.attr($.dashedName(k), v);
                        });
                    }

                    customButton.data("action", item.onclick);

                    buttons.prepend(customButton);
                });
            }

            caption.on(Metro.events.stop, ".btn-custom", function(e){
                if (Utils.isRightMouse(e)) return;
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [button], this);
            });

            win.attr("id", o.id === undefined ? Utils.elementId("window") : o.id);

            win.on(Metro.events.dblclick, ".window-caption", function(e){
                that.maximized(e);
            });

            caption.on(Metro.events.click, ".btn-max, .btn-min, .btn-close", function(e){
                if (Utils.isRightMouse(e)) return;
                var target = $(e.target);
                if (target.hasClass("btn-max")) that.maximized(e);
                if (target.hasClass("btn-min")) that.minimized(e);
                if (target.hasClass("btn-close")) that.close(e);
            });

            if (o.draggable === true) {
                Metro.makePlugin(win, "draggable", {
                    dragContext: win[0],
                    dragElement: o.dragElement,
                    dragArea: o.dragArea,
                    onDragStart: o.onDragStart,
                    onDragStop: o.onDragStop,
                    onDragMove: o.onDragMove
                });
            }

            win.addClass(o.clsWindow);
            caption.addClass(o.clsCaption);
            content.addClass(o.clsContent);

            if (o.minWidth === 0) {
                o.minWidth = 34;
                $.each(buttons.children(".btn-custom"), function(){
                    o.minWidth += Utils.hiddenElementSize(this).width;
                });
                if (o.btnMax) o.minWidth += 34;
                if (o.btnMin) o.minWidth += 34;
                if (o.btnClose) o.minWidth += 34;
            }

            if (o.minWidth > 0 && !isNaN(o.width) && o.width < o.minWidth) {
                width = o.minWidth;
            }
            if (o.minHeight > 0 && !isNaN(o.height) && o.height > o.minHeight) {
                height = o.minHeight;
            }

            if (o.resizable === true) {
                resizer = $("<span>").addClass("resize-element");
                resizer.appendTo(win);
                win.addClass("resizable");

                Metro.makePlugin(win, "resizable", {
                    minWidth: o.minWidth,
                    minHeight: o.minHeight,
                    maxWidth: o.maxWidth,
                    maxHeight: o.maxHeight,
                    resizeElement: ".resize-element",
                    onResizeStart: o.onResizeStart,
                    onResizeStop: o.onResizeStop,
                    onResize: o.onResize
                });
            }

            win.css({
                width: width,
                height: height,
                position: o.position,
                top: o.top,
                left: o.left
            });

            return win;
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay");

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Utils.hex2rgba(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        width: function(v){
            var win = this.win;

            if (!Utils.isValue(v)) {
                return win.width();
            }

            win.css("width", parseInt(v));

            return this;
        },

        height: function(v){
            var win = this.win;

            if (!Utils.isValue(v)) {
                return win.height();
            }

            win.css("height", parseInt(v));

            return this;
        },

        maximized: function(e){
            var win = this.win, o = this.options;
            var target = $(e.currentTarget);

            if (o.btnMax) {
                win.removeClass("minimized");
                win.toggleClass("maximized");
            }

            if (target.hasClass && target.hasClass("window-caption")) {

                this._fireEvent("caption-dbl-click", {
                    win: win[0]
                });

            } else {

                this._fireEvent("max-click", {
                    win: win[0]
                });

            }
        },

        minimized: function(){
            var win = this.win, o = this.options;

            if (o.btnMin) {
                win.removeClass("maximized");
                win.toggleClass("minimized");
            }

            this._fireEvent("min-click", {
                win: win[0]
            });
        },

        close: function(){
            var that = this, win = this.win,  o = this.options;

            if (Utils.exec(o.onCanClose, [win]) === false) {
                return false;
            }

            var timeout = 0;

            if (o.onClose !== Metro.noop) {
                timeout = 500;
            }

            this._fireEvent("close", {
                win: win[0]
            });

            setTimeout(function(){
                if (o.modal === true) {
                    win.siblings(".overlay").remove();
                }

                that._fireEvent("close-click", {
                    win: win[0]
                });

                if (o.closeAction === Metro.actions.REMOVE) {
                    that._fireEvent("window-destroy", {
                        win: win[0]
                    });
                    win.remove();
                } else {
                    that.hide();
                }

            }, timeout);
        },

        hide: function(){
            var win = this.win;

            win.css({
                display: "none"
            });

            this._fireEvent("hide", {
                win: win[0]
            });
        },

        show: function(){
            var win = this.win;

            win
                .removeClass("no-visible")
                .css({
                    display: "flex"
                });

            this._fireEvent("show", {
                win: win[0]
            });

        },

        toggle: function(){
            if (this.win.css("display") === "none" || this.win.hasClass("no-visible")) {
                this.show();
            } else {
                this.hide();
            }
        },

        isOpen: function(){
            return this.win.hasClass("no-visible");
        },

        min: function(a){
            a ? this.win.addClass("minimized") : this.win.removeClass("minimized");
        },

        max: function(a){
            a ? this.win.addClass("maximized") : this.win.removeClass("maximized");
        },

        changeClass: function(a){
            var element = this.element, win = this.win, o = this.options;

            if (a === "data-cls-window") {
                win[0].className = "window " + (o.resizable ? " resizable " : " ") + element.attr("data-cls-window");
            }
            if (a === "data-cls-caption") {
                win.find(".window-caption")[0].className = "window-caption " + element.attr("data-cls-caption");
            }
            if (a === "data-cls-content") {
                win.find(".window-content")[0].className = "window-content " + element.attr("data-cls-content");
            }
        },

        toggleShadow: function(){
            var element = this.element, win = this.win;
            var flag = JSON.parse(element.attr("data-shadow"));
            if (flag === true) {
                win.addClass("win-shadow");
            } else {
                win.removeClass("win-shadow");
            }
        },

        setContent: function(c){
            var element = this.element, win = this.win;
            var content = Utils.isValue(c) ? c : element.attr("data-content");
            var result;

            if (!Utils.isQ(content) && Utils.isFunc(content)) {
                result = Utils.exec(content);
            } else if (Utils.isQ(content)) {
                result = content.html();
            } else {
                result = content;
            }

            win.find(".window-content").html(result);
        },

        setTitle: function(t){
            var element = this.element, win = this.win;
            var title = Utils.isValue(t) ? t : element.attr("data-title");
            win.find(".window-caption .title").html(title);
        },

        setIcon: function(i){
            var element = this.element, win = this.win;
            var icon = Utils.isValue(i) ? i : element.attr("data-icon");
            win.find(".window-caption .icon").html(icon);
        },

        getIcon: function(){
            return this.win.find(".window-caption .icon").html();
        },

        getTitle: function(){
            return this.win.find(".window-caption .title").html();
        },

        toggleDraggable: function(f){
            var win = this.win;
            var flag = Utils.bool(f);
            var drag = Metro.getPlugin(win, "draggable");
            if (flag === true) {
                drag.on();
            } else {
                drag.off();
            }
        },

        toggleResizable: function(f){
            var win = this.win;
            var flag = Utils.bool(f);
            var resize = Metro.getPlugin(win, "resizable");
            if (flag === true) {
                resize.on();
                win.find(".resize-element").removeClass("resize-element-disabled");
            } else {
                resize.off();
                win.find(".resize-element").addClass("resize-element-disabled");
            }
        },

        changePlace: function (p) {
            var element = this.element, win = this.win;
            var place = Utils.isValue(p) ? p : element.attr("data-place");
            win.addClass(place);
        },

        pos: function(top, left){
            var win = this.win;
            win.css({
                top: top,
                left: left
            });
            return this;
        },

        top: function(v){
            this.win.css({
                top: v
            });
            return this;
        },

        left: function(v){
            this.win.css({
                left: v
            });
            return this;
        },

        changeAttribute: function(attr, value){
            var changePos = function(a, v){
                var win = this.win;
                var pos;
                if (a === "data-top") {
                    pos = parseInt(v);
                    if (!isNaN(pos)) {
                        return ;
                    }
                    win.css("top", pos);
                }
                if (a === "data-left") {
                    pos = parseInt(v);
                    if (!isNaN(pos)) {
                        return ;
                    }
                    win.css("left", pos);
                }
            };

            var toggleButtons = function(a, v) {
                var win = this.win;
                var btnClose = win.find(".btn-close");
                var btnMin = win.find(".btn-min");
                var btnMax = win.find(".btn-max");
                var _v = Utils.bool(v);
                var func = _v ? "show" : "hide";

                switch (a) {
                    case "data-btn-close": btnClose[func](); break;
                    case "data-btn-min": btnMin[func](); break;
                    case "data-btn-max": btnMax[func](); break;
                }
            };

            var changeSize = function(a, v){
                var win = this.win;
                if (a === "data-width") {
                    win.css("width", +v);
                }
                if (a === "data-height") {
                    win.css("height", +v);
                }
            };

            switch (attr) {
                case "data-btn-close":
                case "data-btn-min":
                case "data-btn-max": toggleButtons(attr, value); break;
                case "data-width":
                case "data-height": changeSize(attr, value); break;
                case "data-cls-window":
                case "data-cls-caption":
                case "data-cls-content": this.changeClass(attr); break;
                case "data-shadow": this.toggleShadow(); break;
                case "data-icon": this.setIcon(); break;
                case "data-title": this.setTitle(); break;
                case "data-content": this.setContent(); break;
                case "data-draggable": this.toggleDraggable(value); break;
                case "data-resizable": this.toggleResizable(value); break;
                case "data-top":
                case "data-left": changePos(attr, value); break;
                case "data-place": this.changePlace(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['window'] = {

        isWindow: function(el){
            return Utils.isMetroObject(el, "window");
        },

        min: function(el, a){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el,"window").min(a);
        },

        max: function(el, a){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").max(a);
        },

        show: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").show();
        },

        hide: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").hide();
        },

        toggle: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").toggle();
        },

        isOpen: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            var win = Metro.getPlugin(el,"window");
            return win.isOpen();
        },

        close: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").close();
        },

        pos: function(el, top, left){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").pos(top, left);
        },

        top: function(el, top){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").top(top);
        },

        left: function(el, left){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").left(left);
        },

        width: function(el, width){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").width(width);
        },

        height: function(el, height){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").height(height);
        },

        create: function(options){
            var w;

            w = $("<div>").appendTo($("body"));

            var w_options = $.extend({}, {
            }, (options !== undefined ? options : {}));

            w_options._runtime = true;

            return Metro.makePlugin(w, "window", w_options);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var WizardDefaultConfig = {
        wizardDeferred: 0,
        start: 1,
        finish: 0,
        iconHelp: "<span class='default-icon-help'></span>",
        iconPrev: "<span class='default-icon-left-arrow'></span>",
        iconNext: "<span class='default-icon-right-arrow'></span>",
        iconFinish: "<span class='default-icon-check'></span>",

        buttonMode: "cycle", // default, cycle, square
        buttonOutline: true,
        duration: 300,

        clsWizard: "",
        clsActions: "",
        clsHelp: "",
        clsPrev: "",
        clsNext: "",
        clsFinish: "",

        onPage: Metro.noop,
        onNextPage: Metro.noop,
        onPrevPage: Metro.noop,
        onFirstPage: Metro.noop,
        onLastPage: Metro.noop,
        onFinishPage: Metro.noop,
        onHelpClick: Metro.noop,
        onPrevClick: Metro.noop,
        onNextClick: Metro.noop,
        onFinishClick: Metro.noop,
        onBeforePrev: Metro.noop_true,
        onBeforeNext: Metro.noop_true,
        onWizardCreate: Metro.noop
    };

    Metro.wizardSetup = function (options) {
        WizardDefaultConfig = $.extend({}, WizardDefaultConfig, options);
    };

    if (typeof window["metroWizardSetup"] !== undefined) {
        Metro.wizardSetup(window["metroWizardSetup"]);
    }

    Metro.Component('wizard', {
        init: function( options, elem ) {
            this._super(elem, options, WizardDefaultConfig, {
                id: Utils.elementId('wizard')
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createWizard();
            this._createEvents();

            this._fireEvent("wizard-create", {
                element: element
            });
        },

        _createWizard: function(){
            var element = this.element, o = this.options;
            var bar;

            element.addClass("wizard").addClass(o.view).addClass(o.clsWizard);

            bar = $("<div>").addClass("action-bar").addClass(o.clsActions).appendTo(element);

            var buttonMode = o.buttonMode === "button" ? "" : o.buttonMode;
            if (o.buttonOutline === true) {
                buttonMode += " outline";
            }

            if (o.iconHelp !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-help").addClass(buttonMode).addClass(o.clsHelp).html(Utils.isTag(o.iconHelp) ? o.iconHelp : $("<img>").attr('src', o.iconHelp)).appendTo(bar);
            if (o.iconPrev !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-prev").addClass(buttonMode).addClass(o.clsPrev).html(Utils.isTag(o.iconPrev) ? o.iconPrev : $("<img>").attr('src', o.iconPrev)).appendTo(bar);
            if (o.iconNext !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-next").addClass(buttonMode).addClass(o.clsNext).html(Utils.isTag(o.iconNext) ? o.iconNext : $("<img>").attr('src', o.iconNext)).appendTo(bar);
            if (o.iconFinish !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-finish").addClass(buttonMode).addClass(o.clsFinish).html(Utils.isTag(o.iconFinish) ? o.iconFinish : $("<img>").attr('src', o.iconFinish)).appendTo(bar);

            this.toPage(o.start);

            this._setHeight();
        },

        _setHeight: function(){
            var element = this.element;
            var pages = element.children("section");
            var max_height = 0;

            pages.children(".page-content").css("max-height", "none");

            $.each(pages, function(){
                var h = $(this).height();
                if (max_height < parseInt(h)) {
                    max_height = h;
                }
            });

            element.height(max_height);
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".wizard-btn-help", function(){
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("help-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-prev", function(){
                that.prev();
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("prev-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-next", function(){
                that.next();
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("next-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-finish", function(){
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("finish-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".complete", function(){
                var index = $(this).index() + 1;
                that.toPage(index);
            });

            $(window).on(Metro.events.resize, function(){
                that._setHeight();
            }, {ns: this.id});
        },

        next: function(){
            var that = this, element = this.element, o = this.options;
            var pages = element.children("section");
            var page = $(element.children("section").get(this.current - 1));

            if (this.current + 1 > pages.length || Utils.exec(o.onBeforeNext, [this.current, page, element]) === false) {
                return ;
            }

            this.current++;

            this.toPage(this.current);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("next-page", {
                index: that.current,
                page: page[0]
            });
        },

        prev: function(){
            var that = this, element = this.element, o = this.options;
            var page = $(element.children("section").get(this.current - 1));

            if (this.current - 1 === 0 || Utils.exec(o.onBeforePrev, [this.current, page, element]) === false) {
                return ;
            }

            this.current--;

            this.toPage(this.current);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("prev-page", {
                index: that.current,
                page: page[0]
            });
        },

        last: function(){
            var that = this, element = this.element;
            var page;

            this.toPage(element.children("section").length);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("last-page", {
                index: that.current,
                page: page[0]
            });
        },

        first: function(){
            var that = this, element = this.element;
            var page;

            this.toPage(1);

            page = $(element.children("section").get(0));

            this._fireEvent("first-page", {
                index: that.current,
                page: page[0]
            });
        },

        toPage: function(page){
            var element = this.element, o = this.options;
            var target = $(element.children("section").get(page - 1));
            var sections = element.children("section");
            var actions = element.find(".action-bar");

            if (target.length === 0) {
                return ;
            }

            var finish = element.find(".wizard-btn-finish").addClass("disabled");
            var next = element.find(".wizard-btn-next").addClass("disabled");
            var prev = element.find(".wizard-btn-prev").addClass("disabled");

            this.current = page;

            element.children("section")
                .removeClass("complete current")
                .removeClass(o.clsCurrent)
                .removeClass(o.clsComplete);

            target.addClass("current").addClass(o.clsCurrent);
            target.prevAll().addClass("complete").addClass(o.clsComplete);

            var border_size = element.children("section.complete").length === 0 ? 0 : parseInt(Utils.getStyleOne(element.children("section.complete")[0], "border-left-width"));

            actions.animate({
                draw: {
                    left: element.children("section.complete").length * border_size + 41
                },
                dur: o.duration
            });

            if (
                (this.current === sections.length) || (o.finish > 0 && this.current >= o.finish)
            ) {
                finish.removeClass("disabled");
            }

            if (parseInt(o.finish) > 0 && this.current === parseInt(o.finish)) {

                this._fireEvent("finish-page", {
                    index: this.current,
                    page: target[0]
                });
            }

            if (this.current < sections.length) {
                next.removeClass("disabled");
            }

            if (this.current > 1) {
                prev.removeClass("disabled");
            }

            this._fireEvent("page", {
                index: this.current,
                page: target[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".wizard-btn-help");
            element.off(Metro.events.click, ".wizard-btn-prev");
            element.off(Metro.events.click, ".wizard-btn-next");
            element.off(Metro.events.click, ".wizard-btn-finish");
            element.off(Metro.events.click, ".complete");
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));